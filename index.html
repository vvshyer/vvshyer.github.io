<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://sunhuayan.tech">
  <title>MineMine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Stay Hungry. Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="MineMine">
<meta property="og:url" content="https://sunhuayan.tech/index.html">
<meta property="og:site_name" content="MineMine">
<meta property="og:description" content="Stay Hungry. Stay Foolish.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MineMine">
<meta name="twitter:description" content="Stay Hungry. Stay Foolish.">
  
    <link rel="alternative" href="/atom.xml" title="MineMine" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.2d7529.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/photo.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">SUN Huayan</a></h1>
		</hgroup>
		
		<p class="header-subtitle">Stay Hungry. Stay Foolish.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://www.github.com/vvshyer" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/5291886920" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/vvshyer" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="mail" target="_blank" href="/sunhuayanchn@gmail.com" title="mail"><i class="icon-mail"></i></a>
		        
					<a class="twitter" target="_blank" href="https://twitter.com/huayan_sun" title="twitter"><i class="icon-twitter"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">SUN Huayan</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>Stay Hungry. Stay Foolish.<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://www.github.com/vvshyer" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5291886920" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/vvshyer" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="mail" target="_blank" href="/sunhuayanchn@gmail.com" title="mail"><i class="icon-mail"></i></a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/huayan_sun" title="twitter"><i class="icon-twitter"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-学习词根—第一天" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/06/学习词根—第一天/">学习词根---第一天</a>
    </h1>
  

        
        <a href="/2018/03/06/学习词根—第一天/" class="archive-article-date">
  	<time datetime="2018-03-06T10:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-03-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通过Merrian-Webster’s-Vocabulary-Builder学习词根—第一天"><a href="#通过Merrian-Webster’s-Vocabulary-Builder学习词根—第一天" class="headerlink" title="通过Merrian-Webster’s Vocabulary Builder学习词根—第一天"></a>通过Merrian-Webster’s Vocabulary Builder学习词根—第一天</h1><p>韦氏三宝之一的绿皮书，被广大英语学习者亲切称呼为“小绿”。近日偶然在书柜中发现了这本被我买来就弃置不理长达四年的宝书，决定好好学习一番。</p>
<p>本书一共<strong>30个单元</strong>，为了记得牢固，打算<strong>一周一个单元</strong>，<strong>一天两个词根十六个单词</strong>。简单的部分直接翻译了，为了保证原汁原味的理解，哲理性的语句和小故事都直接原文展示。</p>
<h2 id="Unit-1"><a href="#Unit-1" class="headerlink" title="Unit 1"></a>Unit 1</h2><hr>
<p><strong>词根 BENE.</strong> 源自拉丁“well”. A benefit is a good result or effect. Something beneficial produces good results or effects. 你常常可在其他语言中听到拉丁词根：”Good”或者”Fine”在西班牙语中是”Bueno”；在法语中是”Bon”；在意大利语中是”Bene”</p>
<hr>
<p><strong>benediction.</strong> A prayer that asks for God’s blessing, especially a prayer that concludes a worship services.</p>
<blockquote>
<p>例句：The moment the bishop had finished his benediction, she squeezed quickly out of her row and darted out the cathedral’s side entrance.</p>
</blockquote>
<p>在benediction这个单词中，bene词根源自另一个拉丁词根dictio(意为speaking)，所以这个单词的意思有点像”well-wishing”. 可能最出名的benediction是《圣经》中Aaronic Benediction，即那句“May the Lord bless you and keep you”.</p>
<h2 id="gt-An-important-section-of-the-Catholic-Mass-was-traditionally-known-as-the-Benedictus-after-its-first-word-meaning-“blessed”-It-was-St-Benedict-who-organized-the-first-Christian-monasteries-many-Christians-have-been-baptized-Benedict-in-his-honor-and-16-popes-have-taken-it-as-their-papal-name"><a href="#gt-An-important-section-of-the-Catholic-Mass-was-traditionally-known-as-the-Benedictus-after-its-first-word-meaning-“blessed”-It-was-St-Benedict-who-organized-the-first-Christian-monasteries-many-Christians-have-been-baptized-Benedict-in-his-honor-and-16-popes-have-taken-it-as-their-papal-name" class="headerlink" title="&gt; An important section of the Catholic Mass was traditionally known as the Benedictus, after its first word (meaning “blessed”). It was St. Benedict who organized the first Christian monasteries; many Christians have been baptized Benedict in his honor, and 16 popes have taken it as their papal name."></a>&gt; An important section of the Catholic Mass was traditionally known as the Benedictus, after its first word (meaning “blessed”). It was St. Benedict who organized the first Christian monasteries; many Christians have been baptized Benedict in his honor, and 16 popes have taken it as their papal name.</h2><p><strong>benefactor.</strong> Someone who helps another person or group, especially by giving money.</p>
<blockquote>
<p>例句：An anonymous benefactor had given $15 million to establish an ecological institute at the university.</p>
</blockquote>
<p>benefactor是一个很好理解的词，对应中文中的好心人（特指资助）.如：资助贫困学生上学；资助贫困地区建设图书馆；捐赠遗体给医院以供医学研究。原文举了John D. Rockefeller为例，感兴趣的可以自查其光辉事迹。个人觉得 丛飞 很符合这个词所表达的意思。</p>
<hr>
<p><strong>beneficiary.</strong> A person or organization that benefits or is expected to benefit from something, especially one that receives money or property when someone dies.</p>
<blockquote>
<p>例句：Living in a trailer in near-poverty, she received word in the mail that her father had died, naming her as the sole beneficiary of his life-insurance policy.</p>
</blockquote>
<p>Beneficiary常被用在人生保险方面，在其他语境中还有如下的意思。</p>
<ol>
<li>A college may be the beneficiary of a private donation.</li>
<li>Your uncle’s will may make a church his sole beneficiary, in which case all his money and property will go to it when he dies.</li>
<li>A third-party beneficiary. 即 第三方受益人</li>
</ol>
<hr>
<p>benevolence. Kindness, generosity.</p>
<blockquote>
<p>例句：In those financially desperate years, the young couple was saved only by the benevolence of her elderly great-uncle.</p>
</blockquote>
<p>部分benevolence源自拉丁词根意为”wish”. Charles Dickens的小说中常常有一个在关键点救了主角的慷慨的人物。像是《雾都孤儿》里的Mr.Brownlow，《大卫科波菲尔》里的Abel Magwitch等。</p>
<p>To be benevolent, it helps to have money, but it’s not necessary; kind assistance of a non-financial sort may turn out to be lifesaving benevolence as well.</p>
<hr>
<p><strong>词根：AM</strong> 源自拉丁语amare, 意味”to love”. 罗马爱神有两个众所周知的名字，丘比特(Cupid)和Amor. Amiable意为”friendly or good-natured”。amigo在西班牙语中是”friend“的意思。</p>
<hr>
<p><strong>amicable.</strong> Friendly, peaceful.</p>
<blockquote>
<p>例句：Their relations with their in-laws were generally amicable, despite some bickering during the holidays.</p>
</blockquote>
<p>Amicable常常用来描述两个group之间的关系，尤其是两个nation之间。例如，美国和加拿大以有着世界上最大的不设防接壤边境而自豪。So we often speak of an amicable meeting or an amicable settlement.</p>
<p>When amicable describes more personal relations, it may indicate a rather formal friendliness. But it’s always nice when two friends who’ve been quarreling manage to have an amicable conversation and to say amicable good-byes at the end.</p>
<hr>
<p><strong>enamored.</strong> Charmed or fascinated; inflamed with love.</p>
<blockquote>
<p>例句：Rebecca quickly became enamored of the town’s rustic surroundings, its slow pace, and its eccentric characters.</p>
</blockquote>
<p>可以通过以下句子体会这个单词的含义：</p>
<ol>
<li>Computer hackers are always <strong>enamored of</strong> their new programs and games.</li>
<li>Millions of readers have found themselves <strong>enamored with</strong> Jane Austen’s novels.</li>
<li>Romeo and Juliet were, of course, utterly <strong>enamored of</strong> each other.</li>
</ol>
<p>有时也用在消极的语境中：</p>
<ol>
<li>A friend at work may complain that she’s not <strong>enamored of</strong> the new boss, and when you start talking about how you’re not <strong>enamored with</strong> neighbors it may be time to move.</li>
</ol>
<hr>
<p><strong>amorous.</strong> Having or showing strong feelings of attraction or love.</p>
<blockquote>
<p>例句：It turned out that the amorous Congressman had gotten his girlfriend a good job and was paying for her apartment.</p>
</blockquote>
<p>在公园长椅上亲吻的情侣、总是拥抱亲吻的年轻夫妇都可以用amorous形容。</p>
<p>But the word is often used a bit sarcastically, as when a tabloid(通俗小报) newspaper gets hold of some scandalous photos and calls the participants “the amorous pair”. In such case, we may be encouraged to think the attraction is more physical than emotional.</p>
<hr>
<p><strong>paramour.</strong> A lover, often secret, not allowed by law or custom.</p>
<blockquote>
<p>例句：He had been coming the house for two years before her brothers realized that he was actually the paramour of their shy and withdrawn sister.</p>
</blockquote>
<p>Paramour源自法语，现代法语已经弃用该词。Since par amour meant “through love”, it implies a relationship based solely on love, often physical love, rather than on social custom or ceremony. So today it tends to refer to the lover of a married man or a woman, but may be used for any lover who isn’t obeying the social rules.</p>
<hr>
<p><strong>Quizzes:</strong></p>
<p><strong>Choose the closest synonym:</strong></p>
<ol>
<li>beneficiary a.benefit b.prayer c.recipient d.contributor</li>
<li>amorous a.friendly b.sympathetic c.loving d.kind</li>
<li>benediction a.blessing b.gift c.saint d.favor</li>
<li>amicable a.difficult b.friendly c.curious d.lazy</li>
<li>enamored a.strengthened b.engaged c.fond d.free</li>
<li>benefactor a.supporter b.priest c.donation d.kindness</li>
<li>paramour a.lover b.husband c.heaven d.affection</li>
<li>benevolence a.value b.kindness c.luck d.approval</li>
</ol>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">English</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/03/06/学习词根—第一天/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Python Numpy 教程" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/10/Python Numpy 教程/">Python Numpy 教程</a>
    </h1>
  

        
        <a href="/2018/02/10/Python Numpy 教程/" class="archive-article-date">
  	<time datetime="2018-02-10T12:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-02-10</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python-Numpy-教程"><a href="#Python-Numpy-教程" class="headerlink" title="Python Numpy 教程"></a>Python Numpy 教程</h1><p>这篇教程由<a href="https://cs.stanford.edu/people/jcjohns/" target="_blank" rel="noopener">Justin Johnson</a>创作。</p>
<p>我们将使用Python编程语言来完成本课程的所有作业。Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。<br>我们期望你们中大多数人对于Python语言和Numpy库比较熟悉，而对于没有Python经验的同学，这篇教程可以帮助你们快速了解Python编程环境和如何使用Python作为科学计算工具。</p>
<p>一部分同学对于Matlab有一定经验。对于这部分同学，我们推荐阅读 <a href="http://scipy.github.io/old-wiki/pages/NumPy_for_Matlab_Users" target="_blank" rel="noopener">numpy for Matlab users</a>页面。</p>
<p>你们还可以查看本教程的<a href="https://github.com/kuleshov/cs228-material/blob/master/tutorials/python/cs228-python-tutorial.ipynb" target="_blank" rel="noopener">IPython notebook</a>版。该教程是由<a href="http://web.stanford.edu/~kuleshov/" target="_blank" rel="noopener">Volodymyr Kuleshov</a>和<a href="https://symsys.stanford.edu/viewing/symsysaffiliate/21335" target="_blank" rel="noopener">Isaac Caswell</a>为课程<a href="https://cs.stanford.edu/~ermon/cs228/index.html" target="_blank" rel="noopener">CS 228</a>创建的。</p>
<p>内容列表：</p>
<ul>
<li>Python<ul>
<li>基本数据类型</li>
<li>容器<ul>
<li>列表</li>
<li>字典</li>
<li>集合</li>
<li>元组</li>
</ul>
</li>
<li>函数</li>
<li>类</li>
</ul>
</li>
<li>Numpy<ul>
<li>数组</li>
<li>访问数组</li>
<li>数据类型</li>
<li>数组计算</li>
<li>广播</li>
</ul>
</li>
<li>SciPy<ul>
<li>图像操作</li>
<li>MATLAB文件</li>
<li>点之间的距离</li>
</ul>
</li>
<li>Matplotlib<ul>
<li>绘制图形</li>
<li>绘制多个图形</li>
<li>图像</li>
</ul>
</li>
</ul>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def quicksort(arr):</span><br><span class="line">    if len(arr) &lt;= 1:</span><br><span class="line">        return arr</span><br><span class="line">    pivot = arr[len(arr) // 2]</span><br><span class="line">    left = [x for x in arr if x &lt; pivot]</span><br><span class="line">    middle = [x for x in arr if x == pivot]</span><br><span class="line">    right = [x for x in arr if x &gt; pivot]</span><br><span class="line">    return quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line">print(quicksort([3,6,8,10,1,2,1]))</span><br><span class="line"># Prints &quot;[1, 1, 2, 3, 6, 8, 10]&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h2><p>Python有两个支持的版本，分别是2.7和3.5。这有点让人迷惑，3.0向语言中引入了很多不向后兼容的变化，2.7下的代码有时候在3.5下是行不通的。在这个课程中，我们使用的是3.5版本。</p>
<p>你可以使用<code>python--version</code>命令查看Python版本。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>和大多数编程语言一样，Python拥有一系列的基本数据类型，比如整型(integers)、浮点型(floats)、布尔型(booleans)和字符串(strings)等。这些类型的使用方式和在其他语言中的使用方式是类似的。</p>
<p>数字：整型和浮点型的使用与其他语言类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = 3</span><br><span class="line">print(type(x)) # Prints &quot;&lt;class &apos;int&apos;&gt;&quot;</span><br><span class="line">print(x)       # Prints &quot;3&quot;</span><br><span class="line">print(x + 1)   # Addition; prints &quot;4&quot;</span><br><span class="line">print(x - 1)   # Subtraction; prints &quot;2&quot;</span><br><span class="line">print(x * 2)   # Multiplication; prints &quot;6&quot;</span><br><span class="line">print(x ** 2)  # Exponentiation; prints &quot;9&quot;</span><br><span class="line">x += 1</span><br><span class="line">print(x)  # Prints &quot;4&quot;</span><br><span class="line">x *= 2</span><br><span class="line">print(x)  # Prints &quot;8&quot;</span><br><span class="line">y = 2.5</span><br><span class="line">print(type(y)) # Prints &quot;&lt;class &apos;float&apos;&gt;&quot;</span><br><span class="line">print(y, y + 1, y * 2, y ** 2) # Prints &quot;2.5 3.5 5.0 6.25&quot;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Python中没有 <code>x++</code> 和 <code>x--</code> 的操作符。</p>
<p>Python也有内置的长整型和复杂数字类型，具体细节可以查看<a href="https://docs.python.org/3.5/library/stdtypes.html#numeric-types-int-float-complex" target="_blank" rel="noopener">文档</a>。</p>
<p>布尔型：Python实现了所有的布尔逻辑，但用的是英语，而不是我们习惯的操作符（比如<code>&amp;&amp;</code>和<code>||</code>等）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = True</span><br><span class="line">f = False</span><br><span class="line">print(type(t)) # Prints &quot;&lt;class &apos;bool&apos;&gt;&quot;</span><br><span class="line">print(t and f) # Logical AND; prints &quot;False&quot;</span><br><span class="line">print(t or f)  # Logical OR; prints &quot;True&quot;</span><br><span class="line">print(not t)   # Logical NOT; prints &quot;False&quot;</span><br><span class="line">print(t != f)  # Logical XOR; prints &quot;True&quot;</span><br></pre></td></tr></table></figure>
<p>字符串：Python对字符串的支持非常棒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello = &apos;hello&apos;    # String literals can use single quotes</span><br><span class="line">world = &quot;world&quot;    # or double quotes; it does not matter.</span><br><span class="line">print(hello)       # Prints &quot;hello&quot;</span><br><span class="line">print(len(hello))  # String length; prints &quot;5&quot;</span><br><span class="line">hw = hello + &apos; &apos; + world  # String concatenation</span><br><span class="line">print(hw)  # prints &quot;hello world&quot;</span><br><span class="line">hw12 = &apos;%s %s %d&apos; % (hello, world, 12)  # sprintf style string formatting</span><br><span class="line">print(hw12)  # prints &quot;hello world 12&quot;</span><br></pre></td></tr></table></figure>
<p>字符串对象有一系列有用的方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;hello&quot;</span><br><span class="line">print(s.capitalize())  # Capitalize a string; prints &quot;Hello&quot;</span><br><span class="line">print(s.upper())       # Convert a string to uppercase; prints &quot;HELLO&quot;</span><br><span class="line">print(s.rjust(7))      # Right-justify a string, padding with spaces; prints &quot;  hello&quot;</span><br><span class="line">print(s.center(7))     # Center a string, padding with spaces; prints &quot; hello &quot;</span><br><span class="line">print(s.replace(&apos;l&apos;, &apos;(ell)&apos;))  # Replace all instances of one substring with another;</span><br><span class="line">                                # prints &quot;he(ell)(ell)o&quot;</span><br><span class="line">print(&apos;  world &apos;.strip())  # Strip leading and trailing whitespace; prints &quot;world&quot;</span><br></pre></td></tr></table></figure>
<p>如果想详细查看字符串方法，请看<a href="https://docs.python.org/3.5/library/stdtypes.html#string-methods" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="容器Containers"><a href="#容器Containers" class="headerlink" title="容器Containers"></a>容器Containers</h2><p>译者注：有知友建议container翻译为复合数据类型，供读者参考。</p>
<p>Python有以下几种容器类型：列表（lists）、字典（dictionaries）、集合（sets）和元组（tuples）。</p>
<h3 id="列表Lists"><a href="#列表Lists" class="headerlink" title="列表Lists"></a>列表Lists</h3><p>列表就是Python中的数组，但是列表长度可变，且能包含不同类型元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xs = [3, 1, 2]    # Create a list</span><br><span class="line">print(xs, xs[2])  # Prints &quot;[3, 1, 2] 2&quot;</span><br><span class="line">print(xs[-1])     # Negative indices count from the end of the list; prints &quot;2&quot;</span><br><span class="line">xs[2] = &apos;foo&apos;     # Lists can contain elements of different types</span><br><span class="line">print(xs)         # Prints &quot;[3, 1, &apos;foo&apos;]&quot;</span><br><span class="line">xs.append(&apos;bar&apos;)  # Add a new element to the end of the list</span><br><span class="line">print(xs)         # Prints &quot;[3, 1, &apos;foo&apos;, &apos;bar&apos;]&quot;</span><br><span class="line">x = xs.pop()      # Remove and return the last element of the list</span><br><span class="line">print(x, xs)      # Prints &quot;bar [3, 1, &apos;foo&apos;]&quot;</span><br></pre></td></tr></table></figure>
<p>列表的细节，同样可以查阅<a href="https://docs.python.org/3.5/tutorial/datastructures.html#more-on-lists" target="_blank" rel="noopener">文档</a>。</p>
<p>切片Slicing：为了一次性地获取列表中的元素，Python提供了一种简洁的语法，这就是切片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums = list(range(5))     # range is a built-in function that creates a list of integers</span><br><span class="line">print(nums)               # Prints &quot;[0, 1, 2, 3, 4]&quot;</span><br><span class="line">print(nums[2:4])          # Get a slice from index 2 to 4 (exclusive); prints &quot;[2, 3]&quot;</span><br><span class="line">print(nums[2:])           # Get a slice from index 2 to the end; prints &quot;[2, 3, 4]&quot;</span><br><span class="line">print(nums[:2])           # Get a slice from the start to index 2 (exclusive); prints &quot;[0, 1]&quot;</span><br><span class="line">print(nums[:])            # Get a slice of the whole list; prints &quot;[0, 1, 2, 3, 4]&quot;</span><br><span class="line">print(nums[:-1])          # Slice indices can be negative; prints &quot;[0, 1, 2, 3]&quot;</span><br><span class="line">nums[2:4] = [8, 9]        # Assign a new sublist to a slice</span><br><span class="line">print(nums)               # Prints &quot;[0, 1, 8, 9, 4]&quot;</span><br></pre></td></tr></table></figure></p>
<p>在Numpy数组的内容中，我们会再次看到切片语法。</p>
<p>循环Loops：我们可以这样遍历列表中的每一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [&apos;cat&apos;, &apos;dog&apos;, &apos;monkey&apos;]</span><br><span class="line">for animal in animals:</span><br><span class="line">    print(animal)</span><br><span class="line"># Prints &quot;cat&quot;, &quot;dog&quot;, &quot;monkey&quot;, each on its own line.</span><br></pre></td></tr></table></figure>
<p>如果想要在循环体内访问每个元素的指针，可以使用内置的<code>enumerate</code>函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [&apos;cat&apos;, &apos;dog&apos;, &apos;monkey&apos;]</span><br><span class="line">for idx, animal in enumerate(animals):</span><br><span class="line">    print(&apos;#%d: %s&apos; % (idx + 1, animal))</span><br><span class="line"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span><br></pre></td></tr></table></figure></p>
<p>列表推导 List comprehensions：在编程的时候，我们常常想要将一种数据类型转换为另一种。下面是一个简单例子，将列表中的每个元素变成它的平方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">squares = []</span><br><span class="line">for x in nums:</span><br><span class="line">    squares.append(x ** 2)</span><br><span class="line">print(squares)   # Prints [0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure></p>
<p>使用列表推导，你就可以让代码简化很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">squares = [x ** 2 for x in nums]</span><br><span class="line">print(squares)   # Prints [0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure></p>
<p>列表推导还可以包含条件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">even_squares = [x ** 2 for x in nums if x % 2 == 0]</span><br><span class="line">print(even_squares)  # Prints &quot;[0, 4, 16]&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="字典-Dictionaries"><a href="#字典-Dictionaries" class="headerlink" title="字典 Dictionaries"></a>字典 Dictionaries</h3><p>字典用来储存（键, 值）对，这和Java中的<code>Map</code>差不多。你可以这样使用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;cat&apos;: &apos;cute&apos;, &apos;dog&apos;: &apos;furry&apos;&#125;  # Create a new dictionary with some data</span><br><span class="line">print(d[&apos;cat&apos;])       # Get an entry from a dictionary; prints &quot;cute&quot;</span><br><span class="line">print(&apos;cat&apos; in d)     # Check if a dictionary has a given key; prints &quot;True&quot;</span><br><span class="line">d[&apos;fish&apos;] = &apos;wet&apos;     # Set an entry in a dictionary</span><br><span class="line">print(d[&apos;fish&apos;])      # Prints &quot;wet&quot;</span><br><span class="line"># print(d[&apos;monkey&apos;])  # KeyError: &apos;monkey&apos; not a key of d</span><br><span class="line">print(d.get(&apos;monkey&apos;, &apos;N/A&apos;))  # Get an element with a default; prints &quot;N/A&quot;</span><br><span class="line">print(d.get(&apos;fish&apos;, &apos;N/A&apos;))    # Get an element with a default; prints &quot;wet&quot;</span><br><span class="line">del d[&apos;fish&apos;]         # Remove an element from a dictionary</span><br><span class="line">print(d.get(&apos;fish&apos;, &apos;N/A&apos;)) # &quot;fish&quot; is no longer a key; prints &quot;N/A&quot;</span><br></pre></td></tr></table></figure></p>
<p>想要知道字典的其他特性，请查阅<a href="https://docs.python.org/3.5/library/stdtypes.html#dict" target="_blank" rel="noopener">文档</a>。</p>
<p>循环Loops：在字典中，用键来迭代更加容易。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;person&apos;: 2, &apos;cat&apos;: 4, &apos;spider&apos;: 8&#125;</span><br><span class="line">for animal in d:</span><br><span class="line">    legs = d[animal]</span><br><span class="line">    print(&apos;A %s has %d legs&apos; % (animal, legs))</span><br><span class="line"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果你想要访问键和对应的值，那就使用<code>items</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;person&apos;: 2, &apos;cat&apos;: 4, &apos;spider&apos;: 8&#125;</span><br><span class="line">for animal, legs in d.items():</span><br><span class="line">    print(&apos;A %s has %d legs&apos; % (animal, legs))</span><br><span class="line"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span><br></pre></td></tr></table></figure></p>
<p>字典推导 Dictionary comprehensions：和列表推导类似，但是允许你方便地构建字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">even_num_to_square = &#123;x: x ** 2 for x in nums if x % 2 == 0&#125;</span><br><span class="line">print(even_num_to_square)  # Prints &quot;&#123;0: 0, 2: 4, 4: 16&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="集合Sets"><a href="#集合Sets" class="headerlink" title="集合Sets"></a>集合Sets</h3><p>集合是独立不同个体的无序集合。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;&apos;cat&apos;, &apos;dog&apos;&#125;</span><br><span class="line">print(&apos;cat&apos; in animals)   # Check if an element is in a set; prints &quot;True&quot;</span><br><span class="line">print(&apos;fish&apos; in animals)  # prints &quot;False&quot;</span><br><span class="line">animals.add(&apos;fish&apos;)       # Add an element to a set</span><br><span class="line">print(&apos;fish&apos; in animals)  # Prints &quot;True&quot;</span><br><span class="line">print(len(animals))       # Number of elements in a set; prints &quot;3&quot;</span><br><span class="line">animals.add(&apos;cat&apos;)        # Adding an element that is already in the set does nothing</span><br><span class="line">print(len(animals))       # Prints &quot;3&quot;</span><br><span class="line">animals.remove(&apos;cat&apos;)     # Remove an element from a set</span><br><span class="line">print(len(animals))       # Prints &quot;2&quot;</span><br></pre></td></tr></table></figure></p>
<p>和前面一样，要知道更详细的，查看<a href="https://docs.python.org/3.5/library/stdtypes.html#set" target="_blank" rel="noopener">文档</a>。</p>
<p>循环Loops：在集合中循环的语法和在列表中一样，但是集合是无序的，所以你在访问集合的元素的时候，不能做关于顺序的假设。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;&apos;cat&apos;, &apos;dog&apos;, &apos;fish&apos;&#125;</span><br><span class="line">for idx, animal in enumerate(animals):</span><br><span class="line">    print(&apos;#%d: %s&apos; % (idx + 1, animal))</span><br><span class="line"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span><br></pre></td></tr></table></figure></p>
<p>集合推导Set comprehensions：和字典推导一样，可以很方便地构建集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">nums = &#123;int(sqrt(x)) for x in range(30)&#125;</span><br><span class="line">print(nums)  # Prints &quot;&#123;0, 1, 2, 3, 4, 5&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="元组Tuples"><a href="#元组Tuples" class="headerlink" title="元组Tuples"></a>元组Tuples</h3><p>元组是一个值的有序列表（不可改变）。从很多方面来说，元组和列表都很相似。和列表最重要的不同在于，元组可以在字典中用作键，还可以作为集合的元素，而列表不行。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;(x, x + 1): x for x in range(10)&#125;  # Create a dictionary with tuple keys</span><br><span class="line">t = (5, 6)        # Create a tuple</span><br><span class="line">print(type(t))    # Prints &quot;&lt;class &apos;tuple&apos;&gt;&quot;</span><br><span class="line">print(d[t])       # Prints &quot;5&quot;</span><br><span class="line">print(d[(1, 2)])  # Prints &quot;1&quot;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://docs.python.org/3.5/tutorial/datastructures.html#tuples-and-sequences" target="_blank" rel="noopener">文档</a>有更多元组的信息。</p>
<h2 id="函数Functions"><a href="#函数Functions" class="headerlink" title="函数Functions"></a>函数Functions</h2><p>Python函数使用<code>def</code>来定义函数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sign(x):</span><br><span class="line">    if x &gt; 0:</span><br><span class="line">        return &apos;positive&apos;</span><br><span class="line">    elif x &lt; 0:</span><br><span class="line">        return &apos;negative&apos;</span><br><span class="line">    else:</span><br><span class="line">        return &apos;zero&apos;</span><br><span class="line"></span><br><span class="line">for x in [-1, 0, 1]:</span><br><span class="line">    print(sign(x))</span><br><span class="line"># Prints &quot;negative&quot;, &quot;zero&quot;, &quot;positive&quot;</span><br></pre></td></tr></table></figure></p>
<p>我们常常使用可选参数来定义函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def hello(name, loud=False):</span><br><span class="line">    if loud:</span><br><span class="line">        print(&apos;HELLO, %s!&apos; % name.upper())</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Hello, %s&apos; % name)</span><br><span class="line"></span><br><span class="line">hello(&apos;Bob&apos;) # Prints &quot;Hello, Bob&quot;</span><br><span class="line">hello(&apos;Fred&apos;, loud=True)  # Prints &quot;HELLO, FRED!&quot;</span><br></pre></td></tr></table></figure></p>
<p>函数还有很多内容，可以查看<a href="https://docs.python.org/3.5/tutorial/controlflow.html#defining-functions" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="类Classes"><a href="#类Classes" class="headerlink" title="类Classes"></a>类Classes</h2><p>Python对于类的定义是简单直接的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Greeter(object):</span><br><span class="line"></span><br><span class="line">    # Constructor</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name  # Create an instance variable</span><br><span class="line"></span><br><span class="line">    # Instance method</span><br><span class="line">    def greet(self, loud=False):</span><br><span class="line">        if loud:</span><br><span class="line">            print(&apos;HELLO, %s!&apos; % self.name.upper())</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;Hello, %s&apos; % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(&apos;Fred&apos;)  # Construct an instance of the Greeter class</span><br><span class="line">g.greet()            # Call an instance method; prints &quot;Hello, Fred&quot;</span><br><span class="line">g.greet(loud=True)   # Call an instance method; prints &quot;HELLO, FRED!&quot;</span><br></pre></td></tr></table></figure></p>
<p>更多类的信息请查阅<a href="https://docs.python.org/3.5/tutorial/classes.html" target="_blank" rel="noopener">文档</a>。</p>
<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p><a href="http://www.numpy.org/" target="_blank" rel="noopener">Numpy</a>是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具。如果你已经很熟悉MATLAB，你可以通过这个<a href="http://wiki.scipy.org/NumPy_for_Matlab_Users" target="_blank" rel="noopener">文档</a>开始使用Numpy。</p>
<h2 id="数组Arrays"><a href="#数组Arrays" class="headerlink" title="数组Arrays"></a>数组Arrays</h2><p>一个numpy数组是一个由不同数值组成的网格。网格中的数据都是同一种数据类型，可以通过非负整型数的元组来访问。维度的数量被称为数组的阶，数组的大小是一个由整型数构成的元组，可以描述数组不同维度上的大小。</p>
<p>我们可以从列表创建数组，然后利用方括号访问其中的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([1, 2, 3])   # Create a rank 1 array</span><br><span class="line">print(type(a))            # Prints &quot;&lt;class &apos;numpy.ndarray&apos;&gt;&quot;</span><br><span class="line">print(a.shape)            # Prints &quot;(3,)&quot;</span><br><span class="line">print(a[0], a[1], a[2])   # Prints &quot;1 2 3&quot;</span><br><span class="line">a[0] = 5                  # Change an element of the array</span><br><span class="line">print(a)                  # Prints &quot;[5, 2, 3]&quot;</span><br><span class="line"></span><br><span class="line">b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array</span><br><span class="line">print(b.shape)                     # Prints &quot;(2, 3)&quot;</span><br><span class="line">print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;</span><br></pre></td></tr></table></figure></p>
<p>Numpy还提供了很多其他创建数组的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.zeros((2,2))   # Create an array of all zeros</span><br><span class="line">print(a)              # Prints &quot;[[ 0.  0.]</span><br><span class="line">                      #          [ 0.  0.]]&quot;</span><br><span class="line"></span><br><span class="line">b = np.ones((1,2))    # Create an array of all ones</span><br><span class="line">print(b)              # Prints &quot;[[ 1.  1.]]&quot;</span><br><span class="line"></span><br><span class="line">c = np.full((2,2), 7)  # Create a constant array</span><br><span class="line">print(c)               # Prints &quot;[[ 7.  7.]</span><br><span class="line">                       #          [ 7.  7.]]&quot;</span><br><span class="line"></span><br><span class="line">d = np.eye(2)         # Create a 2x2 identity matrix</span><br><span class="line">print(d)              # Prints &quot;[[ 1.  0.]</span><br><span class="line">                      #          [ 0.  1.]]&quot;</span><br><span class="line"></span><br><span class="line">e = np.random.random((2,2))  # Create an array filled with random values</span><br><span class="line">print(e)                     # Might print &quot;[[ 0.91940167  0.08143941]</span><br><span class="line">                             #               [ 0.68744134  0.87236687]]&quot;</span><br></pre></td></tr></table></figure></p>
<p>其他数组相关方法，请查看<a href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>Numpy提供了多种访问数组的方法。</p>
<p>切片(Slicing)：和Python列表类似，numpy数组可以使用切片语法。因为数组可以是多维的，所以你必须为每个维度指定好切片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Use slicing to pull out the subarray consisting of the first 2 rows</span><br><span class="line"># and columns 1 and 2; b is the following array of shape (2, 2):</span><br><span class="line"># [[2 3]</span><br><span class="line">#  [6 7]]</span><br><span class="line">b = a[:2, 1:3]</span><br><span class="line"></span><br><span class="line"># A slice of an array is a view into the same data, so modifying it</span><br><span class="line"># will modify the original array.</span><br><span class="line">print(a[0, 1])   # Prints &quot;2&quot;</span><br><span class="line">b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]</span><br><span class="line">print(a[0, 1])   # Prints &quot;77&quot;</span><br></pre></td></tr></table></figure></p>
<p>你可以同时使用整型和切片语法来访问数组。但是，这样做会产生一个比原数组低阶的新数组。需要注意的是，这里和MATLAB中的情况是不同的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Two ways of accessing the data in the middle row of the array.</span><br><span class="line"># Mixing integer indexing with slices yields an array of lower rank,</span><br><span class="line"># while using only slices yields an array of the same rank as the</span><br><span class="line"># original array:</span><br><span class="line">row_r1 = a[1, :]    # Rank 1 view of the second row of a</span><br><span class="line">row_r2 = a[1:2, :]  # Rank 2 view of the second row of a</span><br><span class="line">print(row_r1, row_r1.shape)  # Prints &quot;[5 6 7 8] (4,)&quot;</span><br><span class="line">print(row_r2, row_r2.shape)  # Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span><br><span class="line"></span><br><span class="line"># We can make the same distinction when accessing columns of an array:</span><br><span class="line">col_r1 = a[:, 1]</span><br><span class="line">col_r2 = a[:, 1:2]</span><br><span class="line">print(col_r1, col_r1.shape)  # Prints &quot;[ 2  6 10] (3,)&quot;</span><br><span class="line">print(col_r2, col_r2.shape)  # Prints &quot;[[ 2]</span><br><span class="line">                             #          [ 6]</span><br><span class="line">                             #          [10]] (3, 1)&quot;</span><br></pre></td></tr></table></figure></p>
<p>整型数组访问：当我们使用切片语法访问数组时，得到的总是原数组的一个子集。整型数组访问允许我们利用其它数组的数据构建一个新的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1,2], [3, 4], [5, 6]])</span><br><span class="line"></span><br><span class="line"># An example of integer array indexing.</span><br><span class="line"># The returned array will have shape (3,) and</span><br><span class="line">print(a[[0, 1, 2], [0, 1, 0]])  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># The above example of integer array indexing is equivalent to this:</span><br><span class="line">print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># When using integer array indexing, you can reuse the same</span><br><span class="line"># element from the source array:</span><br><span class="line">print(a[[0, 0], [1, 1]])  # Prints &quot;[2 2]&quot;</span><br><span class="line"></span><br><span class="line"># Equivalent to the previous integer array indexing example</span><br><span class="line">print(np.array([a[0, 1], a[0, 1]]))  # Prints &quot;[2 2]&quot;</span><br></pre></td></tr></table></figure></p>
<p>整型数组访问语法还有个有用的技巧，可以用来选择或者更改矩阵中每行中的一个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create a new array from which we will select elements</span><br><span class="line">a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[ 1,  2,  3],</span><br><span class="line">          #                [ 4,  5,  6],</span><br><span class="line">          #                [ 7,  8,  9],</span><br><span class="line">          #                [10, 11, 12]])&quot;</span><br><span class="line"></span><br><span class="line"># Create an array of indices</span><br><span class="line">b = np.array([0, 2, 0, 1])</span><br><span class="line"></span><br><span class="line"># Select one element from each row of a using the indices in b</span><br><span class="line">print(a[np.arange(4), b])  # Prints &quot;[ 1  6  7 11]&quot;</span><br><span class="line"></span><br><span class="line"># Mutate one element from each row of a using the indices in b</span><br><span class="line">a[np.arange(4), b] += 10</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[11,  2,  3],</span><br><span class="line">          #                [ 4,  5, 16],</span><br><span class="line">          #                [17,  8,  9],</span><br><span class="line">          #                [10, 21, 12]])</span><br></pre></td></tr></table></figure></p>
<p>布尔型数组访问：布尔型数组访问可以让你选择数组中任意元素。通常，这种访问方式用于选取数组中满足某些条件的元素，举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1,2], [3, 4], [5, 6]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; 2)   # Find the elements of a that are bigger than 2;</span><br><span class="line">                     # this returns a numpy array of Booleans of the same</span><br><span class="line">                     # shape as a, where each slot of bool_idx tells</span><br><span class="line">                     # whether that element of a is &gt; 2.</span><br><span class="line"></span><br><span class="line">print(bool_idx)      # Prints &quot;[[False False]</span><br><span class="line">                     #          [ True  True]</span><br><span class="line">                     #          [ True  True]]&quot;</span><br><span class="line"></span><br><span class="line"># We use boolean array indexing to construct a rank 1 array</span><br><span class="line"># consisting of the elements of a corresponding to the True values</span><br><span class="line"># of bool_idx</span><br><span class="line">print(a[bool_idx])  # Prints &quot;[3 4 5 6]&quot;</span><br><span class="line"></span><br><span class="line"># We can do all of the above in a single concise statement:</span><br><span class="line">print(a[a &gt; 2])     # Prints &quot;[3 4 5 6]&quot;</span><br></pre></td></tr></table></figure></p>
<p>为了教程的简介，有很多数组访问的细节我们没有详细说明，可以查看<a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每个Numpy数组都是数据类型相同的元素组成的网格。Numpy提供了很多的数据类型用于创建数组。当你创建数组的时候，Numpy会尝试猜测数组的数据类型，你也可以通过参数直接指定数据类型，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([1, 2])   # Let numpy choose the datatype</span><br><span class="line">print(x.dtype)         # Prints &quot;int64&quot;</span><br><span class="line"></span><br><span class="line">x = np.array([1.0, 2.0])   # Let numpy choose the datatype</span><br><span class="line">print(x.dtype)             # Prints &quot;float64&quot;</span><br><span class="line"></span><br><span class="line">x = np.array([1, 2], dtype=np.int64)   # Force a particular datatype</span><br><span class="line">print(x.dtype)                         # Prints &quot;int64&quot;</span><br></pre></td></tr></table></figure>
<p>更多细节查看<a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h2><p>基本数学计算函数会对数组中元素逐个进行计算，既可以利用操作符重载，也可以使用函数方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]], dtype=np.float64)</span><br><span class="line">y = np.array([[5,6],[7,8]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"># Elementwise sum; both produce the array</span><br><span class="line"># [[ 6.0  8.0]</span><br><span class="line">#  [10.0 12.0]]</span><br><span class="line">print(x + y)</span><br><span class="line">print(np.add(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise difference; both produce the array</span><br><span class="line"># [[-4.0 -4.0]</span><br><span class="line">#  [-4.0 -4.0]]</span><br><span class="line">print(x - y)</span><br><span class="line">print(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise product; both produce the array</span><br><span class="line"># [[ 5.0 12.0]</span><br><span class="line">#  [21.0 32.0]]</span><br><span class="line">print(x * y)</span><br><span class="line">print(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise division; both produce the array</span><br><span class="line"># [[ 0.2         0.33333333]</span><br><span class="line">#  [ 0.42857143  0.5       ]]</span><br><span class="line">print(x / y)</span><br><span class="line">print(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise square root; produces the array</span><br><span class="line"># [[ 1.          1.41421356]</span><br><span class="line">#  [ 1.73205081  2.        ]]</span><br><span class="line">print(np.sqrt(x))</span><br></pre></td></tr></table></figure></p>
<p>和MATLAB不同，<code>*</code>是元素逐个相乘，而不是矩阵乘法。在Numpy中使用dot来进行矩阵乘法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]])</span><br><span class="line">y = np.array([[5,6],[7,8]])</span><br><span class="line"></span><br><span class="line">v = np.array([9,10])</span><br><span class="line">w = np.array([11, 12])</span><br><span class="line"></span><br><span class="line"># Inner product of vectors; both produce 219</span><br><span class="line">print(v.dot(w))</span><br><span class="line">print(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"># Matrix / vector product; both produce the rank 1 array [29 67]</span><br><span class="line">print(x.dot(v))</span><br><span class="line">print(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"># Matrix / matrix product; both produce the rank 2 array</span><br><span class="line"># [[19 22]</span><br><span class="line">#  [43 50]]</span><br><span class="line">print(x.dot(y))</span><br><span class="line">print(np.dot(x, y))</span><br></pre></td></tr></table></figure></p>
<p>Numpy提供了很多计算数组的函数，其中最常用的一个是<code>sum</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  # Compute sum of all elements; prints &quot;10&quot;</span><br><span class="line">print(np.sum(x, axis=0))  # Compute sum of each column; prints &quot;[4 6]&quot;</span><br><span class="line">print(np.sum(x, axis=1))  # Compute sum of each row; prints &quot;[3 7]&quot;</span><br></pre></td></tr></table></figure></p>
<p>想要了解更多函数，可以查看<a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html" target="_blank" rel="noopener">文档</a>。</p>
<p>除了计算，我们还常常改变数组或者操作其中的元素。其中将矩阵转置是常用的一个，在Numpy中，使用<code>T</code>来转置矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2], [3,4]])</span><br><span class="line">print(x)    # Prints &quot;[[1 2]</span><br><span class="line">            #          [3 4]]&quot;</span><br><span class="line">print(x.T)  # Prints &quot;[[1 3]</span><br><span class="line">            #          [2 4]]&quot;</span><br><span class="line"></span><br><span class="line"># Note that taking the transpose of a rank 1 array does nothing:</span><br><span class="line">v = np.array([1,2,3])</span><br><span class="line">print(v)    # Prints &quot;[1 2 3]&quot;</span><br><span class="line">print(v.T)  # Prints &quot;[1 2 3]&quot;</span><br></pre></td></tr></table></figure></p>
<p>Numpy还提供了更多操作数组的方法，请查看<a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="广播Broadcasting"><a href="#广播Broadcasting" class="headerlink" title="广播Broadcasting"></a>广播Broadcasting</h2><p>广播是一种强有力的机制，它让Numpy可以让不同大小的矩阵在一起进行数学计算。我们常常会有一个小的矩阵和一个大的矩阵，然后我们会需要用小的矩阵对大的矩阵做一些计算。</p>
<p>举个例子，如果我们想要把一个向量加到矩阵的每一行，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = np.empty_like(x)   # Create an empty matrix with the same shape as x</span><br><span class="line"></span><br><span class="line"># Add the vector v to each row of the matrix x with an explicit loop</span><br><span class="line">for i in range(4):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"># Now y is the following</span><br><span class="line"># [[ 2  2  4]</span><br><span class="line">#  [ 5  5  7]</span><br><span class="line">#  [ 8  8 10]</span><br><span class="line">#  [11 11 13]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure></p>
<p>这样是行得通的，但是当<code>x</code>矩阵非常大，利用循环来计算就会变得很慢很慢。Note that adding the vector <code>v</code> to each row of the matrix <code>x</code> is equivalent to forming a matrix <code>vv</code> by stacking multiple copies of <code>v</code> vertically, then performing elementwise summation of <code>x</code> and <code>vv</code>. 我们可以换一种思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">vv = np.tile(v, (4, 1))   # Stack 4 copies of v on top of each other</span><br><span class="line">print(vv)                 # Prints &quot;[[1 0 1]</span><br><span class="line">                          #          [1 0 1]</span><br><span class="line">                          #          [1 0 1]</span><br><span class="line">                          #          [1 0 1]]&quot;</span><br><span class="line">y = x + vv  # Add x and vv elementwise</span><br><span class="line">print(y)  # Prints &quot;[[ 2  2  4</span><br><span class="line">          #          [ 5  5  7]</span><br><span class="line">          #          [ 8  8 10]</span><br><span class="line">          #          [11 11 13]]&quot;</span><br></pre></td></tr></table></figure></p>
<p>Numpy广播机制可以让我们不用创建<code>vv</code>，就能直接运算，看看下面例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = x + v  # Add v to each row of x using broadcasting</span><br><span class="line">print(y)  # Prints &quot;[[ 2  2  4]</span><br><span class="line">          #          [ 5  5  7]</span><br><span class="line">          #          [ 8  8 10]</span><br><span class="line">          #          [11 11 13]]&quot;</span><br></pre></td></tr></table></figure></p>
<p>The line <code>y = x + v</code> works even though <code>x</code> has shape <code>(4, 3)</code> and v has shape<code>(3,)</code> due to broadcasting; this line works as if <code>v</code> actually had shape <code>(4, 3)</code>, where each row was a copy of <code>v</code>, and the sum was performed elementwise.</p>
<p>对两个数组使用广播机制要遵守下列规则：</p>
<ol>
<li>如果数组的秩不同，使用1来将秩较小的数组进行扩展，直到两个数组的尺寸的长度都一样。</li>
<li>如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上长度为1，那么我们就说这两个数组在该维度上是相容的。</li>
<li>如果两个数组在所有维度上都是相容的，他们就能使用广播。</li>
<li>如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和那个较大的尺寸一样。</li>
<li>在任何一个维度上，如果一个数组的长度为1，另一个数组长度大于1，那么在该维度上，就好像是对第一个数组进行了复制。</li>
</ol>
<p>如果上述解释看不明白，可以读一读<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="noopener">文档</a>和这个<a href="http://wiki.scipy.org/EricsBroadcastingDoc/" target="_blank" rel="noopener">解</a>释。译者注：强烈推荐阅读文档中的例子。</p>
<p>支持广播机制的函数是全局函数。哪些是全局函数可以在<a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs" target="_blank" rel="noopener">文档</a>中查找。</p>
<p>下面是一些广播机制的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Compute outer product of vectors</span><br><span class="line">v = np.array([1,2,3])  # v has shape (3,)</span><br><span class="line">w = np.array([4,5])    # w has shape (2,)</span><br><span class="line"># To compute an outer product, we first reshape v to be a column</span><br><span class="line"># vector of shape (3, 1); we can then broadcast it against w to yield</span><br><span class="line"># an output of shape (3, 2), which is the outer product of v and w:</span><br><span class="line"># [[ 4  5]</span><br><span class="line">#  [ 8 10]</span><br><span class="line">#  [12 15]]</span><br><span class="line">print(np.reshape(v, (3, 1)) * w)</span><br><span class="line"></span><br><span class="line"># Add a vector to each row of a matrix</span><br><span class="line">x = np.array([[1,2,3], [4,5,6]])</span><br><span class="line"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span><br><span class="line"># giving the following matrix:</span><br><span class="line"># [[2 4 6]</span><br><span class="line">#  [5 7 9]]</span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line"># Add a vector to each column of a matrix</span><br><span class="line"># x has shape (2, 3) and w has shape (2,).</span><br><span class="line"># If we transpose x then it has shape (3, 2) and can be broadcast</span><br><span class="line"># against w to yield a result of shape (3, 2); transposing this result</span><br><span class="line"># yields the final result of shape (2, 3) which is the matrix x with</span><br><span class="line"># the vector w added to each column. Gives the following matrix:</span><br><span class="line"># [[ 5  6  7]</span><br><span class="line">#  [ 9 10 11]]</span><br><span class="line">print((x.T + w).T)</span><br><span class="line"># Another solution is to reshape w to be a column vector of shape (2, 1);</span><br><span class="line"># we can then broadcast it directly against x to produce the same</span><br><span class="line"># output.</span><br><span class="line">print(x + np.reshape(w, (2, 1)))</span><br><span class="line"></span><br><span class="line"># Multiply a matrix by a constant:</span><br><span class="line"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span><br><span class="line"># these can be broadcast together to shape (2, 3), producing the</span><br><span class="line"># following array:</span><br><span class="line"># [[ 2  4  6]</span><br><span class="line">#  [ 8 10 12]]</span><br><span class="line">print(x * 2)</span><br></pre></td></tr></table></figure></p>
<p>广播机制能够让你的代码更简洁更迅速，能够用的时候请尽量使用！</p>
<h2 id="Numpy文档"><a href="#Numpy文档" class="headerlink" title="Numpy文档"></a>Numpy文档</h2><p>这篇教程涉及了你需要了解的numpy中的一些重要内容，但是numpy远不止如此。可以查阅<a href="http://docs.scipy.org/doc/numpy/reference/" target="_blank" rel="noopener">numpy文献</a>来学习更多。</p>
<h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><p>Numpy提供了高性能的多维数组，以及计算和操作数组的基本工具。<a href="http://docs.scipy.org/doc/scipy/reference/" target="_blank" rel="noopener">SciPy</a>基于Numpy，提供了大量的计算和操作数组的函数，这些函数对于不同类型的科学和工程计算非常有用。</p>
<p>熟悉SciPy的最好方法就是阅读<a href="http://docs.scipy.org/doc/scipy/reference/index.html" target="_blank" rel="noopener">文档</a>。我们会强调对于本课程有用的部分。</p>
<h2 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h2><p>SciPy提供了一些操作图像的基本函数。比如，它提供了将图像从硬盘读入到数组的函数，也提供了将数组中数据写入的硬盘成为图像的函数。下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from scipy.misc import imread, imsave, imresize</span><br><span class="line"></span><br><span class="line"># Read an JPEG image into a numpy array</span><br><span class="line">img = imread(&apos;assets/cat.jpg&apos;)</span><br><span class="line">print(img.dtype, img.shape)  # Prints &quot;uint8 (400, 248, 3)&quot;</span><br><span class="line"></span><br><span class="line"># We can tint the image by scaling each of the color channels</span><br><span class="line"># by a different scalar constant. The image has shape (400, 248, 3);</span><br><span class="line"># we multiply it by the array [1, 0.95, 0.9] of shape (3,);</span><br><span class="line"># numpy broadcasting means that this leaves the red channel unchanged,</span><br><span class="line"># and multiplies the green and blue channels by 0.95 and 0.9</span><br><span class="line"># respectively.</span><br><span class="line">img_tinted = img * [1, 0.95, 0.9]</span><br><span class="line"></span><br><span class="line"># Resize the tinted image to be 300 by 300 pixels.</span><br><span class="line">img_tinted = imresize(img_tinted, (300, 300))</span><br><span class="line"></span><br><span class="line"># Write the tinted image back to disk</span><br><span class="line">imsave(&apos;assets/cat_tinted.jpg&apos;, img_tinted)</span><br></pre></td></tr></table></figure></p>
<p>译者注：如果运行这段代码出现类似ImportError: cannot import name imread的报错，那么请利用pip进行Pillow的下载，可以解决问题。命令：pip install Pillow。</p>
<p>—————————————————————————————————————————</p>
<div align="center"><br><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/cat.jpg?raw=true"><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/cat_tinted.jpg?raw=true"><br></div>

<p>左边是原始图片，右边是变色和变形的图片。</p>
<p>—————————————————————————————————————————</p>
<h2 id="MATLAB文件"><a href="#MATLAB文件" class="headerlink" title="MATLAB文件"></a>MATLAB文件</h2><p>函数<code>scipy.io.loadmat</code>和<code>scipy.io.savemat</code>能够让你读和写MATLAB文件。具体请查看<a href="http://docs.scipy.org/doc/scipy/reference/io.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="点之间的距离"><a href="#点之间的距离" class="headerlink" title="点之间的距离"></a>点之间的距离</h2><p>SciPy定义了一些有用的函数，可以计算集合中点之间的距离。</p>
<p>函数<code>scipy.spatial.distance.pdist</code>能够计算集合中所有两点之间的距离：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.spatial.distance import pdist, squareform</span><br><span class="line"></span><br><span class="line"># Create the following array where each row is a point in 2D space:</span><br><span class="line"># [[0 1]</span><br><span class="line">#  [1 0]</span><br><span class="line">#  [2 0]]</span><br><span class="line">x = np.array([[0, 1], [1, 0], [2, 0]])</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"># Compute the Euclidean distance between all rows of x.</span><br><span class="line"># d[i, j] is the Euclidean distance between x[i, :] and x[j, :],</span><br><span class="line"># and d is the following array:</span><br><span class="line"># [[ 0.          1.41421356  2.23606798]</span><br><span class="line">#  [ 1.41421356  0.          1.        ]</span><br><span class="line">#  [ 2.23606798  1.          0.        ]]</span><br><span class="line">d = squareform(pdist(x, &apos;euclidean&apos;))</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure></p>
<p>具体细节请阅读<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html" target="_blank" rel="noopener">文档</a>。</p>
<p>函数<code>scipy.spatial.distance.cdist</code>可以计算不同集合中点的距离，具体请查看<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html" target="_blank" rel="noopener">文档</a>。</p>
<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p><a href="http://matplotlib.org/" target="_blank" rel="noopener">Matplotlib</a>是一个作图库。这里简要介绍<code>matplotlib.pyplot</code>模块，功能和MATLAB的作图功能类似。</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>matplotlib库中最重要的函数是<code>Plot</code>。该函数允许你做出2D图形，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Compute the x and y coordinates for points on a sine curve</span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"># Plot the points using matplotlib</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()  # You must call plt.show() to make graphics appear.</span><br></pre></td></tr></table></figure></p>
<p>运行上面代码会产生下面的作图：</p>
<p>—————————————————————————————————————————</p>
<p><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/sine.png?raw=true" alt="image"></p>
<p>—————————————————————————————————————————<br>只需要少量工作，就可以一次画不同的线，加上标签，坐标轴标志等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Compute the x and y coordinates for points on sine and cosine curves</span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"># Plot the points using matplotlib</span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(&apos;x axis label&apos;)</span><br><span class="line">plt.ylabel(&apos;y axis label&apos;)</span><br><span class="line">plt.title(&apos;Sine and Cosine&apos;)</span><br><span class="line">plt.legend([&apos;Sine&apos;, &apos;Cosine&apos;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>—————————————————————————————————————————</p>
<p><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/sine_cosine.png?raw=true" alt="image"></p>
<p>—————————————————————————————————————————<br>可以在<a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot/" target="_blank" rel="noopener">文档</a>中阅读更多关于<code>plot</code>的内容。</p>
<h2 id="绘制多个图像"><a href="#绘制多个图像" class="headerlink" title="绘制多个图像"></a>绘制多个图像</h2><p>可以使用<code>subplot</code>函数来在一幅图中画不同的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Compute the x and y coordinates for points on sine and cosine curves</span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"># Set up a subplot grid that has height 2 and width 1,</span><br><span class="line"># and set the first such subplot as active.</span><br><span class="line">plt.subplot(2, 1, 1)</span><br><span class="line"></span><br><span class="line"># Make the first plot</span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(&apos;Sine&apos;)</span><br><span class="line"></span><br><span class="line"># Set the second subplot as active, and make the second plot.</span><br><span class="line">plt.subplot(2, 1, 2)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(&apos;Cosine&apos;)</span><br><span class="line"></span><br><span class="line"># Show the figure.</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>—————————————————————————————————————————</p>
<p><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/sine_cosine_subplot.png?raw=true" alt="image"></p>
<p>—————————————————————————————————————————<br>关于<code>subplot</code>的更多细节，可以阅读<a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>你可以使用<code>imshow</code>函数来显示图像，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.misc import imread, imresize</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">img = imread(&apos;assets/cat.jpg&apos;)</span><br><span class="line">img_tinted = img * [1, 0.95, 0.9]</span><br><span class="line"></span><br><span class="line"># Show the original image</span><br><span class="line">plt.subplot(1, 2, 1)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"># Show the tinted image</span><br><span class="line">plt.subplot(1, 2, 2)</span><br><span class="line"></span><br><span class="line"># A slight gotcha with imshow is that it might give strange results</span><br><span class="line"># if presented with data that is not uint8. To work around this, we</span><br><span class="line"># explicitly cast the image to uint8 before displaying it.</span><br><span class="line">plt.imshow(np.uint8(img_tinted))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>—————————————————————————————————————————<br><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/cat_tinted_imshow.png?raw=true" alt="image"><br>—————————————————————————————————————————</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">CS231n</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/02/10/Python Numpy 教程/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-用Gradle构建Spring Boot项目" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/16/用Gradle构建Spring Boot项目/">用Gradle构建Spring Boot项目</a>
    </h1>
  

        
        <a href="/2017/08/16/用Gradle构建Spring Boot项目/" class="archive-article-date">
  	<time datetime="2017-08-16T09:51:05.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-08-16</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>相比起Maven的XML配置方式，Gradle提供了一套简明的DSL用于构建Java项目，使我们就像编写程序一样编写项目构建脚本。本文将从无到有创建一个用Gradle构建的Spring Boot项目，并在此过程中讲到Gradle的一些典型用法。</p>
<h1 id="创建Gradle工程"><a href="#创建Gradle工程" class="headerlink" title="创建Gradle工程"></a>创建Gradle工程</h1><p>Gradle采用了与Maven相同的目录组织结构，你可以通过Spring Initializr网站创建Spring Boot工程。但是在本文中，我们将全部通过命令行操作创建Spring Boot工程。首先在命令行中创建如下目录结构：</p>
<pre><code>└── src
    ├── main
    │   └── java
    └── test
        └── java    
</code></pre><p>然后在src同级目录中添加一个build.gradle文件，内容如下：</p>
<pre><code>apply plugin: &apos;java&apos;
</code></pre><p>大功告成，一个用Gradle构建的Java项目创建好了，尽情用以下命令编译并打包咱们的Java项目吧：</p>
<pre><code>gradle build
</code></pre><p>只是现在咱们的Java项目还是一个空架子，不用急，在下文中我们将一步一步在这个空架子中搭建一个有血有肉的Spring Boot项目。<br>值得一提的是，虽然此时的build.gradle文件中只有一行配置（apply plugin: ‘java’，作用是引入java插件），但是其背后已经帮我们做了很多事情，比如它使得我们能够运行gradle build命令。这里的build即为Gradle中的一个任务（Task），我们还可以运行以下命令查看到更多的Task。</p>
<pre><code>gradle tasks
</code></pre><p>此时输出：</p>
<pre><code>…
Build tasks
    -----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.
...
</code></pre><p>这里的assemble、build和jar等Task都是java插件引入的。build.gradle是Gradle的配置文件。</p>
<h1 id="使用Gradle-Wrapper"><a href="#使用Gradle-Wrapper" class="headerlink" title="使用Gradle Wrapper"></a>使用Gradle Wrapper</h1><p>对于所有的Gradle项目来说，笔者都推荐使用Gradle Wrapper，甚至应该将其当做创建代码库之后的第一件事来做。使用Gradle Wrapper有以下好处：</p>
<ol>
<li>不用安装gradle也能运行gradle</li>
<li><p>所有人使用相同的gradle版本<br>在build.gradle中加入以下配置：</p>
<p>task wrapper(type: Wrapper) {<br>gradleVersion = ‘3.0’<br>}    </p>
</li>
</ol>
<p>然后在命令行运行：</p>
<pre><code>gradle wrapper
</code></pre><p>此时会生成以下三个文件（夹）：gradlew、gradlew.bat和gradle目录。<br>这里的gradlew和gradlew.bat其实只是脚本文件（前者用于Unix/Linux/Mac，后者用于Windows），在使用gradle命令的地方替换为gradlew或gradlew.bat，他们将自动下载指定的gradle版本，然后用该版本进行项目构建。如上文所示，本文中我们配置gradle版本为3.0。<br>请注意，这三个文件（夹）都需要提交到代码库中。当项目其他人拿到代码之后，由于gradlew和gradlew.bat文件均在源代码中，他们本地即便没有gradle，依然可以通过以下命令进行项目构建：</p>
<pre><code>./gradlew build
</code></pre><p>如果你的项目有持续集成（CI）服务器（你也应该有），那么你的CI机器也没有必要安装Gradle了。另外，此时所有人都是使用的相同版本的gradle，进而避免了由于版本不同所带来的问题。</p>
<h1 id="添加Spring-Boot依赖"><a href="#添加Spring-Boot依赖" class="headerlink" title="添加Spring Boot依赖"></a>添加Spring Boot依赖</h1><p>在本文中，我们的业务非常简单———输出“Hello World！”。但是麻雀虽小，五脏俱全，首先需要在build.gradle中配置spring-boot插件，并引入Spring的Web组件，整个build.gradle如下：</p>
<pre><code>buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.5.2.RELEASE&quot;)
    }
}

repositories {
    jcenter()
}

apply plugin: &apos;java&apos;
apply plugin: &apos;org.springframework.boot&apos;


sourceCompatibility = 1.8
targetCompatibility = 1.8


task wrapper(type: Wrapper) {
    gradleVersion = &apos;3.0&apos;
}

dependencies {
    compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;)
    testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)
}
</code></pre><p>然后创建Application类：</p>
<pre><code>@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
</code></pre><p>依然很简单，是吧？！这个Application类便是Spring Boot程序的入口。另外我们还需要一个Controller和一个业务类HelloWorld：</p>
<pre><code>HelloWorldController:
@RestController(&quot;/helloworld&quot;)
public class HelloController {

    private HelloWorld helloWorld;

    public HelloController(HelloWorld helloWorld) {
        this.helloWorld = helloWorld;
    }

    @GetMapping
    public String hello() {
        return helloWorld.hello();
    }
}
HelloWorld:
@Component
public class HelloWorld {

    public String hello() {
        return &quot;Hello World!&quot;;
    }
}
</code></pre><p>此时工程的目录结构为：</p>
<pre><code>├── README.md
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── src
    ├── main
    │   └── java
    │       └── davenkin
    │           ├── Application.java
    │           ├── HelloController.java
    │           └── HelloWorld.java
    └── test
        └── java
        `
</code></pre><p>然后运行：</p>
<pre><code>./gradlew bootRun
</code></pre><p>在浏览器或者Postman中打开<em><a href="http://localhost:8080/gradle-spring-boot/helloworld" target="_blank" rel="noopener">http://localhost:8080/gradle-spring-boot/helloworld</a></em>，便可以看到久违的”Hello World！”了。</p>
<h1 id="生成IDE工程文件"><a href="#生成IDE工程文件" class="headerlink" title="生成IDE工程文件"></a>生成IDE工程文件</h1><p>我曾经看到不少人在Eclipse或者IntelliJ IDEA中导入Maven/Gradle工程，甚至在IDE中使用嵌入Tomcat容器。我并不推荐这么做，这些严重依赖于GUI操作的功能其实是很笨拙、很脆弱的。以嵌入Tomcat容器为例，它要求项目中所有人都在自己的IDE中手动地对Tomcat进行配置，而手动的过程总是容易出错的。在持续交付中有个原则是“凡是能够自动化的，都应该自动化”，这里的自动化说白了其实就是代码化。</p>
<p>因此，在使用Gradle时，笔者更推崇的一种方式是通过Gradle的IDE插件一键式地生成IDE工程文件，然后在IDE中直接打开这样的工程文件。这样的好处一是非常简单，二是所有人都使用了相同的IDE配置。</p>
<p>在Gradle中配置IntelliJ IDEA插件，只需在build.gradle中配置：</p>
<pre><code>apply plugin: &apos;idea&apos;
</code></pre><p>然后运行：</p>
<pre><code>./gradlew idea
</code></pre><p>此时将生成后缀为ipr的IntelliJ IDEA工程文件，在IntelliJ IDEA中直接打开(Open)该文件即可。</p>
<p>对于Eclipse，在build.gradle中增加以下配置：</p>
<pre><code>apply plugin: &apos;eclipse&apos;
</code></pre><p>然后运行：</p>
<pre><code>./gradlew eclipse
</code></pre><p>此时将生成Eclipse的.project工程文件。</p>
<p><em>请注意，所有IDE工程文件都不应该提交到代码库，对于Git来说应该将这些文件注册到.gitignore文件中。各个开发者拿到代码后需要各自运行./graldlw idea或./gradlew eclipse命令以生成本地工程文件。</em></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>至少有两种方式可以对Spring Boot项目进行调试。一种是直接运行命令：</p>
<pre><code>./gradlew bootRun --debug-jvm
</code></pre><p>此时程序将默认监听5005端口，并暂停以等待调试客户端的连接，然后启动Spring Boot。</p>
<p>另一种方式是使用Gradle的Application插件，在build.gradle中添加：</p>
<pre><code>apply plugin: &apos;application&apos;
applicationDefaultJvmArgs = [ &quot;-    agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005&quot; ]
</code></pre><p>此时运行：</p>
<pre><code>./gradlew bootRun
</code></pre><p>程序将启动并监听5005调试端口，但是与第一种方法不同的是，程序不会暂停，而是将直接启动整个Spring Boot程序。如果你想调试Spring Boot在启动过程中的某些代码，比如Spring框架启动代码，那么请选择第一种方式；否则，第二种是更合适的选择，因为我们并不是每次启动程序都一定会调试的，对吧？！</p>
<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><p>软件项目可以包含多种自动化测试，比如单元测试、集成测试、功能测试等。对于Spring Boot项目来说，笔者推荐将自动化测试划分为单元测试和API测试，其中单元测试即是传统的单元测试，而API测试包含了集成测试、功能测试和端到端测试的功能，它的测试对象是程序向外暴露的REST API接口，在测试时我们需要启动整个Spring Boot程序，然后模拟客户端调用这些API接口来完成业务测试用例。</p>
<p>单元测试相对比较简单，Spring Boot也提供了一些有助于单元测试的设施，但是我并不推荐大家使用，因为单元测试应该是非常纯粹、粒度非常小的测试，不应该有框架掺和。</p>
<p>通常来说，单元测试和API测试应该是分离的，也即他们的代码应该是分开的，运行测试的命令也应该是不同的。但是这给Gradle带来了难题，因为默认情况下Gradle只提供一个./gradlew test命令用于测试，并且默认要求测试代码位于src/test/java目录下。为此，我们需要对Gradle进行改造。</p>
<p>我们的目的是：</p>
<ul>
<li>默认的src/test/java目录用于单元测试代码，通过./gradlew test运行</li>
<li>新建src/apiTest/java目录用于API测试代码，通过./gradlew apiTest运行</li>
</ul>
<p>可以看到，我么将Gradle默认的测试设施用于了单元测试，也即对于单元测试我们不需要做任何改变。对于API测试而言，首先我们需要添加名为apiTest的源代码集合（SrouceSet），该SourceSet即对应了src/apiTest/java目录，在build.gradle文件中增加如下配置：</p>
<pre><code>sourceSets {
    apiTest {
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}

configurations {
    apiTestCompile.extendsFrom testCompile
    apiTestRuntime.extendsFrom testRuntime
}
</code></pre><p>然后，添加一个Test类型的Task用于运行src/apiTest/java目录下的API测试代码：</p>
<pre><code>task apiTest(type: Test) {
    testClassesDir =     sourceSets.apiTest.output.classesDir
    classpath = sourceSets.apiTest.runtimeClasspath
}
</code></pre><p>为了使Intelli IDEA能够感知到这些新添加的测试代码，我们需要对Gradle的idea插件进行额外配置：</p>
<pre><code>idea {
    module {
        testSourceDirs += file(&apos;src/apiTest/java&apos;)
        testSourceDirs += file(&apos;src/apiTest/resources&apos;)
        scopes.TEST.plus += [configurations.apiTestCompile]
        scopes.TEST.plus += [configurations.apiTestRuntime]
    }
}
</code></pre><p>另外，为了使本地构建（./gradlew biuld）过程能够先运行单元测试，再运行API测试，我们还需要做以下配置：</p>
<pre><code>apiTest.mustRunAfter test
build.dependsOn apiTest
</code></pre><p>第一行的意思是API测试必须运行在单元测试之后，第二行的意思是将API测试包含在build任务中。</p>
<p><a href="http://www.cnblogs.com/davenkin/p/gradle-spring-boot.html" target="_blank" rel="noopener">原文链接</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Gradle</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/08/16/用Gradle构建Spring Boot项目/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Spring Boot" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/Spring Boot/">Spring Boot</a>
    </h1>
  

        
        <a href="/2017/07/19/Spring Boot/" class="archive-article-date">
  	<time datetime="2017-07-19T09:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring-Boot-是什么"><a href="#Spring-Boot-是什么" class="headerlink" title="Spring Boot 是什么"></a>Spring Boot 是什么</h2><ul>
<li>为所有Spring 开发提供一个更快更广泛的入门体验</li>
<li>开箱即用，不合适时也可以快速抛弃</li>
<li>提供一系列大型项目常用的非功能性特征</li>
<li>零配置（无需XML配置，遵循“约定大于配置”）<h2 id="Spring-Boot-简化开发"><a href="#Spring-Boot-简化开发" class="headerlink" title="Spring Boot 简化开发"></a>Spring Boot 简化开发</h2>抛弃了传统JavaEE项目繁琐的配置、学习过程，让企业级应用开发过程变得更容易。<h2 id="Spring-Boot与其他框架的关系"><a href="#Spring-Boot与其他框架的关系" class="headerlink" title="Spring Boot与其他框架的关系"></a>Spring Boot与其他框架的关系</h2><h2 id="通过Spring-Initializr初始化一个Web项目"><a href="#通过Spring-Initializr初始化一个Web项目" class="headerlink" title="通过Spring Initializr初始化一个Web项目"></a>通过Spring Initializr初始化一个Web项目</h2><code>http://start.spring.io/</code></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Spring</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/19/Spring Boot/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-mmall之Spring" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/mmall之Spring/">Spring</a>
    </h1>
  

        
        <a href="/2017/06/28/mmall之Spring/" class="archive-article-date">
  	<time datetime="2017-06-28T11:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-06-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring-学习"><a href="#Spring-学习" class="headerlink" title="Spring 学习"></a>Spring 学习</h2><p>spring-projects/spring-mvc-showcase<br>spring-projects/spring-petclinic<br>spring-projects/greenhouse</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Spring</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/06/28/mmall之Spring/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Spring4_day01" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/01/Spring4_day01/">Spring框架第一天</a>
    </h1>
  

        
        <a href="/2017/04/01/Spring4_day01/" class="archive-article-date">
  	<time datetime="2017-04-01T09:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="今天课程：Spring框架第一天"><a href="#今天课程：Spring框架第一天" class="headerlink" title="今天课程：Spring框架第一天"></a>今天课程：Spring框架第一天</h2><hr>
<p><strong>Spring框架的学习路线</strong></p>
<pre><code>1. Spring第一天：Spring的IOC容器之XML的方式，Spring框架与Web项目整合
2. Spring第二天：Spring的IOC容器之注解的方式，Spring的AOP技术
3. Spring第三天：Spring的事务管理、Spring框架的JDBC模板
4. Spring第四天：SSH三大框架的整合
</code></pre><hr>
<p><strong>今天内容概述</strong></p>
<pre><code>1. Spring框架的概述
2. SpringIOC的快速入门
3. IoC容器XML的方式
4. 在web项目中集成Spring
</code></pre><hr>
<h3 id="案例一：使用Spring的IOC技术完成客户的保存功能"><a href="#案例一：使用Spring的IOC技术完成客户的保存功能" class="headerlink" title="案例一：使用Spring的IOC技术完成客户的保存功能"></a>案例一：使用Spring的IOC技术完成客户的保存功能</h3><hr>
<p><strong>需求分析</strong></p>
<pre><code>1. 使用Spring的IOC技术完成客户的保存功能
</code></pre><hr>
<h3 id="技术分析之Spring框架的概述和入门"><a href="#技术分析之Spring框架的概述和入门" class="headerlink" title="技术分析之Spring框架的概述和入门"></a>技术分析之Spring框架的概述和入门</h3><hr>
<p><strong>技术分析之什么是Spring框架</strong></p>
<pre><code>1. Spring框架的概述
    * Spring是一个开源框架
    * Spring是于2003 年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。
    * 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。
    * Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以    从Spring中受益。
    * Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。

    * EE开发分成三层结构
        * WEB层        -- Spring MVC
        * 业务层    -- Bean管理:(IOC)
        * 持久层    -- Spring的JDBC模板.ORM模板用于整合其他的持久层框架
</code></pre><hr>
<p><strong>技术分析之Spring框架的特点</strong></p>
<pre><code>1. 为什么要学习Spring的框架
    * 方便解耦，简化开发
        * Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理
    * AOP编程的支持
        * Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能
    * 声明式事务的支持
        * 只需要通过配置就可以完成对事务的管理，而无需手动编程
    * 方便程序的测试
        * Spring对Junit4支持，可以通过注解方便的测试Spring程序
    * 方便集成各种优秀框架
        * Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持
    * 降低JavaEE API的使用难度
        * Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低

2. Spring框架的版本
    * Spring3.x和Spring4.x的版本
</code></pre><hr>
<p><strong>技术分析之Spring框架的IOC核心功能快速入门</strong></p>
<pre><code>1. 什么是IOC的功能？
    * IoC        -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！
    * 使用IOC可以解决的程序耦合性高的问题！！

2. 步骤一：下载Spring框架的开发包
    * 官网：http://spring.io/
    * 下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:)
        * docs        -- API和开发规范
        * libs        -- jar包和源码
        * schema    -- 约束

3. 步骤二：创建JavaWEB项目，引入Spring的开发包
    * 引入Spring框架IOC核心功能需要的具体的jar包
        * Spring框架的IOC的功能，那么根据Spring框架的体系结构图能看到，只需要引入如下的jar包
            * Beans
            * Core
            * Context
            * Expression Language

        * Spring框架也需要引入日志相关的jar包
            * 在spring-framework-3.0.2.RELEASE-dependencies/org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1
                * com.springsource.org.apache.commons.logging-1.1.1.jar

            * 还需要引入log4j的jar包 spring-framework-3.0.2.RELEASE-dependencies\org.apache.log4j\com.springsource.org.apache.log4j\1.2.15
                * com.springsource.org.apache.log4j-1.2.15.jar

4. 步骤三：创建对应的包结构，编写Java的类，要注意：以后使用Spring框架做开发，都需要来编写接口与实现类！！
    * com.itcast.demo1
        * UserService            -- 接口
        * UserServiceImpl        -- 具体的实现类

5. 步骤四：想把UserServiceImpl实现类的创建交给Spring框架来管理，需要创建Spring框架的配置文件，完成配置
    * 在src目录下创建applicationContext.xml的配置文件，名称是可以任意的，但是一般都会使用默认名称！！

    * 引入spring的约束，需要先找到具体的约束头信息！！
        * spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html
        * 具体的约束如下：        
            &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
                xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                xsi:schemaLocation=&quot;
                    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
            &lt;/beans&gt;

    * 完成UserService的配置
        &lt;!-- Spring的快速入门 --&gt;
        &lt;bean id=&quot;userService&quot; class=&quot;com.itcast.demo1.UserServiceImpl&quot;/&gt;

6. 步骤五：编写测试程序，采用Spring框架的工厂方式来获取到UserService接口的具体实现类！！
    public void demo2(){
        // 使用Spring的工厂:
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        // 通过工厂获得类:
        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);
        userService.sayHello();
    }
</code></pre><hr>
<p><strong>入门总结之Spring框架中的工厂（了解）</strong></p>
<pre><code>1. ApplicationContext接口
    * 使用ApplicationContext工厂的接口，使用该接口可以获取到具体的Bean对象
    * 该接口下有两个具体的实现类
        * ClassPathXmlApplicationContext            -- 加载类路径下的Spring配置文件
        * FileSystemXmlApplicationContext            -- 加载本地磁盘下的Spring配置文件

2. BeanFactory工厂（是Spring框架早期的创建Bean对象的工厂接口）
    * 使用BeanFactory接口也可以获取到Bean对象
        public void run(){
            BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));
            UserService us = (UserService) factory.getBean(&quot;us&quot;);
            us.sayHello();
        }

    * BeanFactory和ApplicationContext的区别
        * BeanFactory                -- BeanFactory采取延迟加载，第一次getBean时才会初始化Bean
        * ApplicationContext        -- 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能
            * 事件传递
            * Bean自动装配
            * 各种不同应用层的Context实现
</code></pre><hr>
<p><strong>入门总结之配置Spring框架编写XML的提示</strong></p>
<pre><code>1. 步骤一：先复制， http://www.springframework.org/schema/beans/spring-beans.xsd    
2. 步骤二：搜索XML Catalog，点击Add按钮
3. 步骤三：先选择Location的schema的约束地址
    * E:\class\2016\JavaEE28\day35_Spring框架第一天\资料\spring-framework-4.2.4.RELEASE-schema\beans\spring-beans-4.2.xsd
4. 步骤四：注意：Key type要选择：Schema location
5. 步骤五：Key把http://www.springframework.org/schema/beans/spring-beans.xsd复制上
</code></pre><hr>
<h3 id="技术分析之Spring框架的Bean管理的配置文件方式"><a href="#技术分析之Spring框架的Bean管理的配置文件方式" class="headerlink" title="技术分析之Spring框架的Bean管理的配置文件方式"></a>技术分析之Spring框架的Bean管理的配置文件方式</h3><hr>
<p><strong>技术分析之Spring框架中<bean>标签的配置</bean></strong></p>
<pre><code>1. id属性和name属性的区别
    * id        -- Bean起个名字，在约束中采用ID的约束，唯一
        * 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号    id:不能出现特殊字符

    * name        -- Bean起个名字，没有采用ID的约束（了解）
        * 取值要求：name:出现特殊字符.如果&lt;bean&gt;没有id的话 , name可以当做id使用
        * Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以/开头的，例如：/bookAction

2. class属性            -- Bean对象的全路径
3. scope属性            -- scope属性代表Bean的作用范围
    * singleton            -- 单例（默认值）
    * prototype            -- 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！
    * request            -- 应用在Web项目中,每次HTTP请求都会创建一个新的Bean
    * session            -- 应用在Web项目中,同一个HTTP Session 共享一个Bean
    * globalsession        -- 应用在Web项目中,多服务器间的session

4. Bean对象的创建和销毁的两个属性配置（了解）
    * 说明：Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法
    * init-method        -- 当bean被载入到容器的时候调用init-method属性指定的方法
    * destroy-method    -- 当bean从容器中删除的时候调用destroy-method属性指定的方法
        * 想查看destroy-method的效果，有如下条件
            * scope= singleton有效
            * web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法）
</code></pre><hr>
<p><strong>技术分析之依赖注入（DI）</strong></p>
<pre><code>1. IOC和DI的概念
    * IOC        -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！
    * DI        -- Dependency Injection，依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！

2.  DI（依赖注入）
    * 例如：如果UserServiceImpl的实现类中有一个属性，那么使用Spring框架的IOC功能时，可以通过依赖注入把该属性的值传入进来！！
    * 具体的配置如下
        &lt;bean id=&quot;us&quot; class=&quot;com.vvshyer.demo1.UserServiceImpl&quot;&gt;
            &lt;property name=&quot;uname&quot; value=&quot;小风&quot;/&gt;
        &lt;/bean&gt;
</code></pre><hr>
<p><strong>技术分析之Spring框架的属性注入</strong></p>
<pre><code>1. 对于类成员变量，常用的注入方式有两种
    * 构造函数注入
    * 属性setter方法注入

2. 在Spring框架中提供了前两种的属性注入的方式
    1. 构造方法的注入方式，两步
        * 编写Java的类，提供构造方法
            public class Car {
                private String name;
                private double money;
                public Car(String name, double money) {
                    this.name = name;
                    this.money = money;
                }
                @Override
                public String toString() {
                    return &quot;Car [name=&quot; + name + &quot;, money=&quot; + money + &quot;]&quot;;
                }
            }

        * 编写配置文件
            &lt;bean id=&quot;car&quot; class=&quot;com.vvshyer.demo4.Car&quot;&gt;
                &lt;constructor-arg name=&quot;name&quot; value=&quot;大奔&quot;/&gt;
                &lt;constructor-arg name=&quot;money&quot; value=&quot;100&quot;/&gt;
            &lt;/bean&gt;

    2. 属性的setter方法的注入方式
        * 编写Java的类，提供属性和对应的set方法即可
        * 编写配置文件

    3. 如果Java类的属性是另一个Java的类，那么需要怎么来注入值呢？
        * &lt;property name=&quot;name&quot; rel=&quot;具体的Bean的ID或者name的值&quot;/&gt;
        * 例如：
            &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot;&gt;
                &lt;property name=&quot;pname&quot; value=&quot;美美&quot;/&gt;
                &lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&gt;
            &lt;/bean&gt;
</code></pre><hr>
<p><strong>技术分析之Spring的2.5版本中提供了一种:p名称空间的注入（了解）</strong></p>
<pre><code>1. 步骤一：需要先引入 p 名称空间
    * 在schema的名称空间中加入该行：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;

2. 步骤二：使用p名称空间的语法
    * p:属性名 = &quot;&quot;
    * p:属性名-ref = &quot;&quot;

3. 步骤三：测试
    * &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot; p:pname=&quot;老王&quot; p:car2-ref=&quot;car2&quot;/&gt;
</code></pre><hr>
<p><strong>技术分析之Spring的3.0提供了一种:SpEL注入方式（了解）</strong></p>
<pre><code>1. SpEL：Spring Expression Language是Spring的表达式语言，有一些自己的语法
2. 语法
    * #{SpEL}

3. 例如如下的代码
    &lt;!-- SpEL的方式 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot;&gt;
        &lt;property name=&quot;pname&quot; value=&quot;#{&apos;小风&apos;}&quot;/&gt;
        &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt;
    &lt;/bean&gt;

4. 还支持调用类中的属性或者方法
    * 定义类和方法，例如
        public class CarInfo {
            public String getCarname(){
                return &quot;奇瑞QQ&quot;;
            }
        }
</code></pre><hr>
<p><strong>技术分析之数组，集合(List,Set,Map)，Properties等的注入</strong></p>
<pre><code>1. 如果是数组或者List集合，注入配置文件的方式是一样的
    &lt;bean id=&quot;collectionBean&quot; class=&quot;com.vvshyer.demo5.CollectionBean&quot;&gt;
        &lt;property name=&quot;arrs&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;美美&lt;/value&gt;
                &lt;value&gt;小风&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

2. 如果是Set集合，注入的配置文件方式如下：
    &lt;property name=&quot;sets&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;哈哈&lt;/value&gt;
            &lt;value&gt;呵呵&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;

3. 如果是Map集合，注入的配置方式如下：
    &lt;property name=&quot;map&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;老王2&quot; value=&quot;38&quot;/&gt;
            &lt;entry key=&quot;凤姐&quot; value=&quot;38&quot;/&gt;
            &lt;entry key=&quot;如花&quot; value=&quot;29&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;

4. 如果是properties属性文件的方式，注入的配置如下：
    &lt;property name=&quot;pro&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;uname&quot;&gt;root&lt;/prop&gt;
            &lt;prop key=&quot;pass&quot;&gt;123&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
</code></pre><hr>
<p><strong>技术分析之Spring框架的配置文件分开管理（了解）</strong></p>
<pre><code>1. 例如：在src的目录下又多创建了一个配置文件，现在是两个核心的配置文件，那么加载这两个配置文件的方式有两种！
    * 主配置文件中包含其他的配置文件:
        &lt;import resource=&quot;applicationContext2.xml&quot;/&gt;

    * 工厂创建的时候直接加载多个配置文件:
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                    &quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;);
</code></pre><hr>
<h3 id="Spring框架整合WEB"><a href="#Spring框架整合WEB" class="headerlink" title="Spring框架整合WEB"></a>Spring框架整合WEB</h3><hr>
<p><strong>Spring框架整合WEB（不是最终的方案）</strong></p>
<pre><code>1. 创建JavaWEB项目，引入Spring的开发包。编写具体的类和方法。
    * 环境搭建好后，启动服务器来测试项目，发送每访问一次都会加载一次配置文件，这样效率会非常非常慢！！

2. 解决上面的问题
    * 将工厂创建好了以后放入到ServletContext域中.使用工厂的时候,从ServletContext中获得.
        * ServletContextListener:用来监听ServletContext对象的创建和销毁的监听器.
        * 当ServletContext对象创建的时候:创建工厂 , 将工厂存入到ServletContext

3. Spring整合Web项目
    * 引入spring-web-4.2.4.RELEASE.jar包
    * 配置监听器
         &lt;!-- 配置Spring的核心监听器: --&gt;
         &lt;listener&gt;
             &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
         &lt;/listener&gt;
         &lt;context-param&gt;
             &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
             &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
         &lt;/context-param&gt;

4. 修改servlet的代码
    * 从ServletContext中获得工厂
    * 具体代码如下
        ServletContext servletContext = ServletActionContext.getServletContext();
        // 需要使用WEB的工厂的方式
        WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        CustomerService cs = (CustomerService) context.getBean(&quot;customerService&quot;);
        cs.save();    
</code></pre><hr>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Spring</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/01/Spring4_day01/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-计算机网络笔记03" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/计算机网络笔记03/">计算机网络笔记03</a>
    </h1>
  

        
        <a href="/2017/03/31/计算机网络笔记03/" class="archive-article-date">
  	<time datetime="2017-03-31T11:51:40.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-31</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1-数据链路层的基本概念"><a href="#3-1-数据链路层的基本概念" class="headerlink" title="3.1  数据链路层的基本概念"></a>3.1  数据链路层的基本概念</h2><p>链路：一条无源的点到点的物理线路段，中间没有其他任何交换结点。</p>
<p>数据链路：把实现这些协议的硬件和软件加到链路上，就构成数据链路。</p>
<p>帧：在数据链路层传输的数据单位。</p>
<h4 id="数据链路层的主要功能"><a href="#数据链路层的主要功能" class="headerlink" title="数据链路层的主要功能"></a>数据链路层的主要功能</h4><ul>
<li>链路管理</li>
<li>帧定界</li>
<li>流量控制</li>
<li>差错控制</li>
<li>将数据和控制信息区分开</li>
<li>透明传输</li>
<li>寻址<h2 id="3-2-停止等待协议"><a href="#3-2-停止等待协议" class="headerlink" title="3.2  停止等待协议"></a>3.2  停止等待协议</h2><h3 id="3-2-1-完全理想化的数据传输"><a href="#3-2-1-完全理想化的数据传输" class="headerlink" title="3.2.1 完全理想化的数据传输"></a>3.2.1 完全理想化的数据传输</h3><h3 id="3-2-2-具有最简单流量控制的数据链路层协议"><a href="#3-2-2-具有最简单流量控制的数据链路层协议" class="headerlink" title="3.2.2 具有最简单流量控制的数据链路层协议"></a>3.2.2 具有最简单流量控制的数据链路层协议</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">	在发送结点：</span><br><span class="line">	1.从主机取一个数据帧</span><br><span class="line">	2.将数据帧送到数据链路层的发送缓存</span><br><span class="line">	3.将发送缓存中的数据帧发送出去</span><br><span class="line">	4.等待</span><br><span class="line">	5.若收到由接收结点发过来的信息（格式内容事先商定），则从主机取一个新的数据帧，然后转道到2</span><br><span class="line">	</span><br><span class="line">	在接收结点：</span><br><span class="line">	1.等待</span><br><span class="line">	2.若收到由发送结点发过来的数据帧，则将其放入数据链路层的接收缓存</span><br><span class="line">	3。将接收缓存中的数据帧上交主机</span><br><span class="line">	4.向发送结点发一信息，表示数据帧已经上交给主机</span><br><span class="line">	5.转到1</span><br><span class="line">```### 3.2.3 实用的停止等待协议</span><br><span class="line">![](/assets/network/ch3p01.png)</span><br><span class="line"></span><br><span class="line">重传时间：略大于“从发完数据帧到收到确认帧所需的平均时间”</span><br><span class="line"></span><br><span class="line">解决重复帧的问题：</span><br><span class="line">	* 使每一个数据帧带上不同的发送序号，每发送一个新的数据帧就把它的发送序号加1</span><br><span class="line">	* 若结点B收到发送序号相同的数据帧，就表明出现了重复帧。这时应丢弃重复帧，因为已经收到过同样的数据帧并且也交给了主机B</span><br><span class="line">	* 但此时结点B还必须向A发送确认帧ACK，因为B已经知道A还没收到上一次发过去的确认帧ACK</span><br><span class="line"></span><br><span class="line">帧的编号问题：</span><br><span class="line">	* 对于停止等待协议，由于每发送一个数据帧就停止等待，因此一个比特编号就够了。（表示0和1两种不同的序号）</span><br><span class="line"></span><br><span class="line">数据链路层的停止等待协议采用了有效的检错重传机制，对网络层提供*可靠传输*的服务</span><br><span class="line">### 3.2.4 循环冗余检验的原理</span><br><span class="line">![](/assets/network/ch3p02.png)</span><br><span class="line"></span><br><span class="line">帧检验序列FCS：在数据后面添加上的冗余码称为帧检验序列FCS</span><br><span class="line">### 3.2.5 停止等待协议的算法</span><br><span class="line">* 收发双方实行停止等待</span><br><span class="line">* V(S):发送序号状态变量</span><br><span class="line">* V(R):接收序号状态变量</span><br><span class="line">* N(S):帧的序号</span><br><span class="line">* 序号只占1bit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在发送结点：<br>(1)  从主机取一个数据帧，送交发送缓存。<br>(2)  V(S)←0。<br>(3)  N(S)←V(S)。<br>(4)  将发送缓存中的数据帧发送出去。<br>(5)  设置超时计时器。<br>(6)  等待。    {等待以下三个事件中最先出现的一个}<br>(7)  ACK收到确认帧 ，<br>         从主机取一个新的数据帧，放入发送缓存；<br>           V(S)←[1-V(S)]，转到 (3)。<br>(8)  收到否认帧NAK，<br>         丢弃这个确认帧，转到(4)。<br>(9)  若超时计时器时间到，则转到(4)。</p>
<p>在接收结点：<br>(1)  V(R)←0。<br>(2)  等待。<br>(3)  收到一个数据帧；<br>         若 CRC校验无误<br>             若 N(S) = V(R)，则执行(4)；<br>             否则丢弃此数据帧，然后转到(6)。<br>          否则丢弃此数据帧，发送NAK，然后转到(2)。<br>(4)  将收到的数据帧中的数据部分送交上层软件<br>        （也就是数据链路层模型中的主机）。<br>(5)  V(R)←[1-V(R)]。<br>(6)  发送确认帧ACK，转到(2)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>(1)   从主机取一个数据帧，送交发送缓存。<br>(2)   V(S)←0。<br>(3)   N(S)←V(S)。<br>(4)  将发送缓存中的数据帧发送出去。<br>(5)  设置超时计时器。<br>(6)   等待。<br>(7)  收到确认帧 ACKn，<br>      若 n = 1 – V(s)，则：<br>           从主机取一个新的数据帧，放入发送缓存；<br>           V(S)←[1  V(S)]，转到 (3)。<br>      否则，丢弃这个确认帧，转到(6)。<br>(8)  若超时计时器时间到，则转到(4)。</p>
<p>(1)  V(R)←0。<br>(2)  等待。<br>(3)  收到一个数据帧；<br>          若 CRC校验无误<br>             若 N(S) = V(R)，则执行(4)；<br>             否则丢弃此数据帧，然后转到(6)。<br>          否则丢弃此数据帧，然后转到(2)。<br>(4)  将收到的数据帧中的数据部分送交上层软件<br>(5)  V(R)←[1  V(R)]。<br>(6)  n←V(R)；<br>      发送确认帧 ACKn，转到(2)。<br>```</p>
<h5 id="停止等待协议ARQ的优点缺点"><a href="#停止等待协议ARQ的优点缺点" class="headerlink" title="停止等待协议ARQ的优点缺点"></a>停止等待协议ARQ的优点缺点</h5><ul>
<li>优点：比较简单</li>
<li>缺点：通信信道的利用率不高<h2 id="3-3-连续-ARQ-协议"><a href="#3-3-连续-ARQ-协议" class="headerlink" title="3.3  连续 ARQ 协议"></a>3.3  连续 ARQ 协议</h2><img src="/assets/network/ch3p03.png" alt=""><h3 id="3-3-1-连续-ARQ-协议的工作原理"><a href="#3-3-1-连续-ARQ-协议的工作原理" class="headerlink" title="3.3.1 连续 ARQ 协议的工作原理"></a>3.3.1 连续 ARQ 协议的工作原理</h3><h3 id="3-3-2-连续-ARQ-协议的吞吐量"><a href="#3-3-2-连续-ARQ-协议的吞吐量" class="headerlink" title="3.3.2 连续 ARQ 协议的吞吐量"></a>3.3.2 连续 ARQ 协议的吞吐量</h3><h3 id="3-3-3-滑动窗口的概念"><a href="#3-3-3-滑动窗口的概念" class="headerlink" title="3.3.3 滑动窗口的概念"></a>3.3.3 滑动窗口的概念</h3><h3 id="3-3-4-信道利用率与最佳帧长"><a href="#3-3-4-信道利用率与最佳帧长" class="headerlink" title="3.3.4 信道利用率与最佳帧长"></a>3.3.4 信道利用率与最佳帧长</h3><h2 id="3-4-选择重传-ARQ-协议"><a href="#3-4-选择重传-ARQ-协议" class="headerlink" title="3.4  选择重传 ARQ 协议"></a>3.4  选择重传 ARQ 协议</h2><h2 id="3-5-面向比特的链路层协议-HDLC"><a href="#3-5-面向比特的链路层协议-HDLC" class="headerlink" title="3.5 面向比特的链路层协议 HDLC"></a>3.5 面向比特的链路层协议 HDLC</h2><h5 id="两种链路配置"><a href="#两种链路配置" class="headerlink" title="两种链路配置"></a>两种链路配置</h5></li>
<li>非平衡配置</li>
<li>平衡配置<h5 id="三种响应方式"><a href="#三种响应方式" class="headerlink" title="三种响应方式"></a>三种响应方式</h5></li>
<li>正常响应方式</li>
<li>异步响应方式</li>
<li>异步平衡响应方式<h2 id="3-6-因特网的点对点协议-PPP"><a href="#3-6-因特网的点对点协议-PPP" class="headerlink" title="3.6 因特网的点对点协议 PPP"></a>3.6 因特网的点对点协议 PPP</h2></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">计算机网络</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/31/计算机网络笔记03/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Struts2_day03" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/28/Struts2_day03/">Struts2第三天</a>
    </h1>
  

        
        <a href="/2017/03/28/Struts2_day03/" class="archive-article-date">
  	<time datetime="2017-03-28T11:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Struts2第三天"><a href="#Struts2第三天" class="headerlink" title="Struts2第三天"></a>Struts2第三天</h2><hr>
<p><strong>课程回顾：Struts2框架的第二天</strong></p>
<pre><code>1. Servlet的API
    * ActionContext对象
    * ServletActionContext对象

2. 结构类型的跳转
    * 全局结果
    * 局部结构，type属性

3. 数据的封装
    * 属性驱动方式
    * 模型驱动方式

4. 拦截器（自定义拦截器）
</code></pre><hr>
<p><strong>今天的课程内容</strong></p>
<pre><code>1. OGNL表达式（了解）
2. Struts2框架的值栈（值栈、存入值、取值）
3. OGNL的特殊符号
</code></pre><hr>
<h3 id="案例一：使用Struts2框架查询所有的客户功能"><a href="#案例一：使用Struts2框架查询所有的客户功能" class="headerlink" title="案例一：使用Struts2框架查询所有的客户功能"></a>案例一：使用Struts2框架查询所有的客户功能</h3><hr>
<p><strong>需求分析</strong></p>
<pre><code>1. 使用Struts2框架查询所有的客户功能
</code></pre><hr>
<p><strong>技术分析之OGNL表达式概述（了解）</strong></p>
<pre><code>1. OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写
    * 所谓对象图，即以任意一个对象为根，通过OGNL可以访问与这个对象关联的其它对象
    * 通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性

2. Struts2框架使用OGNL作为默认的表达式语言
    * OGNL是一种比EL强大很多倍的语言
    * xwork提供 OGNL表达式
    * ognl-3.0.5.jar

3. OGNL 提供五大类功能
   * 支持对象方法调用
   * 支持类静态的方法调用和值访问
   * 访问OGNL上下文（OGNL context）和ActionContext
   * 支持赋值操作和表达式串联
   * 操作集合对象

4. 测试的代码
    // 访问对象的方法
    @Test
    public void run1() throws OgnlException{
        OgnlContext context = new OgnlContext();
        // 获取对象的方法
        Object obj = Ognl.getValue(&quot;&apos;helloworld&apos;.length()&quot;, context, context.getRoot());
        System.out.println(obj);
    }

    // 获取OGNL上下文件的对象
    @Test
    public void run3() throws OgnlException{
        OgnlContext context = new OgnlContext();
        context.put(&quot;name&quot;, &quot;美美&quot;);
        // 获取对象的方法
        Object obj = Ognl.getValue(&quot;#name&quot;, context, context.getRoot());
        System.out.println(obj);
    }

    // 从root栈获取值
    @Test
    public void demo3() throws OgnlException{
        OgnlContext context = new OgnlContext();
        Customer c = new Customer();
        c.setCust_name(&quot;haha&quot;);
        context.setRoot(c);
        String name = (String) Ognl.getValue(&quot;cust_name&quot;, context, context.getRoot());
        System.out.println(name);
    }
</code></pre><hr>
<p><strong>技术分析之在Struts2框架中使用OGNL表达式</strong></p>
<pre><code>1. Struts2引入了OGNL表达式，主要是在JSP页面中获取值栈中的值
2. 具体在Struts2中怎么使用呢？如下步骤
    * 需要先引入Struts2的标签库
        &gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;

    * 使用Struts2提供的标签中的标签
        &gt; &lt;s:property value=&quot;OGNL表达式&quot;/&gt;

3. 在JSP页面使用OGNL表达式
    * 访问对象方法
        &lt;s:property value=&quot;&apos;hello&apos;.length()&quot;/&gt;
</code></pre><hr>
<p><strong>技术分析之值栈的概述</strong></p>
<pre><code>1. 问题一：什么是值栈？
    * 值栈就相当于Struts2框架的数据的中转站，向值栈存入一些数据。从值栈中获取到数据。
    * ValueStack 是 struts2 提供一个接口，实现类 OgnlValueStack ---- 值栈对象 （OGNL是从值栈中获取数据的 ）
    * Action是多例的，有一起请求，创建Action实例，创建一个ActionContext对象，代表的是Action的上下文对象，还会创建一个ValueStack对象。
    * 每个Action实例都有一个ValueStack对象 （一个请求 对应 一个ValueStack对象 ）
    * 在其中保存当前Action 对象和其他相关对象
    * Struts 框架把 ValueStack 对象保存在名为 “struts.valueStack” 的请求属性中,request中 （值栈对象 是 request一个属性）
        * ValueStack vs = (ValueStack)request.getAttribute(&quot;struts.valueStack&quot;);
</code></pre><hr>
<p><strong>技术分析之值栈的内部结构</strong></p>
<pre><code>2. 问题二 ： 值栈的内部结构 ？
    * 值栈由两部分组成
        &gt; root        -- Struts把动作和相关对象压入 ObjectStack 中--List
        &gt; context      -- Struts把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中

    * Struts会默认把下面这些映射压入ContextMap（context）中
        * 注意：request代表的是Map集合的key值，value的值其实也是一个Map集合。

        &gt; parameters: 该 Map 中包含当前请求的请求参数  ?name=xxx&amp;password=123
        &gt; request: 该 Map 中包含当前 request 对象中的所有属性
        &gt; session: 该 Map 中包含当前 session 对象中的所有属性
        &gt; application:该 Map 中包含当前 application  对象中的所有属性
        &gt; attr: 该 Map 按如下顺序来检索某个属性: request, session, application

    * ValueStack中 存在root属性 (CompoundRoot) 、 context 属性 （OgnlContext ）
        &gt; CompoundRoot 就是ArrayList
        &gt; OgnlContext 就是 Map

    * context 对应Map 引入 root对象 
        &gt; context中还存在 request、 session、application、 attr、 parameters 对象引用 
        &gt; OGNL表达式访问值栈中的数据
            * 访问root中数据时 不需要 #
            * 访问 request、 session、application、 attr、 parameters 对象数据 必须写 # 

        &gt; 操作值栈 默认指 操作 root 元素
</code></pre><p><img src="/assets/struts203/01-值栈的内部结构.bmp" alt="">    </p>
<hr>
<p><strong>技术分析之值栈的创建和ActionContext对象的关系</strong></p>
<pre><code>3. 问题三 ： 值栈对象的创建，ValueStack 和 ActionContext 是什么关系？
    * 值栈对象是请求时创建的
    * ActionContext是绑定到当前的线程上，那么在每个拦截器或者Action中获取到的ActionContext是同一个。
    * ActionContext中存在一个Map集合，该Map集合和ValueStack的context是同一个地址。
    * ActionContext中可以获取到ValueStack的引用，以后再开发，使用ActionContext来获取到值栈对象
</code></pre><hr>
<p><strong>技术分析之获取到值栈的对象</strong></p>
<pre><code>4. 问题四 ： 如何获得值栈对象
    * 获得值栈对象 有三种方法
        * ValueStack vs1 = (ValueStack) ServletActionContext.getRequest().getAttribute(&quot;struts.valueStack&quot;);
        * ValueStack vs2 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);
        * ValueStack vs3 = ActionContext.getContext().getValueStack();
</code></pre><hr>
<p><strong>技术分析之向值栈中保存数据</strong></p>
<pre><code>5. 问题五： 向值栈保存数据 （主要针对root栈）
    &gt; valueStack.push(Object obj);
        * push方法的底层调用root对象的push方法（把元素添加到0位置）

    &gt; valueStack.set(String key, Object obj);
        * 源码获取map集合（map有可能是已经存在的，有可能是新创建的），把map集合push到栈顶，再把数据存入到map集合中。

    &gt; 在jsp中 通过 &lt;s:debug /&gt; 查看值栈的内容
</code></pre><hr>
<p><strong>技术分析之从值栈中获取值</strong></p>
<pre><code>6. 问题六： 在JSP中获取值栈的数据
    * 总结几个小问题：
        &gt; 访问root中数据 不需要#
        &gt; 访问context其它对象数据 加 #
        &gt; 如果向root中存入对象的话，优先使用push方法。
        &gt; 如果向root中存入集合的话，优先要使用set方法。

    * 在OgnlContext中获取数据
        &gt; 在Action中向域对象中存入值
        &gt; request:&lt;s:property value=&quot;#request.username&quot;/&gt;
        &gt; session:&lt;s:property value=&quot;#session.username&quot;/&gt;
        &gt; application:&lt;s:property value=&quot;#application.username&quot;/&gt;
        &gt; attr:&lt;s:property value=&quot;#attr.username&quot;/&gt;
        &gt; parameters:&lt;s:property value=&quot;#parameters.cid&quot;/&gt;

6.1 代码如下
    &lt;!--
        // vs.push(&quot;美美&quot;);
        // 获取到栈顶的值
        &lt;s:property value=&quot;[0].top&quot;/&gt;
    --&gt;

    &lt;!--
        // 栈顶是map集合，通过key获取值
        vs.set(&quot;msg&quot;, &quot;小凤&quot;);
        &lt;s:property value=&quot;[0].top.msg&quot;/&gt;
    --&gt;

    &lt;!--  
        vs.push(user);
        // 栈顶放user对象
        &lt;s:property value=&quot;[0].top.username&quot;/&gt;
        &lt;s:property value=&quot;[0].top.password&quot;/&gt;
        // [0].top 关键字是可以省略的  findValue()
        &lt;s:property value=&quot;username&quot;/&gt;
    --&gt;

    &lt;!--
        vs.set(&quot;user&quot;, user);
        &lt;s:property value=&quot;[0].top.user.username&quot;/&gt;
        &lt;s:property value=&quot;[0].top.user.password&quot;/&gt;
        // 省略关键字
        &lt;s:property value=&quot;user.username&quot;/&gt;
    --&gt;

    &lt;!--  
        // 在ValueStack1Action提供了成员的属性
        private User user = new User(&quot;小泽&quot;,&quot;456&quot;);
        public User getUser() {
            return user;
        }
        public void setUser(User user) {
            this.user = user;
        }

        User user = new User(&quot;小苍&quot;,&quot;123&quot;);
        vs.set(&quot;user&quot;, user);
        // 从栈顶开始查找，找user的属性，显示名称    返回的小苍
        &lt;s:property value=&quot;user.username&quot;/&gt;

        // [1].top获取ValueStack1Action [1].top.user返回user对象  [1].top.user.username获取对象的属性名称
        &lt;s:property value=&quot;[1].top.user.username&quot;/&gt;
    --&gt;

    &lt;!--  
        栈顶是list集合
        vs.push(ulist);
        &lt;s:property value=&quot;[0].top[0].username&quot;/&gt;
        &lt;s:property value=&quot;[0].top[1].username&quot;/&gt;
    --&gt;

    &lt;!--
        vs.set(&quot;ulist&quot;, ulist);
        &lt;s:property value=&quot;ulist[0].username&quot;/&gt;
    --&gt;

    &lt;!-- 迭代的标签 
        属性
            * value    要迭代的集合，需要从值栈中获取
            * var    迭代过程中，遍历的对象
                * var编写上，把迭代产生的对象默认压入到context栈中，从context栈取值，加#号
                * var不编写，默认把迭代产生的对象压入到root栈中

        for(User user:ulist){}    
        // 编写var的属性
        &lt;s:iterator value=&quot;ulist&quot; var=&quot;u&quot;&gt;
            &lt;s:property value=&quot;#u.username&quot;/&gt;
            &lt;s:property value=&quot;#u.password&quot;/&gt;
        &lt;/s:iterator&gt;

        // 没有编写var关键字
        &lt;s:iterator value=&quot;ulist&quot;&gt;
            &lt;s:property value=&quot;username&quot;/&gt;
            &lt;s:property value=&quot;password&quot;/&gt;
        &lt;/s:iterator&gt;
    --&gt;

    &lt;!-- 从context栈中获取值，加#号

    HttpServletRequest request = ServletActionContext.getRequest();
    request.setAttribute(&quot;msg&quot;, &quot;美美&quot;);
    request.getSession().setAttribute(&quot;msg&quot;, &quot;小风&quot;);

    &lt;s:property value=&quot;#request.msg&quot;/&gt;
    &lt;s:property value=&quot;#session.msg&quot;/&gt;
    &lt;s:property value=&quot;#parameters.id&quot;/&gt;
    &lt;s:property value=&quot;#attr.msg&quot;/&gt;
    --&gt;

    &lt;!-- 在JSP页面上，查看值栈的内部结构 --&gt;
    &lt;s:debug&gt;&lt;/s:debug&gt;
</code></pre><hr>
<p><strong>技术分析之EL表达式也会获取到值栈中的数据</strong></p>
<pre><code>7. 问题七：为什么EL也能访问值栈中的数据？
    * StrutsPreparedAndExecuteFilter的doFilter代码中 request = prepare.wrapRequest(request);     
        &gt; 对Request对象进行了包装 ，StrutsRequestWrapper
        &gt; 增强了request的 getAttribute
            Object attribute = super.getAttribute(s);
            if (attribute == null) {
               attribute = stack.findValue(s);
            }
           &gt; 访问request范围的数据时，如果数据找不到，去值栈中找 
        &gt; request对象 具备访问值栈数据的能力 （查找root的数据）
</code></pre><hr>
<p><strong>总结OGNL表达式的特殊的符号</strong></p>
<pre><code>1. # 符号的用法
    * 获得contextMap中的数据
        &gt; &lt;s:property value=&quot;#request.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#session.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#application.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#attr.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt;
        &gt; &lt;s:property value=&quot;#parameters.name&quot;/&gt;

    * 构建一个map集合
        * 例如：
            * &lt;s:radio name=&quot;sex&quot; list=&quot;{&apos;男&apos;,&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt;
            * &lt;s:radio name=&quot;sex&quot; list=&quot;#{&apos;0&apos;:&apos;男&apos;,&apos;1&apos;:&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt;

2. % 符号的用法
    * 强制字符串解析成OGNL表达式。
        &gt; 例如：在request域中存入值，然后在文本框（&lt;s:textfield&gt;）中取值，现在到value上。
        &gt; &lt;s:textfield value=&quot;%{#request.msg}&quot;/&gt;

    * { }中值用&apos;&apos;引起来,此时不再是ognl表达式,而是普通的字符串
        &gt; 例如：&lt;s:property value=&quot;%{&apos;#request.msg&apos;}&quot;/&gt;

3. $ 符号的用法
    * 在配置文件中可以使用OGNL表达式，例如：文件下载的配置文件。
        &lt;action name=&quot;download1&quot; class=&quot;cn.itcast.demo2.DownloadAction&quot;&gt;
            &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt;
                &lt;param name=&quot;contentType&quot;&gt;${contentType}&lt;/param&gt;
                &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${downFilename}&lt;/param&gt;
            &lt;/result&gt;
        &lt;/action&gt;
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Struts2</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/28/Struts2_day03/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Struts2_day02" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/28/Struts2_day02/">Struts2第二天</a>
    </h1>
  

        
        <a href="/2017/03/28/Struts2_day02/" class="archive-article-date">
  	<time datetime="2017-03-28T10:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Struts2的第二天"><a href="#Struts2的第二天" class="headerlink" title="Struts2的第二天"></a>Struts2的第二天</h2><hr>
<p><strong>课程回顾：Struts2框架第一天</strong></p>
<pre><code>1. Struts2框架的概述，前端控制器的模式，核心的过滤器
2. 入门，编写struts.xml配置文件
3. 配置文件
    * 配置文件的加载
4. Action类的编写和访问
</code></pre><hr>
<p><strong>Struts2的第二天的内容</strong></p>
<pre><code>1. Struts2框架中的Servlet的API的使用
2. Struts2中Action接收请求参数
3. Struts2中自定义拦截器
</code></pre><hr>
<h3 id="案例一：使用Struts2作为WEB层完成客户的新增功能"><a href="#案例一：使用Struts2作为WEB层完成客户的新增功能" class="headerlink" title="案例一：使用Struts2作为WEB层完成客户的新增功能"></a>案例一：使用Struts2作为WEB层完成客户的新增功能</h3><hr>
<p><strong>需求分析</strong></p>
<pre><code>1. 原来是使用Servlet作为WEB层框架，现在需要使用Struts2作为WEB层完成客户的新增功能
</code></pre><hr>
<p><strong>技术分析之在Struts2框架中使用Servlet的API</strong></p>
<pre><code>1. 在Action类中也可以获取到Servlet一些常用的API
    * 需求：提供JSP的表单页面的数据，在Action中使用Servlet的API接收到，然后保存到三个域对象中，最后再显示到JSP的页面上。
        * 提供JSP注册的页面，演示下面这三种方式
            &lt;h3&gt;注册页面&lt;/h3&gt;
            &lt;form action=&quot;${ pageContext.request.contextPath }/xxx.action&quot; method=&quot;post&quot;&gt;
                姓名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt;
                密码:&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt;
                &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt;
            &lt;/form&gt;

2. 完全解耦合的方式
    * 如果使用该种方式，Struts2框架中提供了一个类，ActionContext类，该类中提供一些方法，通过方法获取Servlet的API
    * 一些常用的方法如下
        * static ActionContext getContext()                                          -- 获取ActionContext对象实例
        * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getParameters()          -- 获取请求参数，相当于request.getParameterMap();
        * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getSession()              -- 获取的代表session域的Map集合，就相当于操作session域。
        * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getApplication()         -- 获取代表application域的Map集合
        * void put(java.lang.String key, java.lang.Object value)                      -- 注意：向request域中存入值。

3. 使用原生Servlet的API的方式
    * Struts2框架提供了一个类，ServletActionContext，该类中提供了一些静态的方法
    * 具体的方法如下
        * getPageContext()
        * getRequest()
        * getResponse()
        * getServletContext()
</code></pre><hr>
<p><strong>技术分析之结果页面的跳转</strong></p>
<pre><code>1. 结果页面存在两种方式
    * 全局结果页面
        &gt; 条件：如果&lt;package&gt;包中的一些action都返回success，并且返回的页面都是同一个JSP页面，这样就可以配置全局的结果页面。
        &gt; 全局结果页面针对的当前的包中的所有的Action，但是如果局部还有结果页面，会优先局部的。使用的标签是
            &lt;global-results&gt;
                &lt;result&gt;/demo3/suc.jsp&lt;/result&gt;
            &lt;/global-results&gt;

    * 局部结果页面
        &lt;result&gt;/demo3/suc.jsp&lt;/result&gt;

2. 结果页面的类型
    * 结果页面使用&lt;result&gt;标签进行配置，包含两个属性
        &gt; name    -- 逻辑视图的名称
        &gt; type    -- 跳转的类型，值一些，需要掌握一些常用的类型。常见的结果类型去struts-default.xml中查找。
            * dispatcher        -- 转发.type的默认值.Action---&gt;JSP
            * redirect            -- 重定向.    Action---&gt;JSP
            * chain                -- 多个action之间跳转.从一个Action转发到另一个Action.    Action---Action
            * redirectAction    -- 多个action之间跳转.从一个Action重定向到另一个Action.    Action---Action
            * stream            -- 文件下载时候使用的
</code></pre><hr>
<p><img src="/assets/struts202/01-拦截器.bmp" alt="">    </p>
<p><strong>技术分析之Struts2框架的数据封装</strong></p>
<pre><code>1. 为什么要使用数据的封装呢？
    * 作为MVC框架，必须要负责解析HTTP请求参数，并将其封装到Model对象中
    * 封装数据为开发提供了很多方便
    * Struts2框架提供了很强大的数据封装的功能，不再需要使用Servlet的API完成手动封装了！！

2. Struts2中提供了两类数据封装的方式？
    * 第一种方式：属性驱动
        &gt; 提供对应属性的set方法进行数据的封装。
            * 表单的哪些属性需要封装数据，那么在对应的Action类中提供该属性的set方法即可。
            * 表单中的数据提交，最终找到Action类中的setXxx的方法，最后赋值给全局变量。

            * 注意0：Struts2的框架采用的拦截器完成数据的封装。
            * 注意1：这种方式不是特别好:因为属性特别多,提供特别多的set方法,而且还需要手动将数据存入到对象中.
            * 注意2：这种情况下，Action类就相当于一个JavaBean，就没有体现出MVC的思想，Action类又封装数据，又接收请求处理，耦合性较高。

        &gt; 在页面上，使用OGNL表达式进行数据封装。
            * 在页面中使用OGNL表达式进行数据的封装，就可以直接把属性封装到某一个JavaBean的对象中。
            * 在页面中定义一个JavaBean，并且提供set方法：例如：private User user;
            * 页面中的编写发生了变化，需要使用OGNL的方式，表单中的写法：&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;

            * 注意：只提供一个set方法还不够，必须还需要提供user属性的get和set方法！！！
                &gt; 先调用get方法，判断一下是否有user对象的实例对象，如果没有，调用set方法把拦截器创建的对象注入进来，

    * 第二种方式：模型驱动
        &gt; 使用模型驱动的方式，也可以把表单中的数据直接封装到一个JavaBean的对象中，并且表单的写法和之前的写法没有区别！
        &gt; 编写的页面不需要任何变化，正常编写name属性的值
        &gt; 模型驱动的编写步骤：
            * 手动实例化JavaBean，即：private User user = new User();
            * 必须实现ModelDriven&lt;T&gt;接口，实现getModel()的方法，在getModel()方法中返回user即可！！
</code></pre><hr>
<p><strong>技术分析之Struts2把数据封装到集合中</strong></p>
<pre><code>1. 封装复杂类型的参数（集合类型 Collection 、Map接口等）
2. 需求：页面中有可能想批量添加一些数据，那么现在就可以使用上述的技术了。把数据封装到集合中
3. 把数据封装到Collection中
    * 因为Collection接口都会有下标值，所有页面的写法会有一些区别，注意：
        &gt; &lt;input type=&quot;text&quot; name=&quot;products[0].name&quot; /&gt;
    * 在Action中的写法，需要提供products的集合，并且提供get和set方法。

4. 把数据封装到Map中
    * Map集合是键值对的形式，页面的写法
        &gt; &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].name&quot; /&gt;
    * Action中提供map集合，并且提供get和set方法
</code></pre><hr>
<p><strong>案例：添加客户</strong></p>
<pre><code>1. 功能
</code></pre><hr>
<p><strong>案例总结之Struts2的拦截器技术</strong></p>
<pre><code>1. 拦截器的概述
    * 拦截器就是AOP（Aspect-Oriented Programming）的一种实现。（AOP是指用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。）
    * 过滤器:过滤从客服端发送到服务器端请求的

    * 拦截器:拦截对目标Action中的某些方法进行拦截
        * 拦截器不能拦截JSP
        * 拦截到Action中某些方法

2. 拦截器和过滤器的区别
    1）拦截器是基于JAVA反射机制的，而过滤器是基于函数回调的
    2）过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器
    3）拦截器只能对Action请求起作用（Action中的方法），而过滤器可以对几乎所有的请求起作用（CSS JSP JS）

    * 拦截器 采用 责任链 模式
        &gt; 在责任链模式里,很多对象由每一个对象对其下家的引用而连接起来形成一条链
        &gt; 责任链每一个节点，都可以继续调用下一个节点，也可以阻止流程继续执行

    * 在struts2 中可以定义很多个拦截器，将多个拦截器按照特定顺序 组成拦截器栈 （顺序调用 栈中的每一个拦截器 ）

3. Struts2的核心是拦截器，看一下Struts2的运行流程
</code></pre><p><img src="/assets/struts202/02-执行流程.bmp" alt="">    </p>
<hr>
<p><strong>案例总结之自定义拦截器和配置</strong></p>
<pre><code>1. 编写拦截器，需要实现Interceptor接口，实现接口中的三个方法
    protected String doIntercept(ActionInvocation invocation) throws Exception {
        // 获取session对象
        User user = (User) ServletActionContext.getRequest().getSession().getAttribute(&quot;existUser&quot;);
        if(user == null){
            // 说明，没有登录，后面就不会执行了
            return &quot;login&quot;;
        }
        return invocation.invoke();
    }

2. 需要在struts.xml中进行拦截器的配置，配置一共有两种方式
    &lt;!-- 定义了拦截器 第一种方式
    &lt;interceptors&gt;
        &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.vvshyer.interceptor.DemoInterceptor&quot;/&gt;
    &lt;/interceptors&gt;
    --&gt;

    &lt;!-- 第二种方式：定义拦截器栈 --&gt;
    &lt;interceptors&gt;
        &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.vvshyer.interceptor.DemoInterceptor&quot;/&gt;
        &lt;!-- 定义拦截器栈 --&gt;
        &lt;interceptor-stack name=&quot;myStack&quot;&gt;
            &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt;
            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;
        &lt;/interceptor-stack&gt;
    &lt;/interceptors&gt;

    &lt;action name=&quot;userAction&quot; class=&quot;com.vvshyer.demo3.UserAction&quot;&gt;
        &lt;!-- 只要是引用自己的拦截器，默认栈的拦截器就不执行了，必须要手动引入默认栈 
        &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt;
        &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;
        --&gt;

        &lt;!-- 引入拦截器栈就OK --&gt;
        &lt;interceptor-ref name=&quot;myStack&quot;/&gt;
    &lt;/action&gt;
</code></pre><hr>
<p><strong>案例二：使用拦截器判断用户是否已经登录</strong></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Struts2</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/28/Struts2_day02/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-struts2_day01" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/28/struts2_day01/">Struts2第一天</a>
    </h1>
  

        
        <a href="/2017/03/28/struts2_day01/" class="archive-article-date">
  	<time datetime="2017-03-28T09:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Struts2第一天"><a href="#Struts2第一天" class="headerlink" title="Struts2第一天"></a>Struts2第一天</h2><hr>
<p><strong>Struts2的学习路线</strong></p>
<pre><code>1. Struts2的入门：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写）
2. Struts2的Servlet的API、参数封装和拦截器
3. Struts2的值栈和OGNL表达式
</code></pre><hr>
<h3 id="今天的课程内容"><a href="#今天的课程内容" class="headerlink" title="今天的课程内容"></a>今天的课程内容</h3><pre><code>1. Struts2框架的概述
2. Struts2的快速入门
3. Struts2的运行流程
4. Struts2的常见配置（配置文件加载的顺序、struts.xml的常见配置（重点）、常量的配置等）
5. Struts2的Action的访问（Action的三种编写方式、Action类的配置、方法的调用等）
</code></pre><hr>
<h3 id="案例一：使用Struts2框架完成登录功能"><a href="#案例一：使用Struts2框架完成登录功能" class="headerlink" title="案例一：使用Struts2框架完成登录功能"></a>案例一：使用Struts2框架完成登录功能</h3><hr>
<p><strong>需求分析</strong></p>
<pre><code>1. 使用Struts2完成登录的功能
</code></pre><hr>
<p><strong>技术分析之Struts2框架的概述</strong></p>
<pre><code>1. 什么是Struts2的框架
    * Struts2是Struts1的下一代产品，是在 struts1和WebWork的技术基础上进行了合并的全新的Struts 2框架。
    * 其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。
    * Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。
    * 虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。

2. Struts2是一个基于MVC设计模式的Web层框架
    * MVC和JavaEE的三层结构
        * MVC设计模式:是由一些网站的开发人员提出来的
        * JavaEE三层结构:SUN公司为EE开发划分的结构

3. 常见的Web层的框架
    * Struts1
    * Struts2
    * Webwork
    * SpringMVC

4. Web层框架的特点
    * 都是一个特点，前端控制器模式
    * 记住：前端控制器（核心的控制器）
    * Struts2框架前端的控制器就是过滤器
</code></pre><p><img src="/assets/struts201/01-前端控制器模式.bmp" alt=""></p>
<hr>
<p><strong>技术分析之Struts2快速入门的环境准备</strong></p>
<pre><code>1. 创建WEB项目，编写JSP的页面，编写超链接，点击超链接发送请求，请求服务器，让服务器的方法去执行！！
    &lt;h3&gt;Struts2的入门程序&lt;/h3&gt;
    &lt;a href=&quot;${ pageContext.request.contextPath }/hello.action&quot;&gt;Struts2入门程序&lt;/a&gt;

2. 下载Struts2的开发包
    * https://struts.apache.org/        -- 官网地址

3. 解压struts-2.3.24-all.zip包
    * 解压后会看到有包和一些文件，大家需要掌握包相关的信息
        * apps    -- Struts2框架提供了一些应用
        * libs    -- Struts2框架开发的jar包
        * docs    -- Struts2框架开发文档
        * src    -- Struts2框架源码

4. 引入需要开发的jar包
    * Struts2框架的开发jar包非常多，但是不是所有都是必须要引入的，有一些必须要导入的jar包，这些jar包可以从Struts2框架提供的应用中找到。
    * 大家可以打开apps目录，然后找到struts2-blank.war应用。war包和zip包的压缩格式是一样的，所以可以自己修改后缀名，解压。
    * 找到解压后的应用，打开WEB-INF/lib目录下所以的jar包。复制到工程中，就可以了。

5. 需要配置Struts2的前端控制器，注意：这一步是必须要做的操作，这是Struts2核心的控制器。
    * Struts2的前端控制器就是一个过滤器，那么过滤器相关知识咱们都学习过，需要在web.xml中进行配置。
    * 前端控制器的类的路径和名称：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter
    * 具体配置如下
      &lt;filter&gt;
          &lt;filter-name&gt;struts2&lt;/filter-name&gt;
          &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
      &lt;/filter&gt;
      &lt;filter-mapping&gt;
          &lt;filter-name&gt;struts2&lt;/filter-name&gt;
          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
      &lt;/filter-mapping&gt;
</code></pre><hr>
<p><strong>技术分析之编写Action类</strong>    </p>
<pre><code>1. Action类是动作类，是Struts2处理请求，封装数据，响应页面的核心控制器。需要自己编写。
    package cn.itcast.action;
        public String sayHello(){
        System.out.println(&quot;Hello Struts2!!&quot;);
        return null;
    }
</code></pre><hr>
<p><strong>技术分析之编写Struts的配置文件</strong></p>
<pre><code>1. 配置文件名称是struts.xml（名称必须是struts.xml）
2. 在src下引入struts.xml配置文件（配置文件的路径必须是在src的目录下）
3. 配置如下
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE struts PUBLIC
        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
        &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;

    &lt;struts&gt;
        &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;
            &lt;action name=&quot;hello&quot; class=&quot;com.itheima.action.HelloAction&quot; method=&quot;sayHello&quot;&gt;
            &lt;/action&gt;
        &lt;/package&gt;
    &lt;/struts&gt;
</code></pre><hr>
<p><strong>入门总结之Struts2的执行流程</strong></p>
<pre><code>1. 执行的流程
    * 编写的页面，点击超链接，请求提交到服务器端。
    * 请求会先经过Struts2的核心过滤器（StrutsPrepareAndExecuteFilter）
        * 过滤器的功能是完成了一部分代码功能
        * 就是一系列的拦截器执行了，进行一些处理工作。
        * 咱们可以在struts-default.xml配置文件中看到有很多的拦截器。可以通过断点的方式来演示。
        * 拦截器执行完后，会根据struts.xml的配置文件找到请求路径，找到具体的类，通过反射的方式让方法执行。

2. 总结
    * JSP页面--&gt;StrutsPrepereAndExecuteFilter过滤器--&gt;执行一系列拦截器（完成了部分代码）--&gt;执行到目标Action--&gt;返回字符串--&gt;结果页面（result）--&gt;页面跳转
</code></pre><p><img src="/assets/struts201/02-执行流程.bmp" alt="">    </p>
<hr>
<p><strong>入门总结之struts.xml的配置文件提示的问题</strong></p>
<pre><code>1. 先找到struts.xml的配置文件，复制http://struts.apache.org/dtds/struts-2.3.dtd，注意，不要有双引号。
    * http://struts.apache.org/dtds/struts-2.3.dtd

2. 选择window -- 首选项 -- 搜索xml -- 选择xml Catalog
3. 选择添加按钮（add按钮）
    * key type 要选择URI
    * key的位置把刚才复制的路径拷贝进去。http://struts.apache.org/dtds/struts-2.3.dtd
    * Location要在本地能找到struts2-2.3.dtd的真实文件。点击File System，去资料中找到它

4. 如果想查看源代码
    * 选择资料/struts2/struts-2.3.24-all.zip
</code></pre><hr>
<p><strong>入门总结之Struts2框架配置文件加载的顺序</strong></p>
<pre><code>0. 需要掌握
    * 加载了哪些个配置文件（重点的）
    * 配置文件的名称是什么
    * 配置文件的位置
    * 配置文件的作用

1. Struts2框架的核心是StrutsPrepareAndExecuteFilter过滤器，该过滤器有两个功能
    * Prepare        -- 预处理，加载核心的配置文件
    * Execute        -- 执行，让部分拦截器执行

2. StrutsPrepareAndExecuteFilter过滤器会加载哪些配置文件呢？
    * 通过源代码可以看到具体加载的配置文件和加载配置文件的顺序
        * init_DefaultProperties();                 -- 加载org/apache/struts2/default.properties
        * init_TraditionalXmlConfigurations();        -- 加载struts-default.xml,struts-plugin.xml,struts.xml
        * init_LegacyStrutsProperties();            -- 加载自定义的struts.properties.
        * init_CustomConfigurationProviders();        -- 加载用户自定义配置提供者
        * init_FilterInitParameters() ;                -- 加载web.xml

3. 重点了解的配置文件
    * default.properties        -- 在org/apache/struts2/目录下，代表的是配置的是Struts2的常量的值
    * struts-default.xml        -- 在Struts2的核心包下，代表的是Struts2核心功能的配置（Bean、拦截器、结果类型等）
    * struts.xml                -- 重点中的重点配置，代表WEB应用的默认配置，在工作中，基本就配置它就可以了！！（可以配置常量）
    * web.xml                    -- 配置前端控制器（可以配置常量）

    * 注意：
        * 前3个配置文件是struts2框架的默认配置文件，基本不用修改。
        * 后3个配置文件可以允许自己修改struts2的常量。但是有一个特点：后加载的配置文件修改的常量的值，会覆盖掉前面修改的常量的值。

4. 总结（重点掌握的配置文件）
    * 先加载default.properties文件，在org/apache/struts2/default.properties文件，都是常量。
    * 又加载struts-default.xml配置文件，在核心的jar包最下方，struts2框架的核心功能都是在该配置文件中配置的。
    * 再加载struts.xml的配置文件，在src的目录下，代表用户自己配置的配置文件
    * 最后加载web.xml的配置文件

    * 后加载的配置文件会覆盖掉之前加载的配置文件（在这些配置文件中可以配置常量）

5. 注意一个问题
    * 哪些配置文件中可以配置常量？
        * default.properties        -- 默认值，咱们是不能修改的！！
        * struts.xml                -- 可以配置，开发中基本上都在该配置文件中配置常量
        * struts.properties            -- 可以配置，基本不会在该配置文件中配置
        * web.xml                    -- 可以配置，基本不会在该配置文件中配置

    * 后加载的配置文件会覆盖掉之前加载的配置！！
</code></pre><hr>
<p><strong>入门总结之struts.xml配置文件的配置</strong></p>
<pre><code>1. &lt;package&gt;标签，如果要配置&lt;Action&gt;的标签，那么必须要先配置&lt;package&gt;标签，代表的包的概念
    * 包含的属性
        * name                    -- 包的名称，要求是唯一的，管理action配置
        * extends                -- 继承，可以继承其他的包，只要继承了，那么该包就包含了其他包的功能，一般都是继承struts-default
        * namespace                -- 名称空间，一般与&lt;action&gt;标签中的name属性共同决定访问路径（通俗话：怎么来访问action），常见的配置如下
            * namespace=&quot;/&quot;        -- 根名称空间
            * namespace=&quot;/aaa&quot;    -- 带有名称的名称空间
        * abstract                -- 抽象的。这个属性基本很少使用，值如果是true，那么编写的包是被继承的

2. &lt;action&gt;标签
    * 代表配置action类，包含的属性
        * name            -- 和&lt;package&gt;标签的namespace属性一起来决定访问路径的
        * class            -- 配置Action类的全路径（默认值是ActionSupport类）
        * method        -- Action类中执行的方法，如果不指定，默认值是execute

3. &lt;result&gt;标签
    * action类中方法执行，返回的结果跳转的页面
        * name        -- 结果页面逻辑视图名称
        * type        -- 结果类型（默认值是转发，也可以设置其他的值）
</code></pre><hr>
<p><strong>入门总结之Struts2配置常量</strong></p>
<pre><code>1. 可以在Struts2框架中的哪些配置文件中配置常量？
    * struts.xml（必须要掌握，开发中基本上就在该配置文件中编写常量）
        * &lt;constant name=&quot;key&quot; value=&quot;value&quot;&gt;&lt;/constant&gt;
    * web.xml
        * 在StrutsPrepareAndExecuteFilter配置文件中配置初始化参数
    * 注意：后加载的配置的文件的常量会覆盖之前加载的常量！！

2. 需要大家了解的常量
    * struts.i18n.encoding=UTF-8            -- 指定默认编码集,作用于HttpServletRequest的setCharacterEncoding方法 
    * struts.action.extension=action,,        -- 该属性指定需要Struts 2处理的请求后缀，该属性的默认值是action，即所有匹配*.action的请求都由Struts2处理。如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开
    * struts.serve.static.browserCache=true        -- 设置浏览器是否缓存静态内容,默认值为true(生产环境下使用),开发阶段最好关闭 
    * struts.configuration.xml.reload=false        -- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认值为false(生产环境下使用) 
    * struts.devMode = false                    -- 开发模式下使用,这样可以打印出更详细的错误信息 
</code></pre><hr>
<p><strong>入门总结之指定多个struts的配置文件（了解）</strong></p>
<pre><code>1. 在大部分应用里，随着应用规模的增加，系统中Action的数量也会大量增加，导致struts.xml配置文件变得非常臃肿。
    为了避免struts.xml文件过于庞大、臃肿，提高struts.xml文件的可读性，我们可以将一个struts.xml配置文件分解成多个配置文件，然后在struts.xml文件中包含其他配置文件。

2. 可以在&lt;package&gt;标签中，使用&lt;include&gt;标签来引入其他的struts_xx.xml的配置文件。例如：
    &lt;struts&gt;
        &lt;include file=&quot;struts-part1.xml&quot;/&gt;
        &lt;include file=&quot;struts-part2.xml&quot;/&gt;
    &lt;/struts&gt;

3. 注意注意注意（重要的事情说三遍）：&lt;include file=&quot;cn/itcast/demo2/struts-part1.xml&quot;/&gt;
</code></pre><hr>
<p><strong>技术分析之Action类的三种写法</strong></p>
<pre><code>1. 配置文件学习完成，下面的重点是Action类的三种写法
    * Action类就是一个POJO类
        * 什么是POJO类，POJO（Plain Ordinary Java Object）简单的Java对象.简单记：没有继承某个类，没有实现接口，就是POJO的类。

    * Action类可以实现Action接口
        * Action接口中定义了5个常量，5个常量的值对应的是5个逻辑视图跳转页面（跳转的页面还是需要自己来配置），还定义了一个方法，execute方法。
        * 大家需要掌握5个逻辑视图的常量
            * SUCCESS        -- 成功.
            * INPUT            -- 用于数据表单校验.如果校验失败,跳转INPUT视图.
            * LOGIN            -- 登录.
            * ERROR            -- 错误.
            * NONE            -- 页面不转向.

    * Action类可以去继承ActionSupport类（开发中这种方式使用最多）
        * 设置错误信息
</code></pre><hr>
<p><strong>技术分析之Action的访问</strong></p>
<pre><code>1. 通过&lt;action&gt;标签中的method属性，访问到Action中的具体的方法。
    * 传统的配置方式，配置更清晰更好理解！但是扩展需要修改配置文件等！
    * 具体的实例如下：
        * 页面代码
            * &lt;a href=&quot;${pageContext.request.contextPath}/addBook.action&quot;&gt;添加图书&lt;/a&gt;
            * &lt;a href=&quot;${pageContext.request.contextPath}/deleteBook.action&quot;&gt;删除图书&lt;/a&gt;

        * 配置文件的代码
            &lt;package name=&quot;demo2&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;
                &lt;action name=&quot;addBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt;
                &lt;action name=&quot;deleteBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;delete&quot;&gt;&lt;/action&gt;
            &lt;/package&gt;

        * Action的代码
            public String add(){
                System.out.println(&quot;添加图书&quot;);
                return NONE;
            }
            public String delete(){
                System.out.println(&quot;删除图书&quot;);
                return NONE;
            }

2. 通配符的访问方式:(访问的路径和方法的名称必须要有某种联系.)    通配符就是 * 代表任意的字符
    * 使用通配符的方式可以简化配置文件的代码编写，而且扩展和维护比较容易。
    * 具体实例如下：
        * 页面代码
            &lt;a href=&quot;${pageContext.request.contextPath}/order_add.action&quot;&gt;添加订单&lt;/a&gt;
            &lt;a href=&quot;${pageContext.request.contextPath}/order_delete.action&quot;&gt;删除订单&lt;/a&gt;

        * 配置文件代码
            * &lt;action name=&quot;order_*&quot; class=&quot;cn.itcast.demo2.OrderAction&quot; method=&quot;{1}&quot;&gt;&lt;/action&gt;

        * Action的代码
            public String add(){
                System.out.println(&quot;添加订单&quot;);
                return NONE;
            }
            public String delete(){
                System.out.println(&quot;删除订单&quot;);
                return NONE;
            }

    * 具体理解：在JSP页面发送请求，http://localhost/struts2_01/order_add.action，配置文件中的order_*可以匹配该请求，*就相当于变成了add，method属性的值使用{1}来代替，{1}就表示的是第一个*号的位置！！所以method的值就等于了add，那么就找到Action类中的add方法，那么add方法就执行了！

3. 动态方法访问的方式（有的开发中也会使用这种方式）
    * 如果想完成动态方法访问的方式，需要开启一个常量，struts.enable.DynamicMethodInvocation = false，把值设置成true。
        * 注意：不同的Struts2框架的版本，该常量的值不一定是true或者false，需要自己来看一下。如果是false，需要自己开启。
        * 在struts.xml中开启该常量。
            * &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt;

    * 具体代码如下
        * 页面的代码
            * &lt;a href=&quot;${pageContext.request.contextPath}/product!add.action&quot;&gt;添加商品&lt;/a&gt;
            * &lt;a href=&quot;${pageContext.request.contextPath}/product!delete.action&quot;&gt;删除商品&lt;/a&gt;

        * 配置文件代码
            * &lt;action name=&quot;product&quot; class=&quot;cn.itcast.demo2.ProductAction&quot;&gt;&lt;/action&gt;

        * Action的类的代码
            public class ProductAction extends ActionSupport{
                public String add(){
                    System.out.println(&quot;添加订单&quot;);
                    return NONE;
                }
                public String delete(){
                    System.out.println(&quot;删除订单&quot;);
                    return NONE;
                }
            }
</code></pre><hr>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Struts2</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/28/struts2_day01/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 SUN Huayan
			</div>
			<div class="footer-center">
				<a href="http://www.miitbeian.gov.cn/">苏ICP备18005860号</a>
			</div>
			<div class="footer-right">
				<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
			</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p="./",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,d.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function f(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function c(t,n,e,r,o){var i=u(t),c=f(t)-n;if(c-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||c)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");c(t,document.body.scrollTop,-63,2,0),c(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}function l(){x.default.versions.mobile&&window.screen.width<800&&(i(),s())}var p=e(71),d=r(p),v=e(72),y=(r(v),e(84)),h=r(y),b=e(69),x=r(b),m=e(75),g=r(m),w=e(70);l(),(0,w.addLoadEvent)(function(){g.default.init()}),t.exports={}},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n,e){var r=e(49),o=e(15);t.exports=function(t){return r(o(t))}},function(t,n,e){t.exports=!e(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,e){var r=e(6),o=e(12);t.exports=e(4)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(10),o=e(30),i=e(24),u=Object.defineProperty;n.f=e(4)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(22)("wks"),o=e(13),i=e(1).Symbol,u="function"==typeof i,f=t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=r},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(35),o=e(16);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(11);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(6).f,o=e(2),i=e(7)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(22)("keys"),o=e(13);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(1),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n,e){var r=e(11);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n,e){var r=e(1),o=e(14),i=e(18),u=e(26),f=e(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||f(n,t,{value:u.f(t)})}},function(t,n,e){n.f=e(7)},function(t,n,e){var r=e(1),o=e(14),i=e(46),u=e(5),f="prototype",c=function(t,n,e){var a,s,l,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,h=t&c.B,b=t&c.W,x=d?o:o[n]||(o[n]={}),m=x[f],g=d?r:v?r[n]:(r[n]||{})[f];d&&(e=n);for(a in e)s=!p&&g&&void 0!==g[a],s&&a in x||(l=s?g[a]:e[a],x[a]=d&&"function"!=typeof g[a]?e[a]:h&&s?i(l,r):b&&g[a]==l?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n[f]=t[f],n}(l):y&&"function"==typeof l?i(Function.call,l):l,y&&((x.virtual||(x.virtual={}))[a]=l,t&c.R&&m&&!m[a]&&u(m,a,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(11),o=e(1).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){t.exports=!e(4)&&!e(8)(function(){return 7!=Object.defineProperty(e(29)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){"use strict";var r=e(18),o=e(27),i=e(36),u=e(5),f=e(2),c=e(17),a=e(51),s=e(20),l=e(58),p=e(7)("iterator"),d=!([].keys&&"next"in[].keys()),v="@@iterator",y="keys",h="values",b=function(){return this};t.exports=function(t,n,e,x,m,g,w){a(e,n,x);var O,S,_,j=function(t){if(!d&&t in A)return A[t];switch(t){case y:return function(){return new e(this,t)};case h:return function(){return new e(this,t)}}return function(){return new e(this,t)}},P=n+" Iterator",E=m==h,M=!1,A=t.prototype,T=A[p]||A[v]||m&&A[m],L=T||j(m),N=m?E?j("entries"):L:void 0,C="Array"==n?A.entries||T:T;if(C&&(_=l(C.call(new t)),_!==Object.prototype&&(s(_,P,!0),r||f(_,p)||u(_,p,b))),E&&T&&T.name!==h&&(M=!0,L=function(){return T.call(this)}),r&&!w||!d&&!M&&A[p]||u(A,p,L),c[n]=L,c[P]=b,m)if(O={values:E?L:j(h),keys:g?L:j(y),entries:N},w)for(S in O)S in A||i(A,S,O[S]);else o(o.P+o.F*(d||M),n,O);return O}},function(t,n,e){var r=e(10),o=e(55),i=e(16),u=e(21)("IE_PROTO"),f=function(){},c="prototype",a=function(){var t,n=e(29)("iframe"),r=i.length,o="<",u=">";for(n.style.display="none",e(48).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),a=t.F;r--;)delete a[c][i[r]];return a()};t.exports=Object.create||function(t,n){var e;return null!==t?(f[c]=r(t),e=new f,f[c]=null,e[u]=t):e=a(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(35),o=e(16).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,e){var r=e(2),o=e(3),i=e(45)(!1),u=e(21)("IE_PROTO");t.exports=function(t,n){var e,f=o(t),c=0,a=[];for(e in f)e!=u&&r(f,e)&&a.push(e);for(;n.length>c;)r(f,e=n[c++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){t.exports=e(5)},function(t,n,e){var r=e(15);t.exports=function(t){return Object(r(t))}},function(t,n,e){t.exports={default:e(41),__esModule:!0}},function(t,n,e){t.exports={default:e(42),__esModule:!0}},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(39),i=r(o),u=e(38),f=r(u),c="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};n.default="function"==typeof f.default&&"symbol"===c(i.default)?function(t){return"undefined"==typeof t?"undefined":c(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":c(t)}},function(t,n,e){e(65),e(63),e(66),e(67),t.exports=e(14).Symbol},function(t,n,e){e(64),e(68),t.exports=e(26).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,e){var r=e(3),o=e(61),i=e(60);t.exports=function(t){return function(n,e,u){var f,c=r(n),a=o(c.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if(f=c[s++],f!=f)return!0}else for(;a>s;s++)if((t||s in c)&&c[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(43);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,e){var r=e(9),o=e(34),i=e(19);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,f=e(t),c=i.f,a=0;f.length>a;)c.call(t,u=f[a++])&&n.push(u);return n}},function(t,n,e){t.exports=e(1).document&&document.documentElement},function(t,n,e){var r=e(28);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n,e){var r=e(28);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){"use strict";var r=e(32),o=e(12),i=e(20),u={};e(5)(u,e(7)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){var r=e(9),o=e(3);t.exports=function(t,n){for(var e,i=o(t),u=r(i),f=u.length,c=0;f>c;)if(i[e=u[c++]]===n)return e}},function(t,n,e){var r=e(13)("meta"),o=e(11),i=e(2),u=e(6).f,f=0,c=Object.isExtensible||function(){return!0},a=!e(8)(function(){return c(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++f,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&s(t),t},v=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(6),o=e(10),i=e(9);t.exports=e(4)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),f=u.length,c=0;f>c;)r.f(t,e=u[c++],n[e]);return t}},function(t,n,e){var r=e(19),o=e(12),i=e(3),u=e(24),f=e(2),c=e(30),a=Object.getOwnPropertyDescriptor;n.f=e(4)?a:function(t,n){if(t=i(t),n=u(n,!0),c)try{return a(t,n)}catch(t){}if(f(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n,e){var r=e(3),o=e(33).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(r(t))}},function(t,n,e){var r=e(2),o=e(37),i=e(21)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(23),o=e(15);t.exports=function(t){return function(n,e){var i,u,f=String(o(n)),c=r(e),a=f.length;return c<0||c>=a?t?"":void 0:(i=f.charCodeAt(c),i<55296||i>56319||c+1===a||(u=f.charCodeAt(c+1))<56320||u>57343?t?f.charAt(c):i:t?f.slice(c,c+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,n,e){var r=e(23),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(23),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){"use strict";var r=e(44),o=e(52),i=e(17),u=e(3);t.exports=e(31)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){},function(t,n,e){"use strict";var r=e(59)(!0);e(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){"use strict";var r=e(1),o=e(2),i=e(4),u=e(27),f=e(36),c=e(54).KEY,a=e(8),s=e(22),l=e(20),p=e(13),d=e(7),v=e(26),y=e(25),h=e(53),b=e(47),x=e(50),m=e(10),g=e(3),w=e(24),O=e(12),S=e(32),_=e(57),j=e(56),P=e(6),E=e(9),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k="prototype",F=d("_hidden"),q=d("toPrimitive"),I={}.propertyIsEnumerable,B=s("symbol-registry"),D=s("symbols"),W=s("op-symbols"),H=Object[k],K="function"==typeof L,R=r.QObject,J=!R||!R[k]||!R[k].findChild,U=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(H,n);r&&delete H[n],A(t,n,e),r&&t!==H&&A(H,n,r)}:A,G=function(t){var n=D[t]=S(L[k]);return n._k=t,n},$=K&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},z=function(t,n,e){return t===H&&z(W,n,e),m(t),n=w(n,!0),m(e),o(D,n)?(e.enumerable?(o(t,F)&&t[F][n]&&(t[F][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,F)||A(t,F,O(1,{})),t[F][n]=!0),U(t,n,e)):A(t,n,e)},Y=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)z(t,e=r[o++],n[e]);return t},Q=function(t,n){return void 0===n?S(t):Y(S(t),n)},X=function(t){var n=I.call(this,t=w(t,!0));return!(this===H&&o(D,t)&&!o(W,t))&&(!(n||!o(this,t)||!o(D,t)||o(this,F)&&this[F][t])||n)},V=function(t,n){if(t=g(t),n=w(n,!0),t!==H||!o(D,n)||o(W,n)){var e=M(t,n);return!e||!o(D,n)||o(t,F)&&t[F][n]||(e.enumerable=!0),e}},Z=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(D,n=e[i++])||n==F||n==c||r.push(n);return r},tt=function(t){for(var n,e=t===H,r=T(e?W:g(t)),i=[],u=0;r.length>u;)!o(D,n=r[u++])||e&&!o(H,n)||i.push(D[n]);return i};K||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===H&&n.call(W,e),o(this,F)&&o(this[F],t)&&(this[F][t]=!1),U(this,t,O(1,e))};return i&&J&&U(H,t,{configurable:!0,set:n}),G(t)},f(L[k],"toString",function(){return this._k}),j.f=V,P.f=z,e(33).f=_.f=Z,e(19).f=X,e(34).f=tt,i&&!e(18)&&f(H,"propertyIsEnumerable",X,!0),v.f=function(t){return G(d(t))}),u(u.G+u.W+u.F*!K,{Symbol:L});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;nt.length>et;)d(nt[et++]);for(var nt=E(d.store),et=0;nt.length>et;)y(nt[et++]);u(u.S+u.F*!K,"Symbol",{for:function(t){return o(B,t+="")?B[t]:B[t]=L(t)},keyFor:function(t){if($(t))return h(B,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){J=!0},useSimple:function(){J=!1}}),u(u.S+u.F*!K,"Object",{create:Q,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:V,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),N&&u(u.S+u.F*(!K||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!$(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!$(n))return n}),r[1]=n,C.apply(N,r)}}}),L[k][q]||e(5)(L[k],q,L[k].valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){e(25)("asyncIterator")},function(t,n,e){e(25)("observable")},function(t,n,e){e(62);for(var r=e(1),o=e(5),i=e(17),u=e(7)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],c=0;c<5;c++){var a=f[c],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=e(40),i=r(o),u=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):o[t]||t}function n(t){return l[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,r=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},f=/\u00a0/g,c=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var p in o)l[o[p]]=p;return o["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(r,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(c,"\n").replace(e,t).replace(f," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=u.encodeObject(t[n]);else if("object"==("undefined"==typeof t?"undefined":(0,i.default)(t)))for(var r in t)t[r]=u.encodeObject(t[r]);else if("string"==typeof t)return u.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=u},function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},,,function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){var n=document.querySelectorAll(".article-entry a:not(.article-more-a)");n.forEach(function(t){t.setAttribute("target","_blank")})}var e=document.querySelector("#js-aboutme");e&&0!==e.length&&(e.innerHTML=e.innerText)}t.exports={init:e}},,,,,,,,,function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e}])</script><script src="/./main.2d7529.js"></script><script>!function(){var e=function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)};e("/slider.885efe.js")}()</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">CCF</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Hibernate</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">iOS MAC Object-C</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Oracle</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Spring</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">CS231n</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Struts2</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">English</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">数学</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">FTP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">研究生之路</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Gradle</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法 | 数学</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">计算机网络</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://www.hlju.edu.cn/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>黑龙江大学</a>
            </li>
          
            <li class="search-li">
              <a href="https:/www.google.com//" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>Google</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.baidu.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>百度</a>
            </li>
          
            <li class="search-li">
              <a href="https://mryxj.github.io/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>大牛叶小驹</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">在读软件工程大三蒻🐔一只。</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>