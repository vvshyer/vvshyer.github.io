<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://sunhuayan.tech">
  <title>MineMine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Stay Hungry. Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="MineMine">
<meta property="og:url" content="https://sunhuayan.tech/index.html">
<meta property="og:site_name" content="MineMine">
<meta property="og:description" content="Stay Hungry. Stay Foolish.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MineMine">
<meta name="twitter:description" content="Stay Hungry. Stay Foolish.">
  
    <link rel="alternative" href="/atom.xml" title="MineMine" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.2d7529.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/assets/photo.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">SUN Huayan</a></h1>
		</hgroup>
		
		<p class="header-subtitle">Stay Hungry. Stay Foolish.</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">了解我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://www.github.com/vvshyer" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/5291886920" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/vvshyer" title="zhihu"><i class="icon-zhihu"></i></a>
		        
					<a class="mail" target="_blank" href="/sunhuayanchn@gmail.com" title="mail"><i class="icon-mail"></i></a>
		        
					<a class="twitter" target="_blank" href="https://twitter.com/huayan_sun" title="twitter"><i class="icon-twitter"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/assets/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">SUN Huayan</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>Stay Hungry. Stay Foolish.<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://www.github.com/vvshyer" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5291886920" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/vvshyer" title="zhihu"><i class="icon-zhihu"></i></a>
			        
						<a class="mail" target="_blank" href="/sunhuayanchn@gmail.com" title="mail"><i class="icon-mail"></i></a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/huayan_sun" title="twitter"><i class="icon-twitter"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-阅读《Learning CNN for Graphs》笔记" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/阅读《Learning CNN for Graphs》笔记/">阅读《Learning Convolutional Neural Networks for Graphs》笔记</a>
    </h1>
  

        
        <a href="/2018/09/25/阅读《Learning CNN for Graphs》笔记/" class="archive-article-date">
  	<time datetime="2018-09-25T11:51:40.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-09-25</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是ICML 2016上关于CNN在Graph上的应用。</p>
<p>CNN处理的数据是Euclidean Data。所谓的Euclidean Data指的是类似于grids, sequences…这样的数据，例如图像就可以看作是2D的grid数据，语音信号就可以看做是1D的grid数据。但是现实的处理问题当中还存在大量的Non-Euclidean Data，如社交网络(Social Network)数据、化学成分(Chemical Compound)结构数据、生物基因蛋白(Protein)数据以及知识图谱(Knowledge Graphs)数据等等，这类的数据属于图结构数据(Graph-structured Data)。CNN等神经网络结构并不能有效的处理这类数据，<strong>所以这篇paper要解决的问题就是如何使用CNN高效的处理图结构的数据。</strong></p>
<p>本文所提出的算法思想是将一个图结构的数据转化为CNN能够高效处理的结构。处理过程如下：</p>
<blockquote>
<ol>
<li>从图结构当中选出具有代表性的nodes序列</li>
<li>对于选出的每一个node求出一个卷积的领域(neighborhood field)</li>
</ol>
</blockquote>
<p>图1展示的是普通的CNN进行卷积的过程。一张4x4大小的图像，可以表示为具有4个nodes的graph，其中每一个node包括一个和卷积核一样大小的领域(neighborhood field)。由此得到对于这种图像的卷积实际上就是对这4个node组成的graph的领域的卷积。那么，对于一个一般性的graph数据，同样只需要选出其中的nodes，并且求解得到其相关的的固定大小(和卷积核一样大小)的领域便可以使用CNN卷积得到图的特征表示。</p>
<p><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.03.32.png" alt="图1" title="图1"></p>
<p>注意，图中(b)当中表示的是(a)当中的一个node的领域，这个感知野按照空间位置从左到右，从上到下的顺序映射为一个卷积核一样大小的vector，然后在进行卷积。</p>
<p>算法如下：</p>
<p><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.08.08.png" alt="图2" title="图2"></p>
<h3 id="1-图当中顶点的选择Node-Sequence-Selection"><a href="#1-图当中顶点的选择Node-Sequence-Selection" class="headerlink" title="1. 图当中顶点的选择Node Sequence Selection"></a>1. 图当中顶点的选择Node Sequence Selection</h3><p>对于输入的graph，需要确定一个宽度w，即选择的nodes的个数，也就是感知野的个数。如何进行Nodes的选择？paper中说是根据graph当中的node的排序label进行选择，主要采取的方法是:centraliy，即中心化方法。个人的理解为越处于中心位置的点越重要。这里的中心位置不是空间上的概念，应该是度量一个点的关系中的重要性的概念。如图3当中的两个图实际上表示的是同一个图，对其中红色标明的两个不同的nodes我们来比较他们的中心位置关系。比较的过程当中，我们计算该node和其余所有nodes的距离关系。我们假设相邻的两个node之间的距离都是1。<br><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.27.41.png" alt="图3 图当中的两个nodes" title="图3 图当中的两个nodes"><br>那么对于图3当中的左图的红色node，和它直接相连的node有4个，因此距离+4；再稍微远一点的也就是和它相邻点相邻的有3个，距离+6;依次再相邻的有3个+9；最后还剩下一个最远的+4；因此我们知道该node的总的距离为23。同理我们得到右边的node的距离为3+8+6+8=25。那么很明显node的选择的时候左边的node会被先选出来。当然，这只是一种node的排序和选择的方法，其存在的问题也是非常明显的。Paper并没有在这次的工作当中做详细的说明。</p>
<h3 id="2-找到node的领域-Neighborhood-Assembly"><a href="#2-找到node的领域-Neighborhood-Assembly" class="headerlink" title="2. 找到node的领域 Neighborhood Assembly"></a>2. 找到node的领域 Neighborhood Assembly</h3><p>接下来对选出来的每一个node确定一个感知野receptive filed以便进行卷积操作。但是，在这之前，首先找到每一个node的邻域区域（neighborhood filed），然后再从当中确定感知野当中的nodes。假设感知野的大小为k，那么对于每一个Node很明显都会存在两种情况：邻域nodes不够k个，或者是邻域点多了。<br>如图2中选出的是6个nodes，对于每一个node，首先找到其直接相邻的nodes（被称作是1-neighborhood），如果还不够再增加间接相邻的nodes。那么对于1-neighborhood就已经足够的情况，先全部放在候选的区域当中，在下一步当中通过规范化来做最终的选择。</p>
<h3 id="3-图规范化过程-Graph-Normalization"><a href="#3-图规范化过程-Graph-Normalization" class="headerlink" title="3. 图规范化过程 Graph Normalization"></a>3. 图规范化过程 Graph Normalization</h3><p>假设上一步Neighborhood Assemble过程当中一个node得到一个领域nodes总共有N个。那么N的个数可能和k不相等的。因此，normalize的过程就是要对他们打上排序标签进行选择，并且按照该顺序映射到向量当中。<br><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.33.22.png" alt="图4 求解node的receptive field" title="图4 求解node的receptive field"><br>如果这个node的邻域nodes的个数不足的话，直接全部选上，不够补上哑节点（dummy nodes），但还是需要排序；如果数目N超过则需要按着排序截断后面的节点。如图4所示表示从选node到求解出receptive filed的整个过程。Normalize进行排序之后就能够映射到一个vector当中了。因此，这一步最重要的是对nodes进行排序。<br><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.35.36.png" alt="图5" title="图5"><br>如图5所示，表示对任意一个node求解它的receptive filed的过程。这里的卷积核的大小为4，因此最终要选出来4个node，包括这个node本身。因此，需要给这些nodes打上标签（labeling）。当然存在很多的方式，那么怎样的打标签方式才是最好的呢？如图4所示，其实从这7个nodes当中选出4个nodes会形成一个含有4个nodes的graph的集合。paper的作者认为：在某种标签下，随机从集合当中选择两个图，计算他们在vector空间的图的距离和在graph空间图的距离的差异的期望，如果这个期望越小那么就表明这个标签越好！具体的表示如下：<br><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.37.47.png" alt="图6" title="图6"><br>得到最好的标签之后，就能够按着顺序将node映射到一个有序的vector当中，也就得到了这个node的receptive field，如图4最右边所示。</p>
<h3 id="4-卷积网络结构-Convolutional-Architecture"><a href="#4-卷积网络结构-Convolutional-Architecture" class="headerlink" title="4. 卷积网络结构 Convolutional Architecture"></a>4. 卷积网络结构 Convolutional Architecture</h3><p>文章使用的是一个2层的卷积神经网络，将输入转化为一个向量vector之后便可以用来进行卷积操作了。具体的操作如图7，8，9所示<br><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.44.11.png" alt="图7" title="图7"></p>
<p><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.45.31.png" alt="图8" title="图8"></p>
<p><img src="https://raw.githubusercontent.com/vvshyer/images/master/2018-09-27%2019.42.08.png" alt="图9" title="图9"><br>首先最底层的灰色块为网络的输入，每一个块表示的是一个node的感知野(receptive field)区域，也是前面求解得到的4个nodes。其中an表示的是每一个node的数据中的一个维度(node如果是彩色图像那就是3维；如果是文字，可能是一个词向量……这里表明数据的维度为n)。粉色的表示卷积核，核的大小为4，但是宽度要和数据维度一样。因此，和每一个node卷季后得到一个值。卷积的步长(stride)为4，表明每一次卷积1个node，stride=4下一次刚好跨到下一个node。(备注：图1当中,(a)当中的stride=1，但是转化为（b）当中的结构后stride=9)。卷积核的个数为M，表明卷积后得到的特征图的通道数为M，因此最终得到的结果为V1……VM，也就是图的特征表示。有了它便可以进行分类或者是回归的任务了。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">Deep Learning</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/09/25/阅读《Learning CNN for Graphs》笔记/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-阅读《人月神话》笔记" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/15/阅读《人月神话》笔记/">阅读《人月神话》笔记</a>
    </h1>
  

        
        <a href="/2018/09/15/阅读《人月神话》笔记/" class="archive-article-date">
  	<time datetime="2018-09-15T11:51:40.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-09-15</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>软件工程领域的名作《人月神话》从1975年发布至今已经40余年，最近有幸在邵栋老师的推荐下阅读了这本软件工程领域的“神作”。虽然本科已经修过软件工程相关的课，对于项目管理有了基本的理解，在读这本“神作”的时候依然收获颇丰。着重记录原作第十六章《没有银弹》和20周年版新增的第十七章《再论《没有银弹》》。</p>
<p><strong>银弹</strong>，就是能够一击就消灭人狼的武器。如果把软件项目看作是人狼，那么《没有银弹》一文论述了在当年的那个环境下，没有银弹的踪迹。没有任何技术或管理上的进展，能够独立地许诺在生产率、可靠性或简洁上取得数量级的提高。本文试图通过分析软件问题的本质和候选银弹的特征去探索其原因。</p>
<p>由于软件的特性导致其不能像计算机硬件工业中的电子元件一样快速增长，并且因为计算机硬件发展太快，反而显得软件的发展很慢。所有<strong>软件活动</strong>包括：</p>
<ul>
<li><p>根本任务，即打造构成抽象软件实体的复杂概念结构；</p>
</li>
<li><p>次要任务，即使用编程语言表达这些抽象实体，在空间和时间限制下将它们映射成机器语言。</p>
</li>
</ul>
<p>对于更好地构造异常复杂的抽象概念结构，有以下几点建议： </p>
<ol>
<li><p>仔细地进行市场调研，避免开发已上市的产品；</p>
</li>
<li><p>在获取和制定软件需求时，将快速原型开发作为迭代计划的一部分；</p>
</li>
<li><p>有机地更新软件，随着系统的运行、使用和测试，逐渐添加越来越多的功能；</p>
</li>
<li><p>不断挑选和培养杰出新生代的概念设计人员。</p>
</li>
</ol>
<p>软件开发中困难的部分是规格说明、设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。</p>
<p>现代软件系统中无法规避的内在特性：</p>
<p><strong>复杂度</strong><br>规模上，软件实体可能比任何由人类创造的其他实体更复杂，因为没有任何两个软件部分是相同的（至少在语句的级别上）。而由软件的复杂度造成了很多经典的软件产品开发问题：团队成员之间的沟通非常困难，导致了产品瑕疵、成本超支和进度延迟；列举所有可能的状态变得十分困难，影响了产品的可靠性；函数调用变得困难，导致程序难以应用；结构复杂，程序难以在不产生副作用的情况下用新函数扩充；还造成很多安全机制状态上的不可见性。</p>
<p><strong>一致性</strong><br>软件开发必须遵循许多认为惯例和系统，并随着接口的不同而改变，随时间的推移而变化，而且这些变化不是必需的，仅仅由于它们是不同的人设计的结果。</p>
<p><strong>可变性</strong><br>软件实体经常会遭受到持续的变更压力。部分原因是因为系统中的软件包含了很多功能，而功能是最容易感受变更压力的部分。另外的原因是因为软件可以容易地进行修改。</p>
<p><strong>不可见性</strong><br>软件是不可见的和无法可视化的。软件的客观存在不具有空间的形体特征。因此，没有已有的几何表达方式，从而剥夺了一些具有强大功能的概念工具的构造创意。这种缺憾不仅限制了个人的设计过程，也严重地阻碍了思路相互之间的交流。</p>
<p>针对概念上根本问题的颇有前途的方法： </p>
<p><strong>需求精炼</strong><br>开发软件系统的过程中，最困难的部分是确切地决定搭建什么样的系统。详细的需求包括了所有的人机界面，与机器和其他软件系统的接口。因此，软件开发人员为客户所承担的最重要的职能是不断重复地抽取和细化产品的需求。所以，在计划任何软件活动是，要让客户和设计人员之间进行多次广泛的交流沟通，并将其作为系统定义的一部分，这是非常必要的。</p>
<p><strong>快速原型</strong><br>软件系统的快速原型对重要的系统界面进行模拟，并演示待开发系统的主要功能。同时，原型不必受到相同硬件速度、规模或者成本的限制。原型通常展示了应用程序的功能主线，但不处理任何如无效输入、退出清除等异常情况。原型的目的是明确实际的概念结构，使客户可以测试一致性和可用性。</p>
<p><strong>增量开发</strong><br>软件系统应该以增量的方式开发。即，首先系统应该能够运行，即使没完成任何有用功能，只能正确调用一系列伪子系统。接着，系统一点一点被充实，子系统轮流被开发。增量化开发使逆向跟踪很方便，并非常容易进行原型开发，每一项新增功能，以及针对更加复杂数据或环境的新模块，从已经规划的系统中有机地增长。这种开发模式对士气的推动也是令人震惊的。即便是非常简单的系统出现时，即便是一个简单的长方形，开发人员的热情和工作动力也会成倍地增长。</p>
<p>软件开发是一件棘手的事情，前方并不会有魔术般的解决方案。现在是从业者研究和分析革命性进展的时刻，而不是等待或希望它的出现。</p>
<p>软件领域中的一些人发现这是令人泄气的，这些人依然认为突破尽在眼前。但是我们中一些固执的现实主义者们把它看做是清新的空气。我们终于可以将焦点集中在更加可行的事情上而不是空中楼阁。现在，我们有可能在软件生产率上去的逐步的进展，而不是等待不大可能到来的突破。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">软件工程</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/09/15/阅读《人月神话》笔记/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-学习词根" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/学习词根/">学习词根</a>
    </h1>
  

        
        <a href="/2018/04/01/学习词根/" class="archive-article-date">
  	<time datetime="2018-04-01T10:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-04-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通过Merrian-Webster’s-Vocabulary-Builder学习词根"><a href="#通过Merrian-Webster’s-Vocabulary-Builder学习词根" class="headerlink" title="通过Merrian-Webster’s Vocabulary Builder学习词根"></a>通过Merrian-Webster’s Vocabulary Builder学习词根</h1><p>韦氏三宝之一的绿皮书，被广大英语学习者亲切称呼为“小绿”。近日偶然在书柜中发现了这本被我买来就弃置不理长达四年的宝书，决定好好学习一番。</p>
<p>本书一共<strong>30个单元</strong>，为了记得牢固，打算<strong>一周一个单元</strong>，<strong>一天两个词根十六个单词</strong>。简单的部分直接翻译了，为了保证原汁原味的理解，哲理性的语句和小故事都直接原文展示。</p>
<p>移步简书查看所有学习笔记《韦氏小绿》 <a href="https://www.jianshu.com/c/4b8696ea29ac?utm_campaign=maleskine&amp;utm_content=collection&amp;utm_medium=reader_share&amp;utm_source=twitter" target="_blank" rel="noopener">https://www.jianshu.com/c/4b8696ea29ac?utm_campaign=maleskine&amp;utm_content=collection&amp;utm_medium=reader_share&amp;utm_source=twitter</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">English</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/04/01/学习词根/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Python Numpy 教程" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/10/Python Numpy 教程/">Python Numpy 教程</a>
    </h1>
  

        
        <a href="/2018/02/10/Python Numpy 教程/" class="archive-article-date">
  	<time datetime="2018-02-10T12:00:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-02-10</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python-Numpy-教程"><a href="#Python-Numpy-教程" class="headerlink" title="Python Numpy 教程"></a>Python Numpy 教程</h1><p>这篇教程由<a href="https://cs.stanford.edu/people/jcjohns/" target="_blank" rel="noopener">Justin Johnson</a>创作。</p>
<p>我们将使用Python编程语言来完成本课程的所有作业。Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。<br>我们期望你们中大多数人对于Python语言和Numpy库比较熟悉，而对于没有Python经验的同学，这篇教程可以帮助你们快速了解Python编程环境和如何使用Python作为科学计算工具。</p>
<p>一部分同学对于Matlab有一定经验。对于这部分同学，我们推荐阅读 <a href="http://scipy.github.io/old-wiki/pages/NumPy_for_Matlab_Users" target="_blank" rel="noopener">numpy for Matlab users</a>页面。</p>
<p>你们还可以查看本教程的<a href="https://github.com/kuleshov/cs228-material/blob/master/tutorials/python/cs228-python-tutorial.ipynb" target="_blank" rel="noopener">IPython notebook</a>版。该教程是由<a href="http://web.stanford.edu/~kuleshov/" target="_blank" rel="noopener">Volodymyr Kuleshov</a>和<a href="https://symsys.stanford.edu/viewing/symsysaffiliate/21335" target="_blank" rel="noopener">Isaac Caswell</a>为课程<a href="https://cs.stanford.edu/~ermon/cs228/index.html" target="_blank" rel="noopener">CS 228</a>创建的。</p>
<p>内容列表：</p>
<ul>
<li>Python<ul>
<li>基本数据类型</li>
<li>容器<ul>
<li>列表</li>
<li>字典</li>
<li>集合</li>
<li>元组</li>
</ul>
</li>
<li>函数</li>
<li>类</li>
</ul>
</li>
<li>Numpy<ul>
<li>数组</li>
<li>访问数组</li>
<li>数据类型</li>
<li>数组计算</li>
<li>广播</li>
</ul>
</li>
<li>SciPy<ul>
<li>图像操作</li>
<li>MATLAB文件</li>
<li>点之间的距离</li>
</ul>
</li>
<li>Matplotlib<ul>
<li>绘制图形</li>
<li>绘制多个图形</li>
<li>图像</li>
</ul>
</li>
</ul>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def quicksort(arr):</span><br><span class="line">    if len(arr) &lt;= 1:</span><br><span class="line">        return arr</span><br><span class="line">    pivot = arr[len(arr) // 2]</span><br><span class="line">    left = [x for x in arr if x &lt; pivot]</span><br><span class="line">    middle = [x for x in arr if x == pivot]</span><br><span class="line">    right = [x for x in arr if x &gt; pivot]</span><br><span class="line">    return quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line">print(quicksort([3,6,8,10,1,2,1]))</span><br><span class="line"># Prints &quot;[1, 1, 2, 3, 6, 8, 10]&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h2><p>Python有两个支持的版本，分别是2.7和3.5。这有点让人迷惑，3.0向语言中引入了很多不向后兼容的变化，2.7下的代码有时候在3.5下是行不通的。在这个课程中，我们使用的是3.5版本。</p>
<p>你可以使用<code>python--version</code>命令查看Python版本。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>和大多数编程语言一样，Python拥有一系列的基本数据类型，比如整型(integers)、浮点型(floats)、布尔型(booleans)和字符串(strings)等。这些类型的使用方式和在其他语言中的使用方式是类似的。</p>
<p>数字：整型和浮点型的使用与其他语言类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = 3</span><br><span class="line">print(type(x)) # Prints &quot;&lt;class &apos;int&apos;&gt;&quot;</span><br><span class="line">print(x)       # Prints &quot;3&quot;</span><br><span class="line">print(x + 1)   # Addition; prints &quot;4&quot;</span><br><span class="line">print(x - 1)   # Subtraction; prints &quot;2&quot;</span><br><span class="line">print(x * 2)   # Multiplication; prints &quot;6&quot;</span><br><span class="line">print(x ** 2)  # Exponentiation; prints &quot;9&quot;</span><br><span class="line">x += 1</span><br><span class="line">print(x)  # Prints &quot;4&quot;</span><br><span class="line">x *= 2</span><br><span class="line">print(x)  # Prints &quot;8&quot;</span><br><span class="line">y = 2.5</span><br><span class="line">print(type(y)) # Prints &quot;&lt;class &apos;float&apos;&gt;&quot;</span><br><span class="line">print(y, y + 1, y * 2, y ** 2) # Prints &quot;2.5 3.5 5.0 6.25&quot;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Python中没有 <code>x++</code> 和 <code>x--</code> 的操作符。</p>
<p>Python也有内置的长整型和复杂数字类型，具体细节可以查看<a href="https://docs.python.org/3.5/library/stdtypes.html#numeric-types-int-float-complex" target="_blank" rel="noopener">文档</a>。</p>
<p>布尔型：Python实现了所有的布尔逻辑，但用的是英语，而不是我们习惯的操作符（比如<code>&amp;&amp;</code>和<code>||</code>等）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = True</span><br><span class="line">f = False</span><br><span class="line">print(type(t)) # Prints &quot;&lt;class &apos;bool&apos;&gt;&quot;</span><br><span class="line">print(t and f) # Logical AND; prints &quot;False&quot;</span><br><span class="line">print(t or f)  # Logical OR; prints &quot;True&quot;</span><br><span class="line">print(not t)   # Logical NOT; prints &quot;False&quot;</span><br><span class="line">print(t != f)  # Logical XOR; prints &quot;True&quot;</span><br></pre></td></tr></table></figure>
<p>字符串：Python对字符串的支持非常棒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello = &apos;hello&apos;    # String literals can use single quotes</span><br><span class="line">world = &quot;world&quot;    # or double quotes; it does not matter.</span><br><span class="line">print(hello)       # Prints &quot;hello&quot;</span><br><span class="line">print(len(hello))  # String length; prints &quot;5&quot;</span><br><span class="line">hw = hello + &apos; &apos; + world  # String concatenation</span><br><span class="line">print(hw)  # prints &quot;hello world&quot;</span><br><span class="line">hw12 = &apos;%s %s %d&apos; % (hello, world, 12)  # sprintf style string formatting</span><br><span class="line">print(hw12)  # prints &quot;hello world 12&quot;</span><br></pre></td></tr></table></figure>
<p>字符串对象有一系列有用的方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;hello&quot;</span><br><span class="line">print(s.capitalize())  # Capitalize a string; prints &quot;Hello&quot;</span><br><span class="line">print(s.upper())       # Convert a string to uppercase; prints &quot;HELLO&quot;</span><br><span class="line">print(s.rjust(7))      # Right-justify a string, padding with spaces; prints &quot;  hello&quot;</span><br><span class="line">print(s.center(7))     # Center a string, padding with spaces; prints &quot; hello &quot;</span><br><span class="line">print(s.replace(&apos;l&apos;, &apos;(ell)&apos;))  # Replace all instances of one substring with another;</span><br><span class="line">                                # prints &quot;he(ell)(ell)o&quot;</span><br><span class="line">print(&apos;  world &apos;.strip())  # Strip leading and trailing whitespace; prints &quot;world&quot;</span><br></pre></td></tr></table></figure>
<p>如果想详细查看字符串方法，请看<a href="https://docs.python.org/3.5/library/stdtypes.html#string-methods" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="容器Containers"><a href="#容器Containers" class="headerlink" title="容器Containers"></a>容器Containers</h2><p>译者注：有知友建议container翻译为复合数据类型，供读者参考。</p>
<p>Python有以下几种容器类型：列表（lists）、字典（dictionaries）、集合（sets）和元组（tuples）。</p>
<h3 id="列表Lists"><a href="#列表Lists" class="headerlink" title="列表Lists"></a>列表Lists</h3><p>列表就是Python中的数组，但是列表长度可变，且能包含不同类型元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xs = [3, 1, 2]    # Create a list</span><br><span class="line">print(xs, xs[2])  # Prints &quot;[3, 1, 2] 2&quot;</span><br><span class="line">print(xs[-1])     # Negative indices count from the end of the list; prints &quot;2&quot;</span><br><span class="line">xs[2] = &apos;foo&apos;     # Lists can contain elements of different types</span><br><span class="line">print(xs)         # Prints &quot;[3, 1, &apos;foo&apos;]&quot;</span><br><span class="line">xs.append(&apos;bar&apos;)  # Add a new element to the end of the list</span><br><span class="line">print(xs)         # Prints &quot;[3, 1, &apos;foo&apos;, &apos;bar&apos;]&quot;</span><br><span class="line">x = xs.pop()      # Remove and return the last element of the list</span><br><span class="line">print(x, xs)      # Prints &quot;bar [3, 1, &apos;foo&apos;]&quot;</span><br></pre></td></tr></table></figure>
<p>列表的细节，同样可以查阅<a href="https://docs.python.org/3.5/tutorial/datastructures.html#more-on-lists" target="_blank" rel="noopener">文档</a>。</p>
<p>切片Slicing：为了一次性地获取列表中的元素，Python提供了一种简洁的语法，这就是切片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums = list(range(5))     # range is a built-in function that creates a list of integers</span><br><span class="line">print(nums)               # Prints &quot;[0, 1, 2, 3, 4]&quot;</span><br><span class="line">print(nums[2:4])          # Get a slice from index 2 to 4 (exclusive); prints &quot;[2, 3]&quot;</span><br><span class="line">print(nums[2:])           # Get a slice from index 2 to the end; prints &quot;[2, 3, 4]&quot;</span><br><span class="line">print(nums[:2])           # Get a slice from the start to index 2 (exclusive); prints &quot;[0, 1]&quot;</span><br><span class="line">print(nums[:])            # Get a slice of the whole list; prints &quot;[0, 1, 2, 3, 4]&quot;</span><br><span class="line">print(nums[:-1])          # Slice indices can be negative; prints &quot;[0, 1, 2, 3]&quot;</span><br><span class="line">nums[2:4] = [8, 9]        # Assign a new sublist to a slice</span><br><span class="line">print(nums)               # Prints &quot;[0, 1, 8, 9, 4]&quot;</span><br></pre></td></tr></table></figure></p>
<p>在Numpy数组的内容中，我们会再次看到切片语法。</p>
<p>循环Loops：我们可以这样遍历列表中的每一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [&apos;cat&apos;, &apos;dog&apos;, &apos;monkey&apos;]</span><br><span class="line">for animal in animals:</span><br><span class="line">    print(animal)</span><br><span class="line"># Prints &quot;cat&quot;, &quot;dog&quot;, &quot;monkey&quot;, each on its own line.</span><br></pre></td></tr></table></figure>
<p>如果想要在循环体内访问每个元素的指针，可以使用内置的<code>enumerate</code>函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [&apos;cat&apos;, &apos;dog&apos;, &apos;monkey&apos;]</span><br><span class="line">for idx, animal in enumerate(animals):</span><br><span class="line">    print(&apos;#%d: %s&apos; % (idx + 1, animal))</span><br><span class="line"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span><br></pre></td></tr></table></figure></p>
<p>列表推导 List comprehensions：在编程的时候，我们常常想要将一种数据类型转换为另一种。下面是一个简单例子，将列表中的每个元素变成它的平方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">squares = []</span><br><span class="line">for x in nums:</span><br><span class="line">    squares.append(x ** 2)</span><br><span class="line">print(squares)   # Prints [0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure></p>
<p>使用列表推导，你就可以让代码简化很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">squares = [x ** 2 for x in nums]</span><br><span class="line">print(squares)   # Prints [0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure></p>
<p>列表推导还可以包含条件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">even_squares = [x ** 2 for x in nums if x % 2 == 0]</span><br><span class="line">print(even_squares)  # Prints &quot;[0, 4, 16]&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="字典-Dictionaries"><a href="#字典-Dictionaries" class="headerlink" title="字典 Dictionaries"></a>字典 Dictionaries</h3><p>字典用来储存（键, 值）对，这和Java中的<code>Map</code>差不多。你可以这样使用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;cat&apos;: &apos;cute&apos;, &apos;dog&apos;: &apos;furry&apos;&#125;  # Create a new dictionary with some data</span><br><span class="line">print(d[&apos;cat&apos;])       # Get an entry from a dictionary; prints &quot;cute&quot;</span><br><span class="line">print(&apos;cat&apos; in d)     # Check if a dictionary has a given key; prints &quot;True&quot;</span><br><span class="line">d[&apos;fish&apos;] = &apos;wet&apos;     # Set an entry in a dictionary</span><br><span class="line">print(d[&apos;fish&apos;])      # Prints &quot;wet&quot;</span><br><span class="line"># print(d[&apos;monkey&apos;])  # KeyError: &apos;monkey&apos; not a key of d</span><br><span class="line">print(d.get(&apos;monkey&apos;, &apos;N/A&apos;))  # Get an element with a default; prints &quot;N/A&quot;</span><br><span class="line">print(d.get(&apos;fish&apos;, &apos;N/A&apos;))    # Get an element with a default; prints &quot;wet&quot;</span><br><span class="line">del d[&apos;fish&apos;]         # Remove an element from a dictionary</span><br><span class="line">print(d.get(&apos;fish&apos;, &apos;N/A&apos;)) # &quot;fish&quot; is no longer a key; prints &quot;N/A&quot;</span><br></pre></td></tr></table></figure></p>
<p>想要知道字典的其他特性，请查阅<a href="https://docs.python.org/3.5/library/stdtypes.html#dict" target="_blank" rel="noopener">文档</a>。</p>
<p>循环Loops：在字典中，用键来迭代更加容易。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;person&apos;: 2, &apos;cat&apos;: 4, &apos;spider&apos;: 8&#125;</span><br><span class="line">for animal in d:</span><br><span class="line">    legs = d[animal]</span><br><span class="line">    print(&apos;A %s has %d legs&apos; % (animal, legs))</span><br><span class="line"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果你想要访问键和对应的值，那就使用<code>items</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;person&apos;: 2, &apos;cat&apos;: 4, &apos;spider&apos;: 8&#125;</span><br><span class="line">for animal, legs in d.items():</span><br><span class="line">    print(&apos;A %s has %d legs&apos; % (animal, legs))</span><br><span class="line"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span><br></pre></td></tr></table></figure></p>
<p>字典推导 Dictionary comprehensions：和列表推导类似，但是允许你方便地构建字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [0, 1, 2, 3, 4]</span><br><span class="line">even_num_to_square = &#123;x: x ** 2 for x in nums if x % 2 == 0&#125;</span><br><span class="line">print(even_num_to_square)  # Prints &quot;&#123;0: 0, 2: 4, 4: 16&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="集合Sets"><a href="#集合Sets" class="headerlink" title="集合Sets"></a>集合Sets</h3><p>集合是独立不同个体的无序集合。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;&apos;cat&apos;, &apos;dog&apos;&#125;</span><br><span class="line">print(&apos;cat&apos; in animals)   # Check if an element is in a set; prints &quot;True&quot;</span><br><span class="line">print(&apos;fish&apos; in animals)  # prints &quot;False&quot;</span><br><span class="line">animals.add(&apos;fish&apos;)       # Add an element to a set</span><br><span class="line">print(&apos;fish&apos; in animals)  # Prints &quot;True&quot;</span><br><span class="line">print(len(animals))       # Number of elements in a set; prints &quot;3&quot;</span><br><span class="line">animals.add(&apos;cat&apos;)        # Adding an element that is already in the set does nothing</span><br><span class="line">print(len(animals))       # Prints &quot;3&quot;</span><br><span class="line">animals.remove(&apos;cat&apos;)     # Remove an element from a set</span><br><span class="line">print(len(animals))       # Prints &quot;2&quot;</span><br></pre></td></tr></table></figure></p>
<p>和前面一样，要知道更详细的，查看<a href="https://docs.python.org/3.5/library/stdtypes.html#set" target="_blank" rel="noopener">文档</a>。</p>
<p>循环Loops：在集合中循环的语法和在列表中一样，但是集合是无序的，所以你在访问集合的元素的时候，不能做关于顺序的假设。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;&apos;cat&apos;, &apos;dog&apos;, &apos;fish&apos;&#125;</span><br><span class="line">for idx, animal in enumerate(animals):</span><br><span class="line">    print(&apos;#%d: %s&apos; % (idx + 1, animal))</span><br><span class="line"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span><br></pre></td></tr></table></figure></p>
<p>集合推导Set comprehensions：和字典推导一样，可以很方便地构建集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line">nums = &#123;int(sqrt(x)) for x in range(30)&#125;</span><br><span class="line">print(nums)  # Prints &quot;&#123;0, 1, 2, 3, 4, 5&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="元组Tuples"><a href="#元组Tuples" class="headerlink" title="元组Tuples"></a>元组Tuples</h3><p>元组是一个值的有序列表（不可改变）。从很多方面来说，元组和列表都很相似。和列表最重要的不同在于，元组可以在字典中用作键，还可以作为集合的元素，而列表不行。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;(x, x + 1): x for x in range(10)&#125;  # Create a dictionary with tuple keys</span><br><span class="line">t = (5, 6)        # Create a tuple</span><br><span class="line">print(type(t))    # Prints &quot;&lt;class &apos;tuple&apos;&gt;&quot;</span><br><span class="line">print(d[t])       # Prints &quot;5&quot;</span><br><span class="line">print(d[(1, 2)])  # Prints &quot;1&quot;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://docs.python.org/3.5/tutorial/datastructures.html#tuples-and-sequences" target="_blank" rel="noopener">文档</a>有更多元组的信息。</p>
<h2 id="函数Functions"><a href="#函数Functions" class="headerlink" title="函数Functions"></a>函数Functions</h2><p>Python函数使用<code>def</code>来定义函数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sign(x):</span><br><span class="line">    if x &gt; 0:</span><br><span class="line">        return &apos;positive&apos;</span><br><span class="line">    elif x &lt; 0:</span><br><span class="line">        return &apos;negative&apos;</span><br><span class="line">    else:</span><br><span class="line">        return &apos;zero&apos;</span><br><span class="line"></span><br><span class="line">for x in [-1, 0, 1]:</span><br><span class="line">    print(sign(x))</span><br><span class="line"># Prints &quot;negative&quot;, &quot;zero&quot;, &quot;positive&quot;</span><br></pre></td></tr></table></figure></p>
<p>我们常常使用可选参数来定义函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def hello(name, loud=False):</span><br><span class="line">    if loud:</span><br><span class="line">        print(&apos;HELLO, %s!&apos; % name.upper())</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Hello, %s&apos; % name)</span><br><span class="line"></span><br><span class="line">hello(&apos;Bob&apos;) # Prints &quot;Hello, Bob&quot;</span><br><span class="line">hello(&apos;Fred&apos;, loud=True)  # Prints &quot;HELLO, FRED!&quot;</span><br></pre></td></tr></table></figure></p>
<p>函数还有很多内容，可以查看<a href="https://docs.python.org/3.5/tutorial/controlflow.html#defining-functions" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="类Classes"><a href="#类Classes" class="headerlink" title="类Classes"></a>类Classes</h2><p>Python对于类的定义是简单直接的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Greeter(object):</span><br><span class="line"></span><br><span class="line">    # Constructor</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name  # Create an instance variable</span><br><span class="line"></span><br><span class="line">    # Instance method</span><br><span class="line">    def greet(self, loud=False):</span><br><span class="line">        if loud:</span><br><span class="line">            print(&apos;HELLO, %s!&apos; % self.name.upper())</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;Hello, %s&apos; % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(&apos;Fred&apos;)  # Construct an instance of the Greeter class</span><br><span class="line">g.greet()            # Call an instance method; prints &quot;Hello, Fred&quot;</span><br><span class="line">g.greet(loud=True)   # Call an instance method; prints &quot;HELLO, FRED!&quot;</span><br></pre></td></tr></table></figure></p>
<p>更多类的信息请查阅<a href="https://docs.python.org/3.5/tutorial/classes.html" target="_blank" rel="noopener">文档</a>。</p>
<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p><a href="http://www.numpy.org/" target="_blank" rel="noopener">Numpy</a>是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具。如果你已经很熟悉MATLAB，你可以通过这个<a href="http://wiki.scipy.org/NumPy_for_Matlab_Users" target="_blank" rel="noopener">文档</a>开始使用Numpy。</p>
<h2 id="数组Arrays"><a href="#数组Arrays" class="headerlink" title="数组Arrays"></a>数组Arrays</h2><p>一个numpy数组是一个由不同数值组成的网格。网格中的数据都是同一种数据类型，可以通过非负整型数的元组来访问。维度的数量被称为数组的阶，数组的大小是一个由整型数构成的元组，可以描述数组不同维度上的大小。</p>
<p>我们可以从列表创建数组，然后利用方括号访问其中的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([1, 2, 3])   # Create a rank 1 array</span><br><span class="line">print(type(a))            # Prints &quot;&lt;class &apos;numpy.ndarray&apos;&gt;&quot;</span><br><span class="line">print(a.shape)            # Prints &quot;(3,)&quot;</span><br><span class="line">print(a[0], a[1], a[2])   # Prints &quot;1 2 3&quot;</span><br><span class="line">a[0] = 5                  # Change an element of the array</span><br><span class="line">print(a)                  # Prints &quot;[5, 2, 3]&quot;</span><br><span class="line"></span><br><span class="line">b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array</span><br><span class="line">print(b.shape)                     # Prints &quot;(2, 3)&quot;</span><br><span class="line">print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;</span><br></pre></td></tr></table></figure></p>
<p>Numpy还提供了很多其他创建数组的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.zeros((2,2))   # Create an array of all zeros</span><br><span class="line">print(a)              # Prints &quot;[[ 0.  0.]</span><br><span class="line">                      #          [ 0.  0.]]&quot;</span><br><span class="line"></span><br><span class="line">b = np.ones((1,2))    # Create an array of all ones</span><br><span class="line">print(b)              # Prints &quot;[[ 1.  1.]]&quot;</span><br><span class="line"></span><br><span class="line">c = np.full((2,2), 7)  # Create a constant array</span><br><span class="line">print(c)               # Prints &quot;[[ 7.  7.]</span><br><span class="line">                       #          [ 7.  7.]]&quot;</span><br><span class="line"></span><br><span class="line">d = np.eye(2)         # Create a 2x2 identity matrix</span><br><span class="line">print(d)              # Prints &quot;[[ 1.  0.]</span><br><span class="line">                      #          [ 0.  1.]]&quot;</span><br><span class="line"></span><br><span class="line">e = np.random.random((2,2))  # Create an array filled with random values</span><br><span class="line">print(e)                     # Might print &quot;[[ 0.91940167  0.08143941]</span><br><span class="line">                             #               [ 0.68744134  0.87236687]]&quot;</span><br></pre></td></tr></table></figure></p>
<p>其他数组相关方法，请查看<a href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>Numpy提供了多种访问数组的方法。</p>
<p>切片(Slicing)：和Python列表类似，numpy数组可以使用切片语法。因为数组可以是多维的，所以你必须为每个维度指定好切片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Use slicing to pull out the subarray consisting of the first 2 rows</span><br><span class="line"># and columns 1 and 2; b is the following array of shape (2, 2):</span><br><span class="line"># [[2 3]</span><br><span class="line">#  [6 7]]</span><br><span class="line">b = a[:2, 1:3]</span><br><span class="line"></span><br><span class="line"># A slice of an array is a view into the same data, so modifying it</span><br><span class="line"># will modify the original array.</span><br><span class="line">print(a[0, 1])   # Prints &quot;2&quot;</span><br><span class="line">b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]</span><br><span class="line">print(a[0, 1])   # Prints &quot;77&quot;</span><br></pre></td></tr></table></figure></p>
<p>你可以同时使用整型和切片语法来访问数组。但是，这样做会产生一个比原数组低阶的新数组。需要注意的是，这里和MATLAB中的情况是不同的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create the following rank 2 array with shape (3, 4)</span><br><span class="line"># [[ 1  2  3  4]</span><br><span class="line">#  [ 5  6  7  8]</span><br><span class="line">#  [ 9 10 11 12]]</span><br><span class="line">a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span><br><span class="line"></span><br><span class="line"># Two ways of accessing the data in the middle row of the array.</span><br><span class="line"># Mixing integer indexing with slices yields an array of lower rank,</span><br><span class="line"># while using only slices yields an array of the same rank as the</span><br><span class="line"># original array:</span><br><span class="line">row_r1 = a[1, :]    # Rank 1 view of the second row of a</span><br><span class="line">row_r2 = a[1:2, :]  # Rank 2 view of the second row of a</span><br><span class="line">print(row_r1, row_r1.shape)  # Prints &quot;[5 6 7 8] (4,)&quot;</span><br><span class="line">print(row_r2, row_r2.shape)  # Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span><br><span class="line"></span><br><span class="line"># We can make the same distinction when accessing columns of an array:</span><br><span class="line">col_r1 = a[:, 1]</span><br><span class="line">col_r2 = a[:, 1:2]</span><br><span class="line">print(col_r1, col_r1.shape)  # Prints &quot;[ 2  6 10] (3,)&quot;</span><br><span class="line">print(col_r2, col_r2.shape)  # Prints &quot;[[ 2]</span><br><span class="line">                             #          [ 6]</span><br><span class="line">                             #          [10]] (3, 1)&quot;</span><br></pre></td></tr></table></figure></p>
<p>整型数组访问：当我们使用切片语法访问数组时，得到的总是原数组的一个子集。整型数组访问允许我们利用其它数组的数据构建一个新的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1,2], [3, 4], [5, 6]])</span><br><span class="line"></span><br><span class="line"># An example of integer array indexing.</span><br><span class="line"># The returned array will have shape (3,) and</span><br><span class="line">print(a[[0, 1, 2], [0, 1, 0]])  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># The above example of integer array indexing is equivalent to this:</span><br><span class="line">print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &quot;[1 4 5]&quot;</span><br><span class="line"></span><br><span class="line"># When using integer array indexing, you can reuse the same</span><br><span class="line"># element from the source array:</span><br><span class="line">print(a[[0, 0], [1, 1]])  # Prints &quot;[2 2]&quot;</span><br><span class="line"></span><br><span class="line"># Equivalent to the previous integer array indexing example</span><br><span class="line">print(np.array([a[0, 1], a[0, 1]]))  # Prints &quot;[2 2]&quot;</span><br></pre></td></tr></table></figure></p>
<p>整型数组访问语法还有个有用的技巧，可以用来选择或者更改矩阵中每行中的一个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Create a new array from which we will select elements</span><br><span class="line">a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[ 1,  2,  3],</span><br><span class="line">          #                [ 4,  5,  6],</span><br><span class="line">          #                [ 7,  8,  9],</span><br><span class="line">          #                [10, 11, 12]])&quot;</span><br><span class="line"></span><br><span class="line"># Create an array of indices</span><br><span class="line">b = np.array([0, 2, 0, 1])</span><br><span class="line"></span><br><span class="line"># Select one element from each row of a using the indices in b</span><br><span class="line">print(a[np.arange(4), b])  # Prints &quot;[ 1  6  7 11]&quot;</span><br><span class="line"></span><br><span class="line"># Mutate one element from each row of a using the indices in b</span><br><span class="line">a[np.arange(4), b] += 10</span><br><span class="line"></span><br><span class="line">print(a)  # prints &quot;array([[11,  2,  3],</span><br><span class="line">          #                [ 4,  5, 16],</span><br><span class="line">          #                [17,  8,  9],</span><br><span class="line">          #                [10, 21, 12]])</span><br></pre></td></tr></table></figure></p>
<p>布尔型数组访问：布尔型数组访问可以让你选择数组中任意元素。通常，这种访问方式用于选取数组中满足某些条件的元素，举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">a = np.array([[1,2], [3, 4], [5, 6]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; 2)   # Find the elements of a that are bigger than 2;</span><br><span class="line">                     # this returns a numpy array of Booleans of the same</span><br><span class="line">                     # shape as a, where each slot of bool_idx tells</span><br><span class="line">                     # whether that element of a is &gt; 2.</span><br><span class="line"></span><br><span class="line">print(bool_idx)      # Prints &quot;[[False False]</span><br><span class="line">                     #          [ True  True]</span><br><span class="line">                     #          [ True  True]]&quot;</span><br><span class="line"></span><br><span class="line"># We use boolean array indexing to construct a rank 1 array</span><br><span class="line"># consisting of the elements of a corresponding to the True values</span><br><span class="line"># of bool_idx</span><br><span class="line">print(a[bool_idx])  # Prints &quot;[3 4 5 6]&quot;</span><br><span class="line"></span><br><span class="line"># We can do all of the above in a single concise statement:</span><br><span class="line">print(a[a &gt; 2])     # Prints &quot;[3 4 5 6]&quot;</span><br></pre></td></tr></table></figure></p>
<p>为了教程的简介，有很多数组访问的细节我们没有详细说明，可以查看<a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每个Numpy数组都是数据类型相同的元素组成的网格。Numpy提供了很多的数据类型用于创建数组。当你创建数组的时候，Numpy会尝试猜测数组的数据类型，你也可以通过参数直接指定数据类型，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([1, 2])   # Let numpy choose the datatype</span><br><span class="line">print(x.dtype)         # Prints &quot;int64&quot;</span><br><span class="line"></span><br><span class="line">x = np.array([1.0, 2.0])   # Let numpy choose the datatype</span><br><span class="line">print(x.dtype)             # Prints &quot;float64&quot;</span><br><span class="line"></span><br><span class="line">x = np.array([1, 2], dtype=np.int64)   # Force a particular datatype</span><br><span class="line">print(x.dtype)                         # Prints &quot;int64&quot;</span><br></pre></td></tr></table></figure>
<p>更多细节查看<a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h2><p>基本数学计算函数会对数组中元素逐个进行计算，既可以利用操作符重载，也可以使用函数方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]], dtype=np.float64)</span><br><span class="line">y = np.array([[5,6],[7,8]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"># Elementwise sum; both produce the array</span><br><span class="line"># [[ 6.0  8.0]</span><br><span class="line">#  [10.0 12.0]]</span><br><span class="line">print(x + y)</span><br><span class="line">print(np.add(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise difference; both produce the array</span><br><span class="line"># [[-4.0 -4.0]</span><br><span class="line">#  [-4.0 -4.0]]</span><br><span class="line">print(x - y)</span><br><span class="line">print(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise product; both produce the array</span><br><span class="line"># [[ 5.0 12.0]</span><br><span class="line">#  [21.0 32.0]]</span><br><span class="line">print(x * y)</span><br><span class="line">print(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise division; both produce the array</span><br><span class="line"># [[ 0.2         0.33333333]</span><br><span class="line">#  [ 0.42857143  0.5       ]]</span><br><span class="line">print(x / y)</span><br><span class="line">print(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"># Elementwise square root; produces the array</span><br><span class="line"># [[ 1.          1.41421356]</span><br><span class="line">#  [ 1.73205081  2.        ]]</span><br><span class="line">print(np.sqrt(x))</span><br></pre></td></tr></table></figure></p>
<p>和MATLAB不同，<code>*</code>是元素逐个相乘，而不是矩阵乘法。在Numpy中使用dot来进行矩阵乘法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]])</span><br><span class="line">y = np.array([[5,6],[7,8]])</span><br><span class="line"></span><br><span class="line">v = np.array([9,10])</span><br><span class="line">w = np.array([11, 12])</span><br><span class="line"></span><br><span class="line"># Inner product of vectors; both produce 219</span><br><span class="line">print(v.dot(w))</span><br><span class="line">print(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"># Matrix / vector product; both produce the rank 1 array [29 67]</span><br><span class="line">print(x.dot(v))</span><br><span class="line">print(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"># Matrix / matrix product; both produce the rank 2 array</span><br><span class="line"># [[19 22]</span><br><span class="line">#  [43 50]]</span><br><span class="line">print(x.dot(y))</span><br><span class="line">print(np.dot(x, y))</span><br></pre></td></tr></table></figure></p>
<p>Numpy提供了很多计算数组的函数，其中最常用的一个是<code>sum</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2],[3,4]])</span><br><span class="line"></span><br><span class="line">print(np.sum(x))  # Compute sum of all elements; prints &quot;10&quot;</span><br><span class="line">print(np.sum(x, axis=0))  # Compute sum of each column; prints &quot;[4 6]&quot;</span><br><span class="line">print(np.sum(x, axis=1))  # Compute sum of each row; prints &quot;[3 7]&quot;</span><br></pre></td></tr></table></figure></p>
<p>想要了解更多函数，可以查看<a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html" target="_blank" rel="noopener">文档</a>。</p>
<p>除了计算，我们还常常改变数组或者操作其中的元素。其中将矩阵转置是常用的一个，在Numpy中，使用<code>T</code>来转置矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">x = np.array([[1,2], [3,4]])</span><br><span class="line">print(x)    # Prints &quot;[[1 2]</span><br><span class="line">            #          [3 4]]&quot;</span><br><span class="line">print(x.T)  # Prints &quot;[[1 3]</span><br><span class="line">            #          [2 4]]&quot;</span><br><span class="line"></span><br><span class="line"># Note that taking the transpose of a rank 1 array does nothing:</span><br><span class="line">v = np.array([1,2,3])</span><br><span class="line">print(v)    # Prints &quot;[1 2 3]&quot;</span><br><span class="line">print(v.T)  # Prints &quot;[1 2 3]&quot;</span><br></pre></td></tr></table></figure></p>
<p>Numpy还提供了更多操作数组的方法，请查看<a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="广播Broadcasting"><a href="#广播Broadcasting" class="headerlink" title="广播Broadcasting"></a>广播Broadcasting</h2><p>广播是一种强有力的机制，它让Numpy可以让不同大小的矩阵在一起进行数学计算。我们常常会有一个小的矩阵和一个大的矩阵，然后我们会需要用小的矩阵对大的矩阵做一些计算。</p>
<p>举个例子，如果我们想要把一个向量加到矩阵的每一行，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = np.empty_like(x)   # Create an empty matrix with the same shape as x</span><br><span class="line"></span><br><span class="line"># Add the vector v to each row of the matrix x with an explicit loop</span><br><span class="line">for i in range(4):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"># Now y is the following</span><br><span class="line"># [[ 2  2  4]</span><br><span class="line">#  [ 5  5  7]</span><br><span class="line">#  [ 8  8 10]</span><br><span class="line">#  [11 11 13]]</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure></p>
<p>这样是行得通的，但是当<code>x</code>矩阵非常大，利用循环来计算就会变得很慢很慢。Note that adding the vector <code>v</code> to each row of the matrix <code>x</code> is equivalent to forming a matrix <code>vv</code> by stacking multiple copies of <code>v</code> vertically, then performing elementwise summation of <code>x</code> and <code>vv</code>. 我们可以换一种思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">vv = np.tile(v, (4, 1))   # Stack 4 copies of v on top of each other</span><br><span class="line">print(vv)                 # Prints &quot;[[1 0 1]</span><br><span class="line">                          #          [1 0 1]</span><br><span class="line">                          #          [1 0 1]</span><br><span class="line">                          #          [1 0 1]]&quot;</span><br><span class="line">y = x + vv  # Add x and vv elementwise</span><br><span class="line">print(y)  # Prints &quot;[[ 2  2  4</span><br><span class="line">          #          [ 5  5  7]</span><br><span class="line">          #          [ 8  8 10]</span><br><span class="line">          #          [11 11 13]]&quot;</span><br></pre></td></tr></table></figure></p>
<p>Numpy广播机制可以让我们不用创建<code>vv</code>，就能直接运算，看看下面例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># We will add the vector v to each row of the matrix x,</span><br><span class="line"># storing the result in the matrix y</span><br><span class="line">x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])</span><br><span class="line">v = np.array([1, 0, 1])</span><br><span class="line">y = x + v  # Add v to each row of x using broadcasting</span><br><span class="line">print(y)  # Prints &quot;[[ 2  2  4]</span><br><span class="line">          #          [ 5  5  7]</span><br><span class="line">          #          [ 8  8 10]</span><br><span class="line">          #          [11 11 13]]&quot;</span><br></pre></td></tr></table></figure></p>
<p>The line <code>y = x + v</code> works even though <code>x</code> has shape <code>(4, 3)</code> and v has shape<code>(3,)</code> due to broadcasting; this line works as if <code>v</code> actually had shape <code>(4, 3)</code>, where each row was a copy of <code>v</code>, and the sum was performed elementwise.</p>
<p>对两个数组使用广播机制要遵守下列规则：</p>
<ol>
<li>如果数组的秩不同，使用1来将秩较小的数组进行扩展，直到两个数组的尺寸的长度都一样。</li>
<li>如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上长度为1，那么我们就说这两个数组在该维度上是相容的。</li>
<li>如果两个数组在所有维度上都是相容的，他们就能使用广播。</li>
<li>如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和那个较大的尺寸一样。</li>
<li>在任何一个维度上，如果一个数组的长度为1，另一个数组长度大于1，那么在该维度上，就好像是对第一个数组进行了复制。</li>
</ol>
<p>如果上述解释看不明白，可以读一读<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="noopener">文档</a>和这个<a href="http://wiki.scipy.org/EricsBroadcastingDoc/" target="_blank" rel="noopener">解</a>释。译者注：强烈推荐阅读文档中的例子。</p>
<p>支持广播机制的函数是全局函数。哪些是全局函数可以在<a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs" target="_blank" rel="noopener">文档</a>中查找。</p>
<p>下面是一些广播机制的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Compute outer product of vectors</span><br><span class="line">v = np.array([1,2,3])  # v has shape (3,)</span><br><span class="line">w = np.array([4,5])    # w has shape (2,)</span><br><span class="line"># To compute an outer product, we first reshape v to be a column</span><br><span class="line"># vector of shape (3, 1); we can then broadcast it against w to yield</span><br><span class="line"># an output of shape (3, 2), which is the outer product of v and w:</span><br><span class="line"># [[ 4  5]</span><br><span class="line">#  [ 8 10]</span><br><span class="line">#  [12 15]]</span><br><span class="line">print(np.reshape(v, (3, 1)) * w)</span><br><span class="line"></span><br><span class="line"># Add a vector to each row of a matrix</span><br><span class="line">x = np.array([[1,2,3], [4,5,6]])</span><br><span class="line"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span><br><span class="line"># giving the following matrix:</span><br><span class="line"># [[2 4 6]</span><br><span class="line">#  [5 7 9]]</span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line"># Add a vector to each column of a matrix</span><br><span class="line"># x has shape (2, 3) and w has shape (2,).</span><br><span class="line"># If we transpose x then it has shape (3, 2) and can be broadcast</span><br><span class="line"># against w to yield a result of shape (3, 2); transposing this result</span><br><span class="line"># yields the final result of shape (2, 3) which is the matrix x with</span><br><span class="line"># the vector w added to each column. Gives the following matrix:</span><br><span class="line"># [[ 5  6  7]</span><br><span class="line">#  [ 9 10 11]]</span><br><span class="line">print((x.T + w).T)</span><br><span class="line"># Another solution is to reshape w to be a column vector of shape (2, 1);</span><br><span class="line"># we can then broadcast it directly against x to produce the same</span><br><span class="line"># output.</span><br><span class="line">print(x + np.reshape(w, (2, 1)))</span><br><span class="line"></span><br><span class="line"># Multiply a matrix by a constant:</span><br><span class="line"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span><br><span class="line"># these can be broadcast together to shape (2, 3), producing the</span><br><span class="line"># following array:</span><br><span class="line"># [[ 2  4  6]</span><br><span class="line">#  [ 8 10 12]]</span><br><span class="line">print(x * 2)</span><br></pre></td></tr></table></figure></p>
<p>广播机制能够让你的代码更简洁更迅速，能够用的时候请尽量使用！</p>
<h2 id="Numpy文档"><a href="#Numpy文档" class="headerlink" title="Numpy文档"></a>Numpy文档</h2><p>这篇教程涉及了你需要了解的numpy中的一些重要内容，但是numpy远不止如此。可以查阅<a href="http://docs.scipy.org/doc/numpy/reference/" target="_blank" rel="noopener">numpy文献</a>来学习更多。</p>
<h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><p>Numpy提供了高性能的多维数组，以及计算和操作数组的基本工具。<a href="http://docs.scipy.org/doc/scipy/reference/" target="_blank" rel="noopener">SciPy</a>基于Numpy，提供了大量的计算和操作数组的函数，这些函数对于不同类型的科学和工程计算非常有用。</p>
<p>熟悉SciPy的最好方法就是阅读<a href="http://docs.scipy.org/doc/scipy/reference/index.html" target="_blank" rel="noopener">文档</a>。我们会强调对于本课程有用的部分。</p>
<h2 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h2><p>SciPy提供了一些操作图像的基本函数。比如，它提供了将图像从硬盘读入到数组的函数，也提供了将数组中数据写入的硬盘成为图像的函数。下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from scipy.misc import imread, imsave, imresize</span><br><span class="line"></span><br><span class="line"># Read an JPEG image into a numpy array</span><br><span class="line">img = imread(&apos;assets/cat.jpg&apos;)</span><br><span class="line">print(img.dtype, img.shape)  # Prints &quot;uint8 (400, 248, 3)&quot;</span><br><span class="line"></span><br><span class="line"># We can tint the image by scaling each of the color channels</span><br><span class="line"># by a different scalar constant. The image has shape (400, 248, 3);</span><br><span class="line"># we multiply it by the array [1, 0.95, 0.9] of shape (3,);</span><br><span class="line"># numpy broadcasting means that this leaves the red channel unchanged,</span><br><span class="line"># and multiplies the green and blue channels by 0.95 and 0.9</span><br><span class="line"># respectively.</span><br><span class="line">img_tinted = img * [1, 0.95, 0.9]</span><br><span class="line"></span><br><span class="line"># Resize the tinted image to be 300 by 300 pixels.</span><br><span class="line">img_tinted = imresize(img_tinted, (300, 300))</span><br><span class="line"></span><br><span class="line"># Write the tinted image back to disk</span><br><span class="line">imsave(&apos;assets/cat_tinted.jpg&apos;, img_tinted)</span><br></pre></td></tr></table></figure></p>
<p>译者注：如果运行这段代码出现类似ImportError: cannot import name imread的报错，那么请利用pip进行Pillow的下载，可以解决问题。命令：pip install Pillow。</p>
<p>—————————————————————————————————————————</p>
<div align="center"><br><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/cat.jpg?raw=true"><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/cat_tinted.jpg?raw=true"><br></div>

<p>左边是原始图片，右边是变色和变形的图片。</p>
<p>—————————————————————————————————————————</p>
<h2 id="MATLAB文件"><a href="#MATLAB文件" class="headerlink" title="MATLAB文件"></a>MATLAB文件</h2><p>函数<code>scipy.io.loadmat</code>和<code>scipy.io.savemat</code>能够让你读和写MATLAB文件。具体请查看<a href="http://docs.scipy.org/doc/scipy/reference/io.html" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="点之间的距离"><a href="#点之间的距离" class="headerlink" title="点之间的距离"></a>点之间的距离</h2><p>SciPy定义了一些有用的函数，可以计算集合中点之间的距离。</p>
<p>函数<code>scipy.spatial.distance.pdist</code>能够计算集合中所有两点之间的距离：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.spatial.distance import pdist, squareform</span><br><span class="line"></span><br><span class="line"># Create the following array where each row is a point in 2D space:</span><br><span class="line"># [[0 1]</span><br><span class="line">#  [1 0]</span><br><span class="line">#  [2 0]]</span><br><span class="line">x = np.array([[0, 1], [1, 0], [2, 0]])</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"># Compute the Euclidean distance between all rows of x.</span><br><span class="line"># d[i, j] is the Euclidean distance between x[i, :] and x[j, :],</span><br><span class="line"># and d is the following array:</span><br><span class="line"># [[ 0.          1.41421356  2.23606798]</span><br><span class="line">#  [ 1.41421356  0.          1.        ]</span><br><span class="line">#  [ 2.23606798  1.          0.        ]]</span><br><span class="line">d = squareform(pdist(x, &apos;euclidean&apos;))</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure></p>
<p>具体细节请阅读<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html" target="_blank" rel="noopener">文档</a>。</p>
<p>函数<code>scipy.spatial.distance.cdist</code>可以计算不同集合中点的距离，具体请查看<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html" target="_blank" rel="noopener">文档</a>。</p>
<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><p><a href="http://matplotlib.org/" target="_blank" rel="noopener">Matplotlib</a>是一个作图库。这里简要介绍<code>matplotlib.pyplot</code>模块，功能和MATLAB的作图功能类似。</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>matplotlib库中最重要的函数是<code>Plot</code>。该函数允许你做出2D图形，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Compute the x and y coordinates for points on a sine curve</span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"># Plot the points using matplotlib</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()  # You must call plt.show() to make graphics appear.</span><br></pre></td></tr></table></figure></p>
<p>运行上面代码会产生下面的作图：</p>
<p>—————————————————————————————————————————</p>
<p><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/sine.png?raw=true" alt="image"></p>
<p>—————————————————————————————————————————<br>只需要少量工作，就可以一次画不同的线，加上标签，坐标轴标志等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Compute the x and y coordinates for points on sine and cosine curves</span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"># Plot the points using matplotlib</span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.xlabel(&apos;x axis label&apos;)</span><br><span class="line">plt.ylabel(&apos;y axis label&apos;)</span><br><span class="line">plt.title(&apos;Sine and Cosine&apos;)</span><br><span class="line">plt.legend([&apos;Sine&apos;, &apos;Cosine&apos;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>—————————————————————————————————————————</p>
<p><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/sine_cosine.png?raw=true" alt="image"></p>
<p>—————————————————————————————————————————<br>可以在<a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot/" target="_blank" rel="noopener">文档</a>中阅读更多关于<code>plot</code>的内容。</p>
<h2 id="绘制多个图像"><a href="#绘制多个图像" class="headerlink" title="绘制多个图像"></a>绘制多个图像</h2><p>可以使用<code>subplot</code>函数来在一幅图中画不同的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Compute the x and y coordinates for points on sine and cosine curves</span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"># Set up a subplot grid that has height 2 and width 1,</span><br><span class="line"># and set the first such subplot as active.</span><br><span class="line">plt.subplot(2, 1, 1)</span><br><span class="line"></span><br><span class="line"># Make the first plot</span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(&apos;Sine&apos;)</span><br><span class="line"></span><br><span class="line"># Set the second subplot as active, and make the second plot.</span><br><span class="line">plt.subplot(2, 1, 2)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(&apos;Cosine&apos;)</span><br><span class="line"></span><br><span class="line"># Show the figure.</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>—————————————————————————————————————————</p>
<p><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/sine_cosine_subplot.png?raw=true" alt="image"></p>
<p>—————————————————————————————————————————<br>关于<code>subplot</code>的更多细节，可以阅读<a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot" target="_blank" rel="noopener">文档</a>。</p>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>你可以使用<code>imshow</code>函数来显示图像，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from scipy.misc import imread, imresize</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">img = imread(&apos;assets/cat.jpg&apos;)</span><br><span class="line">img_tinted = img * [1, 0.95, 0.9]</span><br><span class="line"></span><br><span class="line"># Show the original image</span><br><span class="line">plt.subplot(1, 2, 1)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"># Show the tinted image</span><br><span class="line">plt.subplot(1, 2, 2)</span><br><span class="line"></span><br><span class="line"># A slight gotcha with imshow is that it might give strange results</span><br><span class="line"># if presented with data that is not uint8. To work around this, we</span><br><span class="line"># explicitly cast the image to uint8 before displaying it.</span><br><span class="line">plt.imshow(np.uint8(img_tinted))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p>—————————————————————————————————————————<br><img src="https://github.com/vvshyer/pics/blob/master/python-numpy-tutorial/cat_tinted_imshow.png?raw=true" alt="image"><br>—————————————————————————————————————————</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">CS231n</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2018/02/10/Python Numpy 教程/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-用Gradle构建Spring Boot项目" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/16/用Gradle构建Spring Boot项目/">用Gradle构建Spring Boot项目</a>
    </h1>
  

        
        <a href="/2017/08/16/用Gradle构建Spring Boot项目/" class="archive-article-date">
  	<time datetime="2017-08-16T09:51:05.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-08-16</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>相比起Maven的XML配置方式，Gradle提供了一套简明的DSL用于构建Java项目，使我们就像编写程序一样编写项目构建脚本。本文将从无到有创建一个用Gradle构建的Spring Boot项目，并在此过程中讲到Gradle的一些典型用法。</p>
<h1 id="创建Gradle工程"><a href="#创建Gradle工程" class="headerlink" title="创建Gradle工程"></a>创建Gradle工程</h1><p>Gradle采用了与Maven相同的目录组织结构，你可以通过Spring Initializr网站创建Spring Boot工程。但是在本文中，我们将全部通过命令行操作创建Spring Boot工程。首先在命令行中创建如下目录结构：</p>
<pre><code>└── src
    ├── main
    │   └── java
    └── test
        └── java    
</code></pre><p>然后在src同级目录中添加一个build.gradle文件，内容如下：</p>
<pre><code>apply plugin: &apos;java&apos;
</code></pre><p>大功告成，一个用Gradle构建的Java项目创建好了，尽情用以下命令编译并打包咱们的Java项目吧：</p>
<pre><code>gradle build
</code></pre><p>只是现在咱们的Java项目还是一个空架子，不用急，在下文中我们将一步一步在这个空架子中搭建一个有血有肉的Spring Boot项目。<br>值得一提的是，虽然此时的build.gradle文件中只有一行配置（apply plugin: ‘java’，作用是引入java插件），但是其背后已经帮我们做了很多事情，比如它使得我们能够运行gradle build命令。这里的build即为Gradle中的一个任务（Task），我们还可以运行以下命令查看到更多的Task。</p>
<pre><code>gradle tasks
</code></pre><p>此时输出：</p>
<pre><code>…
Build tasks
    -----------
assemble - Assembles the outputs of this project.
build - Assembles and tests this project.
buildDependents - Assembles and tests this project and all projects that depend on it.
buildNeeded - Assembles and tests this project and all projects it depends on.
classes - Assembles main classes.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.
testClasses - Assembles test classes.
...
</code></pre><p>这里的assemble、build和jar等Task都是java插件引入的。build.gradle是Gradle的配置文件。</p>
<h1 id="使用Gradle-Wrapper"><a href="#使用Gradle-Wrapper" class="headerlink" title="使用Gradle Wrapper"></a>使用Gradle Wrapper</h1><p>对于所有的Gradle项目来说，笔者都推荐使用Gradle Wrapper，甚至应该将其当做创建代码库之后的第一件事来做。使用Gradle Wrapper有以下好处：</p>
<ol>
<li>不用安装gradle也能运行gradle</li>
<li><p>所有人使用相同的gradle版本<br>在build.gradle中加入以下配置：</p>
<p>task wrapper(type: Wrapper) {<br>gradleVersion = ‘3.0’<br>}    </p>
</li>
</ol>
<p>然后在命令行运行：</p>
<pre><code>gradle wrapper
</code></pre><p>此时会生成以下三个文件（夹）：gradlew、gradlew.bat和gradle目录。<br>这里的gradlew和gradlew.bat其实只是脚本文件（前者用于Unix/Linux/Mac，后者用于Windows），在使用gradle命令的地方替换为gradlew或gradlew.bat，他们将自动下载指定的gradle版本，然后用该版本进行项目构建。如上文所示，本文中我们配置gradle版本为3.0。<br>请注意，这三个文件（夹）都需要提交到代码库中。当项目其他人拿到代码之后，由于gradlew和gradlew.bat文件均在源代码中，他们本地即便没有gradle，依然可以通过以下命令进行项目构建：</p>
<pre><code>./gradlew build
</code></pre><p>如果你的项目有持续集成（CI）服务器（你也应该有），那么你的CI机器也没有必要安装Gradle了。另外，此时所有人都是使用的相同版本的gradle，进而避免了由于版本不同所带来的问题。</p>
<h1 id="添加Spring-Boot依赖"><a href="#添加Spring-Boot依赖" class="headerlink" title="添加Spring Boot依赖"></a>添加Spring Boot依赖</h1><p>在本文中，我们的业务非常简单———输出“Hello World！”。但是麻雀虽小，五脏俱全，首先需要在build.gradle中配置spring-boot插件，并引入Spring的Web组件，整个build.gradle如下：</p>
<pre><code>buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.5.2.RELEASE&quot;)
    }
}

repositories {
    jcenter()
}

apply plugin: &apos;java&apos;
apply plugin: &apos;org.springframework.boot&apos;


sourceCompatibility = 1.8
targetCompatibility = 1.8


task wrapper(type: Wrapper) {
    gradleVersion = &apos;3.0&apos;
}

dependencies {
    compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;)
    testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)
}
</code></pre><p>然后创建Application类：</p>
<pre><code>@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
</code></pre><p>依然很简单，是吧？！这个Application类便是Spring Boot程序的入口。另外我们还需要一个Controller和一个业务类HelloWorld：</p>
<pre><code>HelloWorldController:
@RestController(&quot;/helloworld&quot;)
public class HelloController {

    private HelloWorld helloWorld;

    public HelloController(HelloWorld helloWorld) {
        this.helloWorld = helloWorld;
    }

    @GetMapping
    public String hello() {
        return helloWorld.hello();
    }
}
HelloWorld:
@Component
public class HelloWorld {

    public String hello() {
        return &quot;Hello World!&quot;;
    }
}
</code></pre><p>此时工程的目录结构为：</p>
<pre><code>├── README.md
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── src
    ├── main
    │   └── java
    │       └── davenkin
    │           ├── Application.java
    │           ├── HelloController.java
    │           └── HelloWorld.java
    └── test
        └── java
        `
</code></pre><p>然后运行：</p>
<pre><code>./gradlew bootRun
</code></pre><p>在浏览器或者Postman中打开<em><a href="http://localhost:8080/gradle-spring-boot/helloworld" target="_blank" rel="noopener">http://localhost:8080/gradle-spring-boot/helloworld</a></em>，便可以看到久违的”Hello World！”了。</p>
<h1 id="生成IDE工程文件"><a href="#生成IDE工程文件" class="headerlink" title="生成IDE工程文件"></a>生成IDE工程文件</h1><p>我曾经看到不少人在Eclipse或者IntelliJ IDEA中导入Maven/Gradle工程，甚至在IDE中使用嵌入Tomcat容器。我并不推荐这么做，这些严重依赖于GUI操作的功能其实是很笨拙、很脆弱的。以嵌入Tomcat容器为例，它要求项目中所有人都在自己的IDE中手动地对Tomcat进行配置，而手动的过程总是容易出错的。在持续交付中有个原则是“凡是能够自动化的，都应该自动化”，这里的自动化说白了其实就是代码化。</p>
<p>因此，在使用Gradle时，笔者更推崇的一种方式是通过Gradle的IDE插件一键式地生成IDE工程文件，然后在IDE中直接打开这样的工程文件。这样的好处一是非常简单，二是所有人都使用了相同的IDE配置。</p>
<p>在Gradle中配置IntelliJ IDEA插件，只需在build.gradle中配置：</p>
<pre><code>apply plugin: &apos;idea&apos;
</code></pre><p>然后运行：</p>
<pre><code>./gradlew idea
</code></pre><p>此时将生成后缀为ipr的IntelliJ IDEA工程文件，在IntelliJ IDEA中直接打开(Open)该文件即可。</p>
<p>对于Eclipse，在build.gradle中增加以下配置：</p>
<pre><code>apply plugin: &apos;eclipse&apos;
</code></pre><p>然后运行：</p>
<pre><code>./gradlew eclipse
</code></pre><p>此时将生成Eclipse的.project工程文件。</p>
<p><em>请注意，所有IDE工程文件都不应该提交到代码库，对于Git来说应该将这些文件注册到.gitignore文件中。各个开发者拿到代码后需要各自运行./graldlw idea或./gradlew eclipse命令以生成本地工程文件。</em></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>至少有两种方式可以对Spring Boot项目进行调试。一种是直接运行命令：</p>
<pre><code>./gradlew bootRun --debug-jvm
</code></pre><p>此时程序将默认监听5005端口，并暂停以等待调试客户端的连接，然后启动Spring Boot。</p>
<p>另一种方式是使用Gradle的Application插件，在build.gradle中添加：</p>
<pre><code>apply plugin: &apos;application&apos;
applicationDefaultJvmArgs = [ &quot;-    agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005&quot; ]
</code></pre><p>此时运行：</p>
<pre><code>./gradlew bootRun
</code></pre><p>程序将启动并监听5005调试端口，但是与第一种方法不同的是，程序不会暂停，而是将直接启动整个Spring Boot程序。如果你想调试Spring Boot在启动过程中的某些代码，比如Spring框架启动代码，那么请选择第一种方式；否则，第二种是更合适的选择，因为我们并不是每次启动程序都一定会调试的，对吧？！</p>
<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><p>软件项目可以包含多种自动化测试，比如单元测试、集成测试、功能测试等。对于Spring Boot项目来说，笔者推荐将自动化测试划分为单元测试和API测试，其中单元测试即是传统的单元测试，而API测试包含了集成测试、功能测试和端到端测试的功能，它的测试对象是程序向外暴露的REST API接口，在测试时我们需要启动整个Spring Boot程序，然后模拟客户端调用这些API接口来完成业务测试用例。</p>
<p>单元测试相对比较简单，Spring Boot也提供了一些有助于单元测试的设施，但是我并不推荐大家使用，因为单元测试应该是非常纯粹、粒度非常小的测试，不应该有框架掺和。</p>
<p>通常来说，单元测试和API测试应该是分离的，也即他们的代码应该是分开的，运行测试的命令也应该是不同的。但是这给Gradle带来了难题，因为默认情况下Gradle只提供一个./gradlew test命令用于测试，并且默认要求测试代码位于src/test/java目录下。为此，我们需要对Gradle进行改造。</p>
<p>我们的目的是：</p>
<ul>
<li>默认的src/test/java目录用于单元测试代码，通过./gradlew test运行</li>
<li>新建src/apiTest/java目录用于API测试代码，通过./gradlew apiTest运行</li>
</ul>
<p>可以看到，我么将Gradle默认的测试设施用于了单元测试，也即对于单元测试我们不需要做任何改变。对于API测试而言，首先我们需要添加名为apiTest的源代码集合（SrouceSet），该SourceSet即对应了src/apiTest/java目录，在build.gradle文件中增加如下配置：</p>
<pre><code>sourceSets {
    apiTest {
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}

configurations {
    apiTestCompile.extendsFrom testCompile
    apiTestRuntime.extendsFrom testRuntime
}
</code></pre><p>然后，添加一个Test类型的Task用于运行src/apiTest/java目录下的API测试代码：</p>
<pre><code>task apiTest(type: Test) {
    testClassesDir =     sourceSets.apiTest.output.classesDir
    classpath = sourceSets.apiTest.runtimeClasspath
}
</code></pre><p>为了使Intelli IDEA能够感知到这些新添加的测试代码，我们需要对Gradle的idea插件进行额外配置：</p>
<pre><code>idea {
    module {
        testSourceDirs += file(&apos;src/apiTest/java&apos;)
        testSourceDirs += file(&apos;src/apiTest/resources&apos;)
        scopes.TEST.plus += [configurations.apiTestCompile]
        scopes.TEST.plus += [configurations.apiTestRuntime]
    }
}
</code></pre><p>另外，为了使本地构建（./gradlew biuld）过程能够先运行单元测试，再运行API测试，我们还需要做以下配置：</p>
<pre><code>apiTest.mustRunAfter test
build.dependsOn apiTest
</code></pre><p>第一行的意思是API测试必须运行在单元测试之后，第二行的意思是将API测试包含在build任务中。</p>
<p><a href="http://www.cnblogs.com/davenkin/p/gradle-spring-boot.html" target="_blank" rel="noopener">原文链接</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Gradle</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/08/16/用Gradle构建Spring Boot项目/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Spring Boot" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/19/Spring Boot/">Spring Boot</a>
    </h1>
  

        
        <a href="/2017/07/19/Spring Boot/" class="archive-article-date">
  	<time datetime="2017-07-19T09:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-07-19</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring-Boot-是什么"><a href="#Spring-Boot-是什么" class="headerlink" title="Spring Boot 是什么"></a>Spring Boot 是什么</h2><ul>
<li>为所有Spring 开发提供一个更快更广泛的入门体验</li>
<li>开箱即用，不合适时也可以快速抛弃</li>
<li>提供一系列大型项目常用的非功能性特征</li>
<li>零配置（无需XML配置，遵循“约定大于配置”）<h2 id="Spring-Boot-简化开发"><a href="#Spring-Boot-简化开发" class="headerlink" title="Spring Boot 简化开发"></a>Spring Boot 简化开发</h2>抛弃了传统JavaEE项目繁琐的配置、学习过程，让企业级应用开发过程变得更容易。<h2 id="Spring-Boot与其他框架的关系"><a href="#Spring-Boot与其他框架的关系" class="headerlink" title="Spring Boot与其他框架的关系"></a>Spring Boot与其他框架的关系</h2><h2 id="通过Spring-Initializr初始化一个Web项目"><a href="#通过Spring-Initializr初始化一个Web项目" class="headerlink" title="通过Spring Initializr初始化一个Web项目"></a>通过Spring Initializr初始化一个Web项目</h2><code>http://start.spring.io/</code></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Spring</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/07/19/Spring Boot/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-mmall之Spring" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/mmall之Spring/">Spring</a>
    </h1>
  

        
        <a href="/2017/06/28/mmall之Spring/" class="archive-article-date">
  	<time datetime="2017-06-28T11:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-06-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring-学习"><a href="#Spring-学习" class="headerlink" title="Spring 学习"></a>Spring 学习</h2><p>spring-projects/spring-mvc-showcase<br>spring-projects/spring-petclinic<br>spring-projects/greenhouse</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Spring</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/06/28/mmall之Spring/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Spring4_day01" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/01/Spring4_day01/">Spring框架第一天</a>
    </h1>
  

        
        <a href="/2017/04/01/Spring4_day01/" class="archive-article-date">
  	<time datetime="2017-04-01T09:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-04-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="今天课程：Spring框架第一天"><a href="#今天课程：Spring框架第一天" class="headerlink" title="今天课程：Spring框架第一天"></a>今天课程：Spring框架第一天</h2><hr>
<p><strong>Spring框架的学习路线</strong></p>
<pre><code>1. Spring第一天：Spring的IOC容器之XML的方式，Spring框架与Web项目整合
2. Spring第二天：Spring的IOC容器之注解的方式，Spring的AOP技术
3. Spring第三天：Spring的事务管理、Spring框架的JDBC模板
4. Spring第四天：SSH三大框架的整合
</code></pre><hr>
<p><strong>今天内容概述</strong></p>
<pre><code>1. Spring框架的概述
2. SpringIOC的快速入门
3. IoC容器XML的方式
4. 在web项目中集成Spring
</code></pre><hr>
<h3 id="案例一：使用Spring的IOC技术完成客户的保存功能"><a href="#案例一：使用Spring的IOC技术完成客户的保存功能" class="headerlink" title="案例一：使用Spring的IOC技术完成客户的保存功能"></a>案例一：使用Spring的IOC技术完成客户的保存功能</h3><hr>
<p><strong>需求分析</strong></p>
<pre><code>1. 使用Spring的IOC技术完成客户的保存功能
</code></pre><hr>
<h3 id="技术分析之Spring框架的概述和入门"><a href="#技术分析之Spring框架的概述和入门" class="headerlink" title="技术分析之Spring框架的概述和入门"></a>技术分析之Spring框架的概述和入门</h3><hr>
<p><strong>技术分析之什么是Spring框架</strong></p>
<pre><code>1. Spring框架的概述
    * Spring是一个开源框架
    * Spring是于2003 年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。
    * 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。
    * Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以    从Spring中受益。
    * Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。

    * EE开发分成三层结构
        * WEB层        -- Spring MVC
        * 业务层    -- Bean管理:(IOC)
        * 持久层    -- Spring的JDBC模板.ORM模板用于整合其他的持久层框架
</code></pre><hr>
<p><strong>技术分析之Spring框架的特点</strong></p>
<pre><code>1. 为什么要学习Spring的框架
    * 方便解耦，简化开发
        * Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理
    * AOP编程的支持
        * Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能
    * 声明式事务的支持
        * 只需要通过配置就可以完成对事务的管理，而无需手动编程
    * 方便程序的测试
        * Spring对Junit4支持，可以通过注解方便的测试Spring程序
    * 方便集成各种优秀框架
        * Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持
    * 降低JavaEE API的使用难度
        * Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低

2. Spring框架的版本
    * Spring3.x和Spring4.x的版本
</code></pre><hr>
<p><strong>技术分析之Spring框架的IOC核心功能快速入门</strong></p>
<pre><code>1. 什么是IOC的功能？
    * IoC        -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！
    * 使用IOC可以解决的程序耦合性高的问题！！

2. 步骤一：下载Spring框架的开发包
    * 官网：http://spring.io/
    * 下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:)
        * docs        -- API和开发规范
        * libs        -- jar包和源码
        * schema    -- 约束

3. 步骤二：创建JavaWEB项目，引入Spring的开发包
    * 引入Spring框架IOC核心功能需要的具体的jar包
        * Spring框架的IOC的功能，那么根据Spring框架的体系结构图能看到，只需要引入如下的jar包
            * Beans
            * Core
            * Context
            * Expression Language

        * Spring框架也需要引入日志相关的jar包
            * 在spring-framework-3.0.2.RELEASE-dependencies/org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1
                * com.springsource.org.apache.commons.logging-1.1.1.jar

            * 还需要引入log4j的jar包 spring-framework-3.0.2.RELEASE-dependencies\org.apache.log4j\com.springsource.org.apache.log4j\1.2.15
                * com.springsource.org.apache.log4j-1.2.15.jar

4. 步骤三：创建对应的包结构，编写Java的类，要注意：以后使用Spring框架做开发，都需要来编写接口与实现类！！
    * com.itcast.demo1
        * UserService            -- 接口
        * UserServiceImpl        -- 具体的实现类

5. 步骤四：想把UserServiceImpl实现类的创建交给Spring框架来管理，需要创建Spring框架的配置文件，完成配置
    * 在src目录下创建applicationContext.xml的配置文件，名称是可以任意的，但是一般都会使用默认名称！！

    * 引入spring的约束，需要先找到具体的约束头信息！！
        * spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html
        * 具体的约束如下：        
            &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
                xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                xsi:schemaLocation=&quot;
                    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
            &lt;/beans&gt;

    * 完成UserService的配置
        &lt;!-- Spring的快速入门 --&gt;
        &lt;bean id=&quot;userService&quot; class=&quot;com.itcast.demo1.UserServiceImpl&quot;/&gt;

6. 步骤五：编写测试程序，采用Spring框架的工厂方式来获取到UserService接口的具体实现类！！
    public void demo2(){
        // 使用Spring的工厂:
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        // 通过工厂获得类:
        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);
        userService.sayHello();
    }
</code></pre><hr>
<p><strong>入门总结之Spring框架中的工厂（了解）</strong></p>
<pre><code>1. ApplicationContext接口
    * 使用ApplicationContext工厂的接口，使用该接口可以获取到具体的Bean对象
    * 该接口下有两个具体的实现类
        * ClassPathXmlApplicationContext            -- 加载类路径下的Spring配置文件
        * FileSystemXmlApplicationContext            -- 加载本地磁盘下的Spring配置文件

2. BeanFactory工厂（是Spring框架早期的创建Bean对象的工厂接口）
    * 使用BeanFactory接口也可以获取到Bean对象
        public void run(){
            BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));
            UserService us = (UserService) factory.getBean(&quot;us&quot;);
            us.sayHello();
        }

    * BeanFactory和ApplicationContext的区别
        * BeanFactory                -- BeanFactory采取延迟加载，第一次getBean时才会初始化Bean
        * ApplicationContext        -- 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能
            * 事件传递
            * Bean自动装配
            * 各种不同应用层的Context实现
</code></pre><hr>
<p><strong>入门总结之配置Spring框架编写XML的提示</strong></p>
<pre><code>1. 步骤一：先复制， http://www.springframework.org/schema/beans/spring-beans.xsd    
2. 步骤二：搜索XML Catalog，点击Add按钮
3. 步骤三：先选择Location的schema的约束地址
    * E:\class\2016\JavaEE28\day35_Spring框架第一天\资料\spring-framework-4.2.4.RELEASE-schema\beans\spring-beans-4.2.xsd
4. 步骤四：注意：Key type要选择：Schema location
5. 步骤五：Key把http://www.springframework.org/schema/beans/spring-beans.xsd复制上
</code></pre><hr>
<h3 id="技术分析之Spring框架的Bean管理的配置文件方式"><a href="#技术分析之Spring框架的Bean管理的配置文件方式" class="headerlink" title="技术分析之Spring框架的Bean管理的配置文件方式"></a>技术分析之Spring框架的Bean管理的配置文件方式</h3><hr>
<p><strong>技术分析之Spring框架中<bean>标签的配置</bean></strong></p>
<pre><code>1. id属性和name属性的区别
    * id        -- Bean起个名字，在约束中采用ID的约束，唯一
        * 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号    id:不能出现特殊字符

    * name        -- Bean起个名字，没有采用ID的约束（了解）
        * 取值要求：name:出现特殊字符.如果&lt;bean&gt;没有id的话 , name可以当做id使用
        * Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以/开头的，例如：/bookAction

2. class属性            -- Bean对象的全路径
3. scope属性            -- scope属性代表Bean的作用范围
    * singleton            -- 单例（默认值）
    * prototype            -- 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！
    * request            -- 应用在Web项目中,每次HTTP请求都会创建一个新的Bean
    * session            -- 应用在Web项目中,同一个HTTP Session 共享一个Bean
    * globalsession        -- 应用在Web项目中,多服务器间的session

4. Bean对象的创建和销毁的两个属性配置（了解）
    * 说明：Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法
    * init-method        -- 当bean被载入到容器的时候调用init-method属性指定的方法
    * destroy-method    -- 当bean从容器中删除的时候调用destroy-method属性指定的方法
        * 想查看destroy-method的效果，有如下条件
            * scope= singleton有效
            * web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法）
</code></pre><hr>
<p><strong>技术分析之依赖注入（DI）</strong></p>
<pre><code>1. IOC和DI的概念
    * IOC        -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！
    * DI        -- Dependency Injection，依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！

2.  DI（依赖注入）
    * 例如：如果UserServiceImpl的实现类中有一个属性，那么使用Spring框架的IOC功能时，可以通过依赖注入把该属性的值传入进来！！
    * 具体的配置如下
        &lt;bean id=&quot;us&quot; class=&quot;com.vvshyer.demo1.UserServiceImpl&quot;&gt;
            &lt;property name=&quot;uname&quot; value=&quot;小风&quot;/&gt;
        &lt;/bean&gt;
</code></pre><hr>
<p><strong>技术分析之Spring框架的属性注入</strong></p>
<pre><code>1. 对于类成员变量，常用的注入方式有两种
    * 构造函数注入
    * 属性setter方法注入

2. 在Spring框架中提供了前两种的属性注入的方式
    1. 构造方法的注入方式，两步
        * 编写Java的类，提供构造方法
            public class Car {
                private String name;
                private double money;
                public Car(String name, double money) {
                    this.name = name;
                    this.money = money;
                }
                @Override
                public String toString() {
                    return &quot;Car [name=&quot; + name + &quot;, money=&quot; + money + &quot;]&quot;;
                }
            }

        * 编写配置文件
            &lt;bean id=&quot;car&quot; class=&quot;com.vvshyer.demo4.Car&quot;&gt;
                &lt;constructor-arg name=&quot;name&quot; value=&quot;大奔&quot;/&gt;
                &lt;constructor-arg name=&quot;money&quot; value=&quot;100&quot;/&gt;
            &lt;/bean&gt;

    2. 属性的setter方法的注入方式
        * 编写Java的类，提供属性和对应的set方法即可
        * 编写配置文件

    3. 如果Java类的属性是另一个Java的类，那么需要怎么来注入值呢？
        * &lt;property name=&quot;name&quot; rel=&quot;具体的Bean的ID或者name的值&quot;/&gt;
        * 例如：
            &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot;&gt;
                &lt;property name=&quot;pname&quot; value=&quot;美美&quot;/&gt;
                &lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&gt;
            &lt;/bean&gt;
</code></pre><hr>
<p><strong>技术分析之Spring的2.5版本中提供了一种:p名称空间的注入（了解）</strong></p>
<pre><code>1. 步骤一：需要先引入 p 名称空间
    * 在schema的名称空间中加入该行：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;

2. 步骤二：使用p名称空间的语法
    * p:属性名 = &quot;&quot;
    * p:属性名-ref = &quot;&quot;

3. 步骤三：测试
    * &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot; p:pname=&quot;老王&quot; p:car2-ref=&quot;car2&quot;/&gt;
</code></pre><hr>
<p><strong>技术分析之Spring的3.0提供了一种:SpEL注入方式（了解）</strong></p>
<pre><code>1. SpEL：Spring Expression Language是Spring的表达式语言，有一些自己的语法
2. 语法
    * #{SpEL}

3. 例如如下的代码
    &lt;!-- SpEL的方式 --&gt;
    &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot;&gt;
        &lt;property name=&quot;pname&quot; value=&quot;#{&apos;小风&apos;}&quot;/&gt;
        &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt;
    &lt;/bean&gt;

4. 还支持调用类中的属性或者方法
    * 定义类和方法，例如
        public class CarInfo {
            public String getCarname(){
                return &quot;奇瑞QQ&quot;;
            }
        }
</code></pre><hr>
<p><strong>技术分析之数组，集合(List,Set,Map)，Properties等的注入</strong></p>
<pre><code>1. 如果是数组或者List集合，注入配置文件的方式是一样的
    &lt;bean id=&quot;collectionBean&quot; class=&quot;com.vvshyer.demo5.CollectionBean&quot;&gt;
        &lt;property name=&quot;arrs&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;美美&lt;/value&gt;
                &lt;value&gt;小风&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

2. 如果是Set集合，注入的配置文件方式如下：
    &lt;property name=&quot;sets&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;哈哈&lt;/value&gt;
            &lt;value&gt;呵呵&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;

3. 如果是Map集合，注入的配置方式如下：
    &lt;property name=&quot;map&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;老王2&quot; value=&quot;38&quot;/&gt;
            &lt;entry key=&quot;凤姐&quot; value=&quot;38&quot;/&gt;
            &lt;entry key=&quot;如花&quot; value=&quot;29&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;

4. 如果是properties属性文件的方式，注入的配置如下：
    &lt;property name=&quot;pro&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;uname&quot;&gt;root&lt;/prop&gt;
            &lt;prop key=&quot;pass&quot;&gt;123&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
</code></pre><hr>
<p><strong>技术分析之Spring框架的配置文件分开管理（了解）</strong></p>
<pre><code>1. 例如：在src的目录下又多创建了一个配置文件，现在是两个核心的配置文件，那么加载这两个配置文件的方式有两种！
    * 主配置文件中包含其他的配置文件:
        &lt;import resource=&quot;applicationContext2.xml&quot;/&gt;

    * 工厂创建的时候直接加载多个配置文件:
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(
                    &quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;);
</code></pre><hr>
<h3 id="Spring框架整合WEB"><a href="#Spring框架整合WEB" class="headerlink" title="Spring框架整合WEB"></a>Spring框架整合WEB</h3><hr>
<p><strong>Spring框架整合WEB（不是最终的方案）</strong></p>
<pre><code>1. 创建JavaWEB项目，引入Spring的开发包。编写具体的类和方法。
    * 环境搭建好后，启动服务器来测试项目，发送每访问一次都会加载一次配置文件，这样效率会非常非常慢！！

2. 解决上面的问题
    * 将工厂创建好了以后放入到ServletContext域中.使用工厂的时候,从ServletContext中获得.
        * ServletContextListener:用来监听ServletContext对象的创建和销毁的监听器.
        * 当ServletContext对象创建的时候:创建工厂 , 将工厂存入到ServletContext

3. Spring整合Web项目
    * 引入spring-web-4.2.4.RELEASE.jar包
    * 配置监听器
         &lt;!-- 配置Spring的核心监听器: --&gt;
         &lt;listener&gt;
             &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
         &lt;/listener&gt;
         &lt;context-param&gt;
             &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
             &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
         &lt;/context-param&gt;

4. 修改servlet的代码
    * 从ServletContext中获得工厂
    * 具体代码如下
        ServletContext servletContext = ServletActionContext.getServletContext();
        // 需要使用WEB的工厂的方式
        WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        CustomerService cs = (CustomerService) context.getBean(&quot;customerService&quot;);
        cs.save();    
</code></pre><hr>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Spring</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/04/01/Spring4_day01/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-计算机网络笔记03" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/计算机网络笔记03/">计算机网络笔记03</a>
    </h1>
  

        
        <a href="/2017/03/31/计算机网络笔记03/" class="archive-article-date">
  	<time datetime="2017-03-31T11:51:40.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-31</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1-数据链路层的基本概念"><a href="#3-1-数据链路层的基本概念" class="headerlink" title="3.1  数据链路层的基本概念"></a>3.1  数据链路层的基本概念</h2><p>链路：一条无源的点到点的物理线路段，中间没有其他任何交换结点。</p>
<p>数据链路：把实现这些协议的硬件和软件加到链路上，就构成数据链路。</p>
<p>帧：在数据链路层传输的数据单位。</p>
<h4 id="数据链路层的主要功能"><a href="#数据链路层的主要功能" class="headerlink" title="数据链路层的主要功能"></a>数据链路层的主要功能</h4><ul>
<li>链路管理</li>
<li>帧定界</li>
<li>流量控制</li>
<li>差错控制</li>
<li>将数据和控制信息区分开</li>
<li>透明传输</li>
<li>寻址<h2 id="3-2-停止等待协议"><a href="#3-2-停止等待协议" class="headerlink" title="3.2  停止等待协议"></a>3.2  停止等待协议</h2><h3 id="3-2-1-完全理想化的数据传输"><a href="#3-2-1-完全理想化的数据传输" class="headerlink" title="3.2.1 完全理想化的数据传输"></a>3.2.1 完全理想化的数据传输</h3><h3 id="3-2-2-具有最简单流量控制的数据链路层协议"><a href="#3-2-2-具有最简单流量控制的数据链路层协议" class="headerlink" title="3.2.2 具有最简单流量控制的数据链路层协议"></a>3.2.2 具有最简单流量控制的数据链路层协议</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">	在发送结点：</span><br><span class="line">	1.从主机取一个数据帧</span><br><span class="line">	2.将数据帧送到数据链路层的发送缓存</span><br><span class="line">	3.将发送缓存中的数据帧发送出去</span><br><span class="line">	4.等待</span><br><span class="line">	5.若收到由接收结点发过来的信息（格式内容事先商定），则从主机取一个新的数据帧，然后转道到2</span><br><span class="line">	</span><br><span class="line">	在接收结点：</span><br><span class="line">	1.等待</span><br><span class="line">	2.若收到由发送结点发过来的数据帧，则将其放入数据链路层的接收缓存</span><br><span class="line">	3。将接收缓存中的数据帧上交主机</span><br><span class="line">	4.向发送结点发一信息，表示数据帧已经上交给主机</span><br><span class="line">	5.转到1</span><br><span class="line">```### 3.2.3 实用的停止等待协议</span><br><span class="line">![](/assets/network/ch3p01.png)</span><br><span class="line"></span><br><span class="line">重传时间：略大于“从发完数据帧到收到确认帧所需的平均时间”</span><br><span class="line"></span><br><span class="line">解决重复帧的问题：</span><br><span class="line">	* 使每一个数据帧带上不同的发送序号，每发送一个新的数据帧就把它的发送序号加1</span><br><span class="line">	* 若结点B收到发送序号相同的数据帧，就表明出现了重复帧。这时应丢弃重复帧，因为已经收到过同样的数据帧并且也交给了主机B</span><br><span class="line">	* 但此时结点B还必须向A发送确认帧ACK，因为B已经知道A还没收到上一次发过去的确认帧ACK</span><br><span class="line"></span><br><span class="line">帧的编号问题：</span><br><span class="line">	* 对于停止等待协议，由于每发送一个数据帧就停止等待，因此一个比特编号就够了。（表示0和1两种不同的序号）</span><br><span class="line"></span><br><span class="line">数据链路层的停止等待协议采用了有效的检错重传机制，对网络层提供*可靠传输*的服务</span><br><span class="line">### 3.2.4 循环冗余检验的原理</span><br><span class="line">![](/assets/network/ch3p02.png)</span><br><span class="line"></span><br><span class="line">帧检验序列FCS：在数据后面添加上的冗余码称为帧检验序列FCS</span><br><span class="line">### 3.2.5 停止等待协议的算法</span><br><span class="line">* 收发双方实行停止等待</span><br><span class="line">* V(S):发送序号状态变量</span><br><span class="line">* V(R):接收序号状态变量</span><br><span class="line">* N(S):帧的序号</span><br><span class="line">* 序号只占1bit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在发送结点：<br>(1)  从主机取一个数据帧，送交发送缓存。<br>(2)  V(S)←0。<br>(3)  N(S)←V(S)。<br>(4)  将发送缓存中的数据帧发送出去。<br>(5)  设置超时计时器。<br>(6)  等待。    {等待以下三个事件中最先出现的一个}<br>(7)  ACK收到确认帧 ，<br>         从主机取一个新的数据帧，放入发送缓存；<br>           V(S)←[1-V(S)]，转到 (3)。<br>(8)  收到否认帧NAK，<br>         丢弃这个确认帧，转到(4)。<br>(9)  若超时计时器时间到，则转到(4)。</p>
<p>在接收结点：<br>(1)  V(R)←0。<br>(2)  等待。<br>(3)  收到一个数据帧；<br>         若 CRC校验无误<br>             若 N(S) = V(R)，则执行(4)；<br>             否则丢弃此数据帧，然后转到(6)。<br>          否则丢弃此数据帧，发送NAK，然后转到(2)。<br>(4)  将收到的数据帧中的数据部分送交上层软件<br>        （也就是数据链路层模型中的主机）。<br>(5)  V(R)←[1-V(R)]。<br>(6)  发送确认帧ACK，转到(2)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>(1)   从主机取一个数据帧，送交发送缓存。<br>(2)   V(S)←0。<br>(3)   N(S)←V(S)。<br>(4)  将发送缓存中的数据帧发送出去。<br>(5)  设置超时计时器。<br>(6)   等待。<br>(7)  收到确认帧 ACKn，<br>      若 n = 1 – V(s)，则：<br>           从主机取一个新的数据帧，放入发送缓存；<br>           V(S)←[1  V(S)]，转到 (3)。<br>      否则，丢弃这个确认帧，转到(6)。<br>(8)  若超时计时器时间到，则转到(4)。</p>
<p>(1)  V(R)←0。<br>(2)  等待。<br>(3)  收到一个数据帧；<br>          若 CRC校验无误<br>             若 N(S) = V(R)，则执行(4)；<br>             否则丢弃此数据帧，然后转到(6)。<br>          否则丢弃此数据帧，然后转到(2)。<br>(4)  将收到的数据帧中的数据部分送交上层软件<br>(5)  V(R)←[1  V(R)]。<br>(6)  n←V(R)；<br>      发送确认帧 ACKn，转到(2)。<br>```</p>
<h5 id="停止等待协议ARQ的优点缺点"><a href="#停止等待协议ARQ的优点缺点" class="headerlink" title="停止等待协议ARQ的优点缺点"></a>停止等待协议ARQ的优点缺点</h5><ul>
<li>优点：比较简单</li>
<li>缺点：通信信道的利用率不高<h2 id="3-3-连续-ARQ-协议"><a href="#3-3-连续-ARQ-协议" class="headerlink" title="3.3  连续 ARQ 协议"></a>3.3  连续 ARQ 协议</h2><img src="/assets/network/ch3p03.png" alt=""><h3 id="3-3-1-连续-ARQ-协议的工作原理"><a href="#3-3-1-连续-ARQ-协议的工作原理" class="headerlink" title="3.3.1 连续 ARQ 协议的工作原理"></a>3.3.1 连续 ARQ 协议的工作原理</h3><h3 id="3-3-2-连续-ARQ-协议的吞吐量"><a href="#3-3-2-连续-ARQ-协议的吞吐量" class="headerlink" title="3.3.2 连续 ARQ 协议的吞吐量"></a>3.3.2 连续 ARQ 协议的吞吐量</h3><h3 id="3-3-3-滑动窗口的概念"><a href="#3-3-3-滑动窗口的概念" class="headerlink" title="3.3.3 滑动窗口的概念"></a>3.3.3 滑动窗口的概念</h3><h3 id="3-3-4-信道利用率与最佳帧长"><a href="#3-3-4-信道利用率与最佳帧长" class="headerlink" title="3.3.4 信道利用率与最佳帧长"></a>3.3.4 信道利用率与最佳帧长</h3><h2 id="3-4-选择重传-ARQ-协议"><a href="#3-4-选择重传-ARQ-协议" class="headerlink" title="3.4  选择重传 ARQ 协议"></a>3.4  选择重传 ARQ 协议</h2><h2 id="3-5-面向比特的链路层协议-HDLC"><a href="#3-5-面向比特的链路层协议-HDLC" class="headerlink" title="3.5 面向比特的链路层协议 HDLC"></a>3.5 面向比特的链路层协议 HDLC</h2><h5 id="两种链路配置"><a href="#两种链路配置" class="headerlink" title="两种链路配置"></a>两种链路配置</h5></li>
<li>非平衡配置</li>
<li>平衡配置<h5 id="三种响应方式"><a href="#三种响应方式" class="headerlink" title="三种响应方式"></a>三种响应方式</h5></li>
<li>正常响应方式</li>
<li>异步响应方式</li>
<li>异步平衡响应方式<h2 id="3-6-因特网的点对点协议-PPP"><a href="#3-6-因特网的点对点协议-PPP" class="headerlink" title="3.6 因特网的点对点协议 PPP"></a>3.6 因特网的点对点协议 PPP</h2></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">计算机网络</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/31/计算机网络笔记03/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Struts2_day03" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/28/Struts2_day03/">Struts2第三天</a>
    </h1>
  

        
        <a href="/2017/03/28/Struts2_day03/" class="archive-article-date">
  	<time datetime="2017-03-28T11:59:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2017-03-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Struts2第三天"><a href="#Struts2第三天" class="headerlink" title="Struts2第三天"></a>Struts2第三天</h2><hr>
<p><strong>课程回顾：Struts2框架的第二天</strong></p>
<pre><code>1. Servlet的API
    * ActionContext对象
    * ServletActionContext对象

2. 结构类型的跳转
    * 全局结果
    * 局部结构，type属性

3. 数据的封装
    * 属性驱动方式
    * 模型驱动方式

4. 拦截器（自定义拦截器）
</code></pre><hr>
<p><strong>今天的课程内容</strong></p>
<pre><code>1. OGNL表达式（了解）
2. Struts2框架的值栈（值栈、存入值、取值）
3. OGNL的特殊符号
</code></pre><hr>
<h3 id="案例一：使用Struts2框架查询所有的客户功能"><a href="#案例一：使用Struts2框架查询所有的客户功能" class="headerlink" title="案例一：使用Struts2框架查询所有的客户功能"></a>案例一：使用Struts2框架查询所有的客户功能</h3><hr>
<p><strong>需求分析</strong></p>
<pre><code>1. 使用Struts2框架查询所有的客户功能
</code></pre><hr>
<p><strong>技术分析之OGNL表达式概述（了解）</strong></p>
<pre><code>1. OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写
    * 所谓对象图，即以任意一个对象为根，通过OGNL可以访问与这个对象关联的其它对象
    * 通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性

2. Struts2框架使用OGNL作为默认的表达式语言
    * OGNL是一种比EL强大很多倍的语言
    * xwork提供 OGNL表达式
    * ognl-3.0.5.jar

3. OGNL 提供五大类功能
   * 支持对象方法调用
   * 支持类静态的方法调用和值访问
   * 访问OGNL上下文（OGNL context）和ActionContext
   * 支持赋值操作和表达式串联
   * 操作集合对象

4. 测试的代码
    // 访问对象的方法
    @Test
    public void run1() throws OgnlException{
        OgnlContext context = new OgnlContext();
        // 获取对象的方法
        Object obj = Ognl.getValue(&quot;&apos;helloworld&apos;.length()&quot;, context, context.getRoot());
        System.out.println(obj);
    }

    // 获取OGNL上下文件的对象
    @Test
    public void run3() throws OgnlException{
        OgnlContext context = new OgnlContext();
        context.put(&quot;name&quot;, &quot;美美&quot;);
        // 获取对象的方法
        Object obj = Ognl.getValue(&quot;#name&quot;, context, context.getRoot());
        System.out.println(obj);
    }

    // 从root栈获取值
    @Test
    public void demo3() throws OgnlException{
        OgnlContext context = new OgnlContext();
        Customer c = new Customer();
        c.setCust_name(&quot;haha&quot;);
        context.setRoot(c);
        String name = (String) Ognl.getValue(&quot;cust_name&quot;, context, context.getRoot());
        System.out.println(name);
    }
</code></pre><hr>
<p><strong>技术分析之在Struts2框架中使用OGNL表达式</strong></p>
<pre><code>1. Struts2引入了OGNL表达式，主要是在JSP页面中获取值栈中的值
2. 具体在Struts2中怎么使用呢？如下步骤
    * 需要先引入Struts2的标签库
        &gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt;

    * 使用Struts2提供的标签中的标签
        &gt; &lt;s:property value=&quot;OGNL表达式&quot;/&gt;

3. 在JSP页面使用OGNL表达式
    * 访问对象方法
        &lt;s:property value=&quot;&apos;hello&apos;.length()&quot;/&gt;
</code></pre><hr>
<p><strong>技术分析之值栈的概述</strong></p>
<pre><code>1. 问题一：什么是值栈？
    * 值栈就相当于Struts2框架的数据的中转站，向值栈存入一些数据。从值栈中获取到数据。
    * ValueStack 是 struts2 提供一个接口，实现类 OgnlValueStack ---- 值栈对象 （OGNL是从值栈中获取数据的 ）
    * Action是多例的，有一起请求，创建Action实例，创建一个ActionContext对象，代表的是Action的上下文对象，还会创建一个ValueStack对象。
    * 每个Action实例都有一个ValueStack对象 （一个请求 对应 一个ValueStack对象 ）
    * 在其中保存当前Action 对象和其他相关对象
    * Struts 框架把 ValueStack 对象保存在名为 “struts.valueStack” 的请求属性中,request中 （值栈对象 是 request一个属性）
        * ValueStack vs = (ValueStack)request.getAttribute(&quot;struts.valueStack&quot;);
</code></pre><hr>
<p><strong>技术分析之值栈的内部结构</strong></p>
<pre><code>2. 问题二 ： 值栈的内部结构 ？
    * 值栈由两部分组成
        &gt; root        -- Struts把动作和相关对象压入 ObjectStack 中--List
        &gt; context      -- Struts把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中

    * Struts会默认把下面这些映射压入ContextMap（context）中
        * 注意：request代表的是Map集合的key值，value的值其实也是一个Map集合。

        &gt; parameters: 该 Map 中包含当前请求的请求参数  ?name=xxx&amp;password=123
        &gt; request: 该 Map 中包含当前 request 对象中的所有属性
        &gt; session: 该 Map 中包含当前 session 对象中的所有属性
        &gt; application:该 Map 中包含当前 application  对象中的所有属性
        &gt; attr: 该 Map 按如下顺序来检索某个属性: request, session, application

    * ValueStack中 存在root属性 (CompoundRoot) 、 context 属性 （OgnlContext ）
        &gt; CompoundRoot 就是ArrayList
        &gt; OgnlContext 就是 Map

    * context 对应Map 引入 root对象 
        &gt; context中还存在 request、 session、application、 attr、 parameters 对象引用 
        &gt; OGNL表达式访问值栈中的数据
            * 访问root中数据时 不需要 #
            * 访问 request、 session、application、 attr、 parameters 对象数据 必须写 # 

        &gt; 操作值栈 默认指 操作 root 元素
</code></pre><p><img src="/assets/struts203/01-值栈的内部结构.bmp" alt="">    </p>
<hr>
<p><strong>技术分析之值栈的创建和ActionContext对象的关系</strong></p>
<pre><code>3. 问题三 ： 值栈对象的创建，ValueStack 和 ActionContext 是什么关系？
    * 值栈对象是请求时创建的
    * ActionContext是绑定到当前的线程上，那么在每个拦截器或者Action中获取到的ActionContext是同一个。
    * ActionContext中存在一个Map集合，该Map集合和ValueStack的context是同一个地址。
    * ActionContext中可以获取到ValueStack的引用，以后再开发，使用ActionContext来获取到值栈对象
</code></pre><hr>
<p><strong>技术分析之获取到值栈的对象</strong></p>
<pre><code>4. 问题四 ： 如何获得值栈对象
    * 获得值栈对象 有三种方法
        * ValueStack vs1 = (ValueStack) ServletActionContext.getRequest().getAttribute(&quot;struts.valueStack&quot;);
        * ValueStack vs2 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);
        * ValueStack vs3 = ActionContext.getContext().getValueStack();
</code></pre><hr>
<p><strong>技术分析之向值栈中保存数据</strong></p>
<pre><code>5. 问题五： 向值栈保存数据 （主要针对root栈）
    &gt; valueStack.push(Object obj);
        * push方法的底层调用root对象的push方法（把元素添加到0位置）

    &gt; valueStack.set(String key, Object obj);
        * 源码获取map集合（map有可能是已经存在的，有可能是新创建的），把map集合push到栈顶，再把数据存入到map集合中。

    &gt; 在jsp中 通过 &lt;s:debug /&gt; 查看值栈的内容
</code></pre><hr>
<p><strong>技术分析之从值栈中获取值</strong></p>
<pre><code>6. 问题六： 在JSP中获取值栈的数据
    * 总结几个小问题：
        &gt; 访问root中数据 不需要#
        &gt; 访问context其它对象数据 加 #
        &gt; 如果向root中存入对象的话，优先使用push方法。
        &gt; 如果向root中存入集合的话，优先要使用set方法。

    * 在OgnlContext中获取数据
        &gt; 在Action中向域对象中存入值
        &gt; request:&lt;s:property value=&quot;#request.username&quot;/&gt;
        &gt; session:&lt;s:property value=&quot;#session.username&quot;/&gt;
        &gt; application:&lt;s:property value=&quot;#application.username&quot;/&gt;
        &gt; attr:&lt;s:property value=&quot;#attr.username&quot;/&gt;
        &gt; parameters:&lt;s:property value=&quot;#parameters.cid&quot;/&gt;

6.1 代码如下
    &lt;!--
        // vs.push(&quot;美美&quot;);
        // 获取到栈顶的值
        &lt;s:property value=&quot;[0].top&quot;/&gt;
    --&gt;

    &lt;!--
        // 栈顶是map集合，通过key获取值
        vs.set(&quot;msg&quot;, &quot;小凤&quot;);
        &lt;s:property value=&quot;[0].top.msg&quot;/&gt;
    --&gt;

    &lt;!--  
        vs.push(user);
        // 栈顶放user对象
        &lt;s:property value=&quot;[0].top.username&quot;/&gt;
        &lt;s:property value=&quot;[0].top.password&quot;/&gt;
        // [0].top 关键字是可以省略的  findValue()
        &lt;s:property value=&quot;username&quot;/&gt;
    --&gt;

    &lt;!--
        vs.set(&quot;user&quot;, user);
        &lt;s:property value=&quot;[0].top.user.username&quot;/&gt;
        &lt;s:property value=&quot;[0].top.user.password&quot;/&gt;
        // 省略关键字
        &lt;s:property value=&quot;user.username&quot;/&gt;
    --&gt;

    &lt;!--  
        // 在ValueStack1Action提供了成员的属性
        private User user = new User(&quot;小泽&quot;,&quot;456&quot;);
        public User getUser() {
            return user;
        }
        public void setUser(User user) {
            this.user = user;
        }

        User user = new User(&quot;小苍&quot;,&quot;123&quot;);
        vs.set(&quot;user&quot;, user);
        // 从栈顶开始查找，找user的属性，显示名称    返回的小苍
        &lt;s:property value=&quot;user.username&quot;/&gt;

        // [1].top获取ValueStack1Action [1].top.user返回user对象  [1].top.user.username获取对象的属性名称
        &lt;s:property value=&quot;[1].top.user.username&quot;/&gt;
    --&gt;

    &lt;!--  
        栈顶是list集合
        vs.push(ulist);
        &lt;s:property value=&quot;[0].top[0].username&quot;/&gt;
        &lt;s:property value=&quot;[0].top[1].username&quot;/&gt;
    --&gt;

    &lt;!--
        vs.set(&quot;ulist&quot;, ulist);
        &lt;s:property value=&quot;ulist[0].username&quot;/&gt;
    --&gt;

    &lt;!-- 迭代的标签 
        属性
            * value    要迭代的集合，需要从值栈中获取
            * var    迭代过程中，遍历的对象
                * var编写上，把迭代产生的对象默认压入到context栈中，从context栈取值，加#号
                * var不编写，默认把迭代产生的对象压入到root栈中

        for(User user:ulist){}    
        // 编写var的属性
        &lt;s:iterator value=&quot;ulist&quot; var=&quot;u&quot;&gt;
            &lt;s:property value=&quot;#u.username&quot;/&gt;
            &lt;s:property value=&quot;#u.password&quot;/&gt;
        &lt;/s:iterator&gt;

        // 没有编写var关键字
        &lt;s:iterator value=&quot;ulist&quot;&gt;
            &lt;s:property value=&quot;username&quot;/&gt;
            &lt;s:property value=&quot;password&quot;/&gt;
        &lt;/s:iterator&gt;
    --&gt;

    &lt;!-- 从context栈中获取值，加#号

    HttpServletRequest request = ServletActionContext.getRequest();
    request.setAttribute(&quot;msg&quot;, &quot;美美&quot;);
    request.getSession().setAttribute(&quot;msg&quot;, &quot;小风&quot;);

    &lt;s:property value=&quot;#request.msg&quot;/&gt;
    &lt;s:property value=&quot;#session.msg&quot;/&gt;
    &lt;s:property value=&quot;#parameters.id&quot;/&gt;
    &lt;s:property value=&quot;#attr.msg&quot;/&gt;
    --&gt;

    &lt;!-- 在JSP页面上，查看值栈的内部结构 --&gt;
    &lt;s:debug&gt;&lt;/s:debug&gt;
</code></pre><hr>
<p><strong>技术分析之EL表达式也会获取到值栈中的数据</strong></p>
<pre><code>7. 问题七：为什么EL也能访问值栈中的数据？
    * StrutsPreparedAndExecuteFilter的doFilter代码中 request = prepare.wrapRequest(request);     
        &gt; 对Request对象进行了包装 ，StrutsRequestWrapper
        &gt; 增强了request的 getAttribute
            Object attribute = super.getAttribute(s);
            if (attribute == null) {
               attribute = stack.findValue(s);
            }
           &gt; 访问request范围的数据时，如果数据找不到，去值栈中找 
        &gt; request对象 具备访问值栈数据的能力 （查找root的数据）
</code></pre><hr>
<p><strong>总结OGNL表达式的特殊的符号</strong></p>
<pre><code>1. # 符号的用法
    * 获得contextMap中的数据
        &gt; &lt;s:property value=&quot;#request.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#session.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#application.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#attr.name&quot;/&gt;
        &gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt;
        &gt; &lt;s:property value=&quot;#parameters.name&quot;/&gt;

    * 构建一个map集合
        * 例如：
            * &lt;s:radio name=&quot;sex&quot; list=&quot;{&apos;男&apos;,&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt;
            * &lt;s:radio name=&quot;sex&quot; list=&quot;#{&apos;0&apos;:&apos;男&apos;,&apos;1&apos;:&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt;

2. % 符号的用法
    * 强制字符串解析成OGNL表达式。
        &gt; 例如：在request域中存入值，然后在文本框（&lt;s:textfield&gt;）中取值，现在到value上。
        &gt; &lt;s:textfield value=&quot;%{#request.msg}&quot;/&gt;

    * { }中值用&apos;&apos;引起来,此时不再是ognl表达式,而是普通的字符串
        &gt; 例如：&lt;s:property value=&quot;%{&apos;#request.msg&apos;}&quot;/&gt;

3. $ 符号的用法
    * 在配置文件中可以使用OGNL表达式，例如：文件下载的配置文件。
        &lt;action name=&quot;download1&quot; class=&quot;cn.itcast.demo2.DownloadAction&quot;&gt;
            &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt;
                &lt;param name=&quot;contentType&quot;&gt;${contentType}&lt;/param&gt;
                &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${downFilename}&lt;/param&gt;
            &lt;/result&gt;
        &lt;/action&gt;
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Struts2</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2017/03/28/Struts2_day03/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 SUN Huayan
			</div>
			<div class="footer-center">
				<a href="http://www.miitbeian.gov.cn/">苏ICP备18005860号</a>
			</div>
			<div class="footer-right">
				<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
			</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p="./",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,d.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function f(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function c(t,n,e,r,o){var i=u(t),c=f(t)-n;if(c-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||c)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");c(t,document.body.scrollTop,-63,2,0),c(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}function l(){x.default.versions.mobile&&window.screen.width<800&&(i(),s())}var p=e(71),d=r(p),v=e(72),y=(r(v),e(84)),h=r(y),b=e(69),x=r(b),m=e(75),g=r(m),w=e(70);l(),(0,w.addLoadEvent)(function(){g.default.init()}),t.exports={}},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n,e){var r=e(49),o=e(15);t.exports=function(t){return r(o(t))}},function(t,n,e){t.exports=!e(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,e){var r=e(6),o=e(12);t.exports=e(4)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(10),o=e(30),i=e(24),u=Object.defineProperty;n.f=e(4)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(22)("wks"),o=e(13),i=e(1).Symbol,u="function"==typeof i,f=t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=r},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(35),o=e(16);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(11);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(6).f,o=e(2),i=e(7)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(22)("keys"),o=e(13);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(1),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n,e){var r=e(11);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n,e){var r=e(1),o=e(14),i=e(18),u=e(26),f=e(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||f(n,t,{value:u.f(t)})}},function(t,n,e){n.f=e(7)},function(t,n,e){var r=e(1),o=e(14),i=e(46),u=e(5),f="prototype",c=function(t,n,e){var a,s,l,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,h=t&c.B,b=t&c.W,x=d?o:o[n]||(o[n]={}),m=x[f],g=d?r:v?r[n]:(r[n]||{})[f];d&&(e=n);for(a in e)s=!p&&g&&void 0!==g[a],s&&a in x||(l=s?g[a]:e[a],x[a]=d&&"function"!=typeof g[a]?e[a]:h&&s?i(l,r):b&&g[a]==l?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n[f]=t[f],n}(l):y&&"function"==typeof l?i(Function.call,l):l,y&&((x.virtual||(x.virtual={}))[a]=l,t&c.R&&m&&!m[a]&&u(m,a,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(11),o=e(1).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){t.exports=!e(4)&&!e(8)(function(){return 7!=Object.defineProperty(e(29)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){"use strict";var r=e(18),o=e(27),i=e(36),u=e(5),f=e(2),c=e(17),a=e(51),s=e(20),l=e(58),p=e(7)("iterator"),d=!([].keys&&"next"in[].keys()),v="@@iterator",y="keys",h="values",b=function(){return this};t.exports=function(t,n,e,x,m,g,w){a(e,n,x);var O,S,_,j=function(t){if(!d&&t in A)return A[t];switch(t){case y:return function(){return new e(this,t)};case h:return function(){return new e(this,t)}}return function(){return new e(this,t)}},P=n+" Iterator",E=m==h,M=!1,A=t.prototype,T=A[p]||A[v]||m&&A[m],L=T||j(m),N=m?E?j("entries"):L:void 0,C="Array"==n?A.entries||T:T;if(C&&(_=l(C.call(new t)),_!==Object.prototype&&(s(_,P,!0),r||f(_,p)||u(_,p,b))),E&&T&&T.name!==h&&(M=!0,L=function(){return T.call(this)}),r&&!w||!d&&!M&&A[p]||u(A,p,L),c[n]=L,c[P]=b,m)if(O={values:E?L:j(h),keys:g?L:j(y),entries:N},w)for(S in O)S in A||i(A,S,O[S]);else o(o.P+o.F*(d||M),n,O);return O}},function(t,n,e){var r=e(10),o=e(55),i=e(16),u=e(21)("IE_PROTO"),f=function(){},c="prototype",a=function(){var t,n=e(29)("iframe"),r=i.length,o="<",u=">";for(n.style.display="none",e(48).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),a=t.F;r--;)delete a[c][i[r]];return a()};t.exports=Object.create||function(t,n){var e;return null!==t?(f[c]=r(t),e=new f,f[c]=null,e[u]=t):e=a(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(35),o=e(16).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,e){var r=e(2),o=e(3),i=e(45)(!1),u=e(21)("IE_PROTO");t.exports=function(t,n){var e,f=o(t),c=0,a=[];for(e in f)e!=u&&r(f,e)&&a.push(e);for(;n.length>c;)r(f,e=n[c++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){t.exports=e(5)},function(t,n,e){var r=e(15);t.exports=function(t){return Object(r(t))}},function(t,n,e){t.exports={default:e(41),__esModule:!0}},function(t,n,e){t.exports={default:e(42),__esModule:!0}},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(39),i=r(o),u=e(38),f=r(u),c="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};n.default="function"==typeof f.default&&"symbol"===c(i.default)?function(t){return"undefined"==typeof t?"undefined":c(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":c(t)}},function(t,n,e){e(65),e(63),e(66),e(67),t.exports=e(14).Symbol},function(t,n,e){e(64),e(68),t.exports=e(26).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,e){var r=e(3),o=e(61),i=e(60);t.exports=function(t){return function(n,e,u){var f,c=r(n),a=o(c.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if(f=c[s++],f!=f)return!0}else for(;a>s;s++)if((t||s in c)&&c[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(43);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,e){var r=e(9),o=e(34),i=e(19);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,f=e(t),c=i.f,a=0;f.length>a;)c.call(t,u=f[a++])&&n.push(u);return n}},function(t,n,e){t.exports=e(1).document&&document.documentElement},function(t,n,e){var r=e(28);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n,e){var r=e(28);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){"use strict";var r=e(32),o=e(12),i=e(20),u={};e(5)(u,e(7)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){var r=e(9),o=e(3);t.exports=function(t,n){for(var e,i=o(t),u=r(i),f=u.length,c=0;f>c;)if(i[e=u[c++]]===n)return e}},function(t,n,e){var r=e(13)("meta"),o=e(11),i=e(2),u=e(6).f,f=0,c=Object.isExtensible||function(){return!0},a=!e(8)(function(){return c(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++f,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&s(t),t},v=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(6),o=e(10),i=e(9);t.exports=e(4)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),f=u.length,c=0;f>c;)r.f(t,e=u[c++],n[e]);return t}},function(t,n,e){var r=e(19),o=e(12),i=e(3),u=e(24),f=e(2),c=e(30),a=Object.getOwnPropertyDescriptor;n.f=e(4)?a:function(t,n){if(t=i(t),n=u(n,!0),c)try{return a(t,n)}catch(t){}if(f(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n,e){var r=e(3),o=e(33).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(r(t))}},function(t,n,e){var r=e(2),o=e(37),i=e(21)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(23),o=e(15);t.exports=function(t){return function(n,e){var i,u,f=String(o(n)),c=r(e),a=f.length;return c<0||c>=a?t?"":void 0:(i=f.charCodeAt(c),i<55296||i>56319||c+1===a||(u=f.charCodeAt(c+1))<56320||u>57343?t?f.charAt(c):i:t?f.slice(c,c+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,n,e){var r=e(23),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(23),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){"use strict";var r=e(44),o=e(52),i=e(17),u=e(3);t.exports=e(31)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){},function(t,n,e){"use strict";var r=e(59)(!0);e(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){"use strict";var r=e(1),o=e(2),i=e(4),u=e(27),f=e(36),c=e(54).KEY,a=e(8),s=e(22),l=e(20),p=e(13),d=e(7),v=e(26),y=e(25),h=e(53),b=e(47),x=e(50),m=e(10),g=e(3),w=e(24),O=e(12),S=e(32),_=e(57),j=e(56),P=e(6),E=e(9),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k="prototype",F=d("_hidden"),q=d("toPrimitive"),I={}.propertyIsEnumerable,B=s("symbol-registry"),D=s("symbols"),W=s("op-symbols"),H=Object[k],K="function"==typeof L,R=r.QObject,J=!R||!R[k]||!R[k].findChild,U=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(H,n);r&&delete H[n],A(t,n,e),r&&t!==H&&A(H,n,r)}:A,G=function(t){var n=D[t]=S(L[k]);return n._k=t,n},$=K&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},z=function(t,n,e){return t===H&&z(W,n,e),m(t),n=w(n,!0),m(e),o(D,n)?(e.enumerable?(o(t,F)&&t[F][n]&&(t[F][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,F)||A(t,F,O(1,{})),t[F][n]=!0),U(t,n,e)):A(t,n,e)},Y=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)z(t,e=r[o++],n[e]);return t},Q=function(t,n){return void 0===n?S(t):Y(S(t),n)},X=function(t){var n=I.call(this,t=w(t,!0));return!(this===H&&o(D,t)&&!o(W,t))&&(!(n||!o(this,t)||!o(D,t)||o(this,F)&&this[F][t])||n)},V=function(t,n){if(t=g(t),n=w(n,!0),t!==H||!o(D,n)||o(W,n)){var e=M(t,n);return!e||!o(D,n)||o(t,F)&&t[F][n]||(e.enumerable=!0),e}},Z=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(D,n=e[i++])||n==F||n==c||r.push(n);return r},tt=function(t){for(var n,e=t===H,r=T(e?W:g(t)),i=[],u=0;r.length>u;)!o(D,n=r[u++])||e&&!o(H,n)||i.push(D[n]);return i};K||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===H&&n.call(W,e),o(this,F)&&o(this[F],t)&&(this[F][t]=!1),U(this,t,O(1,e))};return i&&J&&U(H,t,{configurable:!0,set:n}),G(t)},f(L[k],"toString",function(){return this._k}),j.f=V,P.f=z,e(33).f=_.f=Z,e(19).f=X,e(34).f=tt,i&&!e(18)&&f(H,"propertyIsEnumerable",X,!0),v.f=function(t){return G(d(t))}),u(u.G+u.W+u.F*!K,{Symbol:L});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;nt.length>et;)d(nt[et++]);for(var nt=E(d.store),et=0;nt.length>et;)y(nt[et++]);u(u.S+u.F*!K,"Symbol",{for:function(t){return o(B,t+="")?B[t]:B[t]=L(t)},keyFor:function(t){if($(t))return h(B,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){J=!0},useSimple:function(){J=!1}}),u(u.S+u.F*!K,"Object",{create:Q,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:V,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),N&&u(u.S+u.F*(!K||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!$(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!$(n))return n}),r[1]=n,C.apply(N,r)}}}),L[k][q]||e(5)(L[k],q,L[k].valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){e(25)("asyncIterator")},function(t,n,e){e(25)("observable")},function(t,n,e){e(62);for(var r=e(1),o=e(5),i=e(17),u=e(7)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],c=0;c<5;c++){var a=f[c],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=e(40),i=r(o),u=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):o[t]||t}function n(t){return l[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,r=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},f=/\u00a0/g,c=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var p in o)l[o[p]]=p;return o["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(r,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(c,"\n").replace(e,t).replace(f," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=u.encodeObject(t[n]);else if("object"==("undefined"==typeof t?"undefined":(0,i.default)(t)))for(var r in t)t[r]=u.encodeObject(t[r]);else if("string"==typeof t)return u.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=u},function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},,,function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){var n=document.querySelectorAll(".article-entry a:not(.article-more-a)");n.forEach(function(t){t.setAttribute("target","_blank")})}var e=document.querySelector("#js-aboutme");e&&0!==e.length&&(e.innerHTML=e.innerText)}t.exports={init:e}},,,,,,,,,function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e}])</script><script src="/./main.2d7529.js"></script><script>!function(){var e=function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)};e("/slider.885efe.js")}()</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">了解我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">CCF</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Hibernate</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">iOS MAC Object-C</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Oracle</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Spring</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Struts2</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">CS231n</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">English</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">数学</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">FTP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">研究生之路</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Gradle</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法 | 数学</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">计算机网络</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Deep Learning</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">软件工程</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://www.nju.edu.cn/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>南京大学</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.hlju.edu.cn/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>黑龙江大学</a>
            </li>
          
            <li class="search-li">
              <a href="https:/www.google.com//" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>Google</a>
            </li>
          
            <li class="search-li">
              <a href="http://www.baidu.com/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>百度</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">在读软件工程研究生蒻🐔一只。</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>