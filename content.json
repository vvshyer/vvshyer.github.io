[{"title":"CCF之201612-3权限查询","date":"2017-03-16T09:51:05.000Z","path":"2017/03/16/CCF之201612-3权限查询/","text":"授权查询####问题描述 授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。 本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。 具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。 给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类： 不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限； 分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限； 分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。输入格式 输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 category:level，其中 category是权限类名，level&gt;是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。 接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为 &lt;role&gt; &lt;s&gt; &lt;privilege 1&gt; &lt;privilege 2&gt; ... &lt;privilege s&gt; 其中 role 是角色名称，s 表示该角色具有多少种权限。后面 s 个字符串描述该角色具有的权限，格式同 P 段。 接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为 &lt;user&gt; &lt;t&gt; &lt;role 1&gt; &lt;role 2&gt; ... &lt;role t&gt; 其中 user 是用户名，t 表示该用户具有多少种角色。后面 t 个字符串描述该用户具有的角色。 接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 user privilege，表示查询用户 user 是否具有 privilege 权限。如果查询的权限是分等级权限，则查询中的 privilege 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。输出格式 输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。 样例输入 12345678910111213141516171819202122233crm:2git:3game4hr 1 crm:2it 3 crm:1 git:1 gamedev 2 git:3 gameqa 1 git:23alice 1 hrbob 2 it qacharlie 1 dev9alice gamealice crm:2alice git:0bob gitbob poweroffcharlie gamecharlie crmcharlie git:3malice game 样例输出 123456789falsetruefalse2falsetruefalsetruefalse 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package com.main;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); //输入权限类别的数量 int p = cin.nextInt(); Privi[] arrayPrivi = new Privi[p]; //输入各个权限 for (int i = 0; i &lt; p; i++) &#123; arrayPrivi[i] = new Privi(cin.next()); &#125; // 输入角色数量 int r = cin.nextInt(); Role[] arrayRole = new Role[r]; //输入每个角色信息 for (int i = 0; i &lt; r; i++) &#123; String name = cin.next(); //角色名 int countrole = cin.nextInt(); //角色拥有的权限数 Role ro = new Role(name, countrole); //输入该角色具有的权限 for (int j = 0; j &lt; countrole; j++) &#123; ro.addPrivi(j, new Privi(cin.next())); &#125; arrayRole[i] = ro; &#125; //输入用户数量 int u = cin.nextInt(); User[] arrayUser = new User[u]; //输入每个用户信息 for (int i = 0; i &lt; u; i++) &#123; String name = cin.next(); //用户名 int countrole = cin.nextInt(); //用户拥有角色数 User us = new User(name,countrole); //输入该用户具有的角色 for (int j = 0; j &lt; countrole; j++) &#123; us.addRole(j, roleFactory(arrayRole,cin.next())); &#125; arrayUser[i] = us; &#125; //输入权限查询数量 int q = cin.nextInt(); Query[] arrayQuery = new Query[q]; for (int i = 0; i &lt; q; i++) &#123; //输入查询用户和是否具有的权限 arrayQuery[i] = new Query(cin.next(),cin.next()); &#125; cin.close(); //查询 StringBuilder sb = new StringBuilder(); for (Query query : arrayQuery) &#123; //查询结果拼接 sb.append(check(query,arrayUser) + \"\\n\"); &#125; //输出查询结果 System.out.println(sb.toString()); &#125; //角色工厂，如果已存在该角色直接返回，否则返回null private static Role roleFactory(Role[] arrayRole,String name) &#123; for(Role role : arrayRole) &#123; if(name.equals(role.getName())) &#123; return role; &#125; &#125; return null; &#125; //查询 private static String check(Query query,User[] arrayUser) &#123; int flag = -3; String uname = query.qUserName; Privi up = query.qPrivi; for (User user : arrayUser) &#123; flag = -3; //找是否存在该用户 if (uname.equals(user.getName())) &#123; Role[] userRoleArr = user.getRoleArray(); //是否有该角色 for (Role role : userRoleArr) &#123; Privi[] userRolePriviArr = role.getPriviArray(); //是否有该权限，取权限最高级 for (Privi privi : userRolePriviArr) &#123; int temp = up.equals(privi); flag = (temp &gt; flag) ? temp : flag; if(flag == -1) return \"true\"; &#125; &#125; break; &#125; &#125; if (flag == -2 || flag == -3) &#123; return \"false\"; &#125; else return flag + \"\"; &#125; static class Query &#123; public String qUserName; public Privi qPrivi; Query(String username, String Priviname) &#123; this.qUserName = username; this.qPrivi = new Privi(Priviname); &#125; &#125;&#125;class Privi &#123; private String name; private int level; public Privi() &#123;&#125; public Privi(String per) &#123; String[] p = per.split(\":\"); if (p.length == 1) &#123; Privi.this.name = p[0]; Privi.this.level = -1; &#125; else if (p.length == 2) &#123; Privi.this.name = p[0]; Privi.this.level = Integer.parseInt(p[1]); &#125; &#125; public String getName() &#123; return this.name; &#125; public void setName(String s) &#123; this.name = s; &#125; public int getLevel() &#123; return this.level; &#125; public void setLevel(int l) &#123; this.level = l; &#125; public int equals(Privi p) &#123; if (this.name.equals(p.getName())) &#123; if(this.level == -1 &amp;&amp; this.level &lt; p.getLevel()) return p.getLevel(); else if(this.level == -1 &amp;&amp; p.getLevel() == -1) return -1;//bufendengji else if(this.level != -1 &amp;&amp; this.level &lt;= p.getLevel() ) return -1;//fendengji else return -2; // &#125; else return -2; &#125; public String toString() &#123; return this.name +(this.level != -1 ? (\":\" + this.level) : \"\"); &#125;&#125;class Role &#123; private String name; private int countPrivi; private Privi[] arrPrivi; public Role() &#123; this.name = \"\"; &#125; public Role(String n,int count) &#123; this.name = n; this.countPrivi = count; this.arrPrivi = new Privi[count]; &#125; public String getName() &#123; return this.name; &#125; public void setName(String s) &#123; this.name = s; &#125; public int getPriviCount() &#123; return this.arrPrivi.length; &#125; public Privi[] getPriviArray() &#123; return this.arrPrivi; &#125; public void addPrivi(int n,Privi p) &#123; this.arrPrivi[n] = p; &#125; public String toString() &#123; String s = this.name + \"~\" ; for(Privi p : this.arrPrivi) &#123; s += p.toString() + \"+\"; &#125; return s; &#125;&#125;class User &#123; private String name; private int countRole; private Role[] arrRole; public User() &#123; this.name = \"\"; &#125; public User(String name, int count) &#123; this.name = name; this.countRole = count; this.arrRole = new Role[count]; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Role[] getRoleArray() &#123; return this.arrRole; &#125; public void addRole(int n, Role role) &#123; this.arrRole[n] = role; &#125; public String toString() &#123; String s = name + \"~\"; for(Role role : arrRole) &#123; s += role.toString() + \"+\"; &#125; return s; &#125;&#125;","tags":[{"name":"CCF","slug":"CCF","permalink":"https://vvshyer.com/tags/CCF/"}]},{"title":"算法之回文串","date":"2017-03-16T08:33:21.000Z","path":"2017/03/16/算法之最长回文串/","text":"1088 最长回文字串回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。输入一个字符串Str，输出Str里最长回文子串的长度。 Input 输入Str（Str的长度 &lt;= 1000) Output 输出最长回文子串的长度L。 从中心向两边扩展12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Main&#123; public static char[] arr = new char[1001]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); String str = cin.nextLine(); arr = str.toCharArray(); int res = 0; for (int i = 0; i &lt; str.length();i++)&#123; for (int j = 0; (i-j)&gt;=0 &amp;&amp; (i+j)&lt;str.length();j++) &#123; if (arr[i - j] != arr[i + j]) &#123; break; &#125; int tmp = 2 * j + 1; if (tmp &gt;= res) &#123; res = tmp; &#125; &#125; for (int j = 0; (i-j)&gt;=0 &amp;&amp; (i+j+1)&lt;str.length();j++) &#123; if (arr[i - j] != arr[i + j + 1]) &#123; break; &#125; int tmp = 2 * j + 2; if (tmp &gt;= res) &#123; res = tmp; &#125; &#125; &#125; System.out.println(res); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"算法之背包问题","date":"2017-03-16T06:17:23.000Z","path":"2017/03/16/算法之背包问题/","text":"1085 背包问题在N件物品取出若干件放在容量为V的背包里，每件物品的体积为C1，C2……Cn（Ci为整数），与之相对应的价值为W1,W2……Wn（Wi为整数）。求背包能够容纳的最大价值。 Input 第1行，2个整数，N和V中间用空格隔开。N为物品的数量，V为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= V &lt;= 10000) 第2 - N + 1行，每行2个整数，Ci和Wi，分别是物品的体积和物品的价值。(1 &lt;= Ci, Wi &lt;= 10000) Output 输出可以容纳的最大价值。 基本思路这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用自问题定义状态：即 F[i,v] = max{F[i-1,v],F[i-1,v-Ci] + Wi} 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由他衍生出来的。所以有必要将它仔细解释一下：“将前i件物品放入容量为v的背包中“这个字问题，若只考虑第i件物品的策略，那么就可以转化为一个只和前i-1件物品相关的问题。如果不放第i件物品，那么问题就转换为“前i-1件物品放入容量为v的背包中“，价值为F[i-1,v]；如果放第i件物品，那么问题就转换为“前i-1件物品放入剩下的容量为v-Ci的背包中，此时能获得的最大价值就是F[i-1,v-Ci]再加上通过放入第i件物品获得的价值Wi。 12F[0,0..V] ← 0for i←1 to N for v←Ci to V F[i,v] ← max&#123;F[i−1,v], F[i−1,v−Ci] + Wi&#125; 优化空间复杂度以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该不能再优化了，但空间复杂度却可以优化到O(V)。 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i ← 1…N，每次算出二维数组F[i,0…V]的所有值。那么，如果只用一个数组F[0…V]，能不能保证第i次循环结束后F[v]中表示的就是我们定义的状态F[i,v]呢？F[i,v]是由F[i-1,v]和F[i-1,v-Ci]两个字问题递推而来，能否保证在推F[i,v]时能够取用F[i-1,v]和F[i-1,v-Ci]的值呢？ 事实上，这要求在每次主循环中我们以 v ← V…0 的递减顺序计算F[v]，这样才能保证计算F[v]时F[v - Ci]保存的事状态F[i-1,v-Ci]的值。伪代码如下: 1F[0..V] ← 0 for i←1 to N for v←V to Ci F[v] ← max&#123;F[v], F[v−Ci] + Wi&#125; 其中的 F[v] ← max{F[v], F[v−Ci] + Wi} 一句，恰就对应于我们原来的转移方程，因为现在的F[v-Ci]就相当于原来的F[i-1,v-Ci]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了F[i,v]由F[i,v-Ci]推导得到，与题意不符。 事实上，使用以为数组解01背包问题在后面多次用到，以后不再说明。 12def ZeroOnePack(F,C,W) for v ← V to C F[v] ← max(F[v], F[v−C] + W) 有了这个，01背包问题的伪代码可以这么写： 1F [0..V ] ← 0 for i ← 1 to N ZeroOnePack(F, Ci, Wi) 初始化的细节问题我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目 要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。 如果是第一种问法，要求恰好装满背包，那么在初始化时除了 F[0] 为 0，其它 F [1..V ] 均设为 −∞，这样就可以保证最终得到的 F [V ] 是一种恰好装满背包的最优解。 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F [0..V ] 全部设为 0。 这是为什么呢?可以这样理解:初始化的 F 数组事实上就是在没有任何物品可以放 入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什 么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于 未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包 都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0 了。 这个小技巧完全可以推广到其它类型的背包问题，后面不再对进行状态转移之前的 初始化进行讲解。 一个常数优化上面伪代码中的 for i←1 to N for v←V to Ci 中第二重循环的下限可以改进。它可以被优化为 for i←1 to N for v←V to max(V−ΣNi Wi,Ci) 这个优化之所以成立的原因请读者自己思考。(提示:使用二维的转移方程思考较易。) 小结01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成 01 背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及空间复杂度怎样被优化。","tags":[{"name":"算法 | 数学","slug":"算法-数学","permalink":"https://vvshyer.com/tags/算法-数学/"}]},{"title":"数学基础之中国剩余定理","date":"2017-03-15T14:06:54.000Z","path":"2017/03/15/数学基础之中国剩余定理/","text":"1079 中国剩余定理一个正整数K，给出K Mod 一些质数的结果，求符合条件的最小的K。例如，K % 2 = 1, K % 3 = 2, K % 5 = 3。符合条件的最小的K = 23。 Input 第1行：1个数N表示后面输入的质数及模的数量。（2 &lt;= N &lt;= 10) 第2 - N + 1行，每行2个数P和M，中间用空格分隔，P是质数，M是K % P的结果。（2 &lt;= P &lt;= 100, 0 &lt;= K &lt; P) Output 输出符合条件的最小的K。数据中所有K均小于10^9。 例7：一个班学生分组做游戏，如果每组三人就多两人，每组五人就多三人，每组七人就多四人，问这个班有多少学生? 题目可以看成，除3余2，除5余3，除7余4。没有同余的情况，用的方法是“逐步约束法”，就是从“除7余4的数”中找出符合“除5余3的数”，就是再7上一直加7，直到所得的数除5余3。得出数为18，下面只要在18上一直加7和5得最小公倍数35，直到满足“除3余2” 4+7=11 11+7=18 18+35=53 在第一个余数的基础上，加上最小公倍数，如果取余得到要求得余数就取该值（最小） 1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static int[] P = new int[10]; public static int[] M = new int[10]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int N = cin.nextInt(); for (int i = 0;i &lt; N;i++)&#123; P[i] = cin.nextInt(); M[i] = cin.nextInt(); &#125; int j; int s= 1, k = M[0]; for (int i = 0;i &lt; N-1;i++)&#123; s = s * P[i]; while (k % P[i+1] != M[i+1])&#123; k+=s; &#125; &#125; System.out.println(k); &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"数学基础之约瑟夫环","date":"2017-03-15T14:01:39.000Z","path":"2017/03/15/数学基础之约瑟夫环/","text":"1073 约瑟夫环N个人坐成一个圆环（编号为1 - N），从第1个人开始报数，数到K的人出列，后面的人重新从1开始报数。问最后剩下的人的编号。 例如：N = 3，K = 2。2号先出列，然后是1号，最后剩下的是3号。 Input 2个数N和K，表示N个人，数到K出列。(2 &lt;= N, K &lt;= 10^6) Output 最后剩下的人的编号 解法一：思路：建立一个有N个元素的循环链表，然后从链表表头遍历并记数，如果计数i==m(i初始为1)删除元素，依次类推，若当前元素等于该元素链接的下一元素时终止循环。 解法二：用数学归纳法递推。 无论是用链表实现还是用数组实现都有一个共同点：要模拟整个游戏过程，不仅程序写起来比较烦，而且时间复杂度高达O(nm)，若nm非常大，无法在短时间内计算出结果。我们注意到原问题仅仅是要求出最后的胜利者的序号，而不是要读者模拟整个过程。因此如果要追求效率，就要打破常规，实施一点数学策略。 为了讨论方便，先把问题稍微改变一下，并不影响原意：问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 我们知道第一个人(编号一定是m%n-1) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:k k+1 k+2 … n-2, n-1, 0, 1, 2, … k-2并且从k开始报0。现在我们把他们的编号做一下转换： k –&gt; 0k+1 –&gt; 1k+2 –&gt; 2……k-2 –&gt; n-2k-1 –&gt; n-1变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k)%n 如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况——这显然就是一个倒推问题！好了，思路出来了，下面写递推公式： 令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n] 递推公式f[1]=0;f[i]=(f[i-1]+m)%i; (i&gt;1) 有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1 123456789101112131415161718import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); long N = cin.nextLong(); long K = cin.nextLong(); System.out.println(fun(N,K)+1); &#125; public static long fun(long N,long K)&#123; long res = 0; for (int i = 1;i&lt;=N;i++)&#123; res = (res+K)%i; &#125; return res; &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"算法之博弈论初探","date":"2017-03-15T13:56:03.000Z","path":"2017/03/15/算法之博弈论初探/","text":"1066 Bash游戏有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。 例如N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000) 第2 - T + 1行：每行2个数N，K。中间用空格分隔。（1 &lt;= N,K &lt;= 10^9) Output 共T行，如果A获胜输出A，如果B获胜输出B。 1234567891011121314151617181920import java.util.Scanner;public class Main &#123; public static char[] ans = new char[10000]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int T = cin.nextInt(); for (int i = 0;i&lt; T ;i++)&#123; int N = cin.nextInt(); int K = cin.nextInt(); if ((N % (K+1)) == 0) ans[i] = 'B'; else ans[i] = 'A'; &#125; for (int i = 0;i&lt;T;i++)&#123; System.out.println(ans[i]); &#125; &#125;&#125; 1069 Nim游戏有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。 例如：3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。 Input 第1行：一个数N，表示有N堆石子。（1 &lt;= N &lt;= 1000) 第2 - N + 1行：N堆石子的数量。(1 &lt;= A[i] &lt;= 10^9) Output 如果A获胜输出A，如果B获胜输出B。 123456789101112131415161718import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int T = cin.nextInt(); int tmp , ret = 0; for (int i = 0;i&lt; T ;i++)&#123; tmp = cin.nextInt(); if (i==0) ret = tmp; else ret = ret ^ tmp; &#125; char ans; if (ret==0) ans = 'B'; else ans = 'A'; System.out.println(ans); &#125;&#125; 1072 威左夫游戏有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。 例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000) 第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 2000000) Output 共T行，如果A获胜输出A，如果B获胜输出B。 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int t,n,m,temp; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d\",&amp;n,&amp;m); if(n&gt;m) swap(n,m); temp=(m-n)*(sqrt(5)+1)/2; if(n==temp) printf(\"B\\n\"); else printf(\"A\\n\"); &#125; return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"数学基础之log的巧用","date":"2017-03-15T13:52:52.000Z","path":"2017/03/15/数学基础之log的巧用/","text":"1058 N的阶乘的长度1234567891011121314import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); double N = cin.nextLong(); double ans = 1; for (double i = 1; i &lt;= N;i++)&#123; ans = ans + Math.log10(i); &#125; System.out.println((int)ans); &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"算法之归并","date":"2017-03-15T13:47:26.000Z","path":"2017/03/15/算法之归并/","text":"1019 逆序数 在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。给出一个整数序列，求该序列的逆序数。 解法：归并排序是将两个(或两个以上)有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序的子序列合并为整体有序序列。归并排序是分治算法的一个典型的应用，而且是稳定的一种排序，这题利用归并排序的过程中，计算每个小区间的逆序数，进而得到大区间的逆序数。那么，问题就解决了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.BufferedInputStream;import java.util.Scanner;public class Main &#123; public static int N = 50005; public static int ans = 0; public static long[] a = new long[N]; public static long[] res = new long[N]; public static void main(String[] args) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); int n = cin.nextInt(); for (int i = 1;i&lt;=n;i++)&#123; a[i] = cin.nextLong(); &#125; ans = 0; mer_sort(1,n); System.out.println(ans); &#125; public static void merge(int left, int right)&#123; int mid = (left+right)&gt;&gt;1; int i = left,j = mid+1; int cur = left; while(i &lt;= mid &amp;&amp; j &lt;= right)&#123; if(a[i] &lt;= a[j]) res[cur++] = a[i++]; else&#123; res[cur++] = a[j++]; ans += mid-i+1; //找到逆序的个数 &#125; &#125; while(i &lt;= mid) res[cur++] = a[i++]; while(j &lt;= right) res[cur++] = a[j++]; for(i = left;i &lt;= right;i ++) a[i] = res[i]; &#125; public static void mer_sort(int left ,int right)&#123; if (left &lt; right)&#123; int mid = (left+right)&gt;&gt;1; mer_sort(left,mid); //分解 mer_sort(mid+1,right); //分解 merge(left,right); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"数学基础之求最大公约数、最小公倍数","date":"2017-03-14T11:48:44.000Z","path":"2017/03/14/数学基础之求最大公约数/","text":"用Java求最大公约数GCD1011 最大公约数GCD12345678910111213141516171819202122import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); long A = cin.nextLong(); long B = cin.nextLong(); System.out.println(gcd(A,B)); &#125; /** * 辗转相除法：两个整数的最大公约数等于其中较小的数和两数的相除余数的最大公约数。 */ public static long gcd(long m,long n)&#123; while (true)&#123; if ((m = m % n) == 0) return n; if ((n = n % m) == 0) return m; &#125; &#125;&#125; 最小公倍数1012 最小公倍数LCM1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); long A = cin.nextLong(); long B = cin.nextLong(); System.out.println(lcm(A,B)); &#125; public static long gcd(long m,long n)&#123; while (true)&#123; if ((m = m % n) == 0) return n; if ((n = n % m) == 0) return m; &#125; &#125; /** * 在GCM基础上改动 * 最小公倍数 = n*m/最大公约数 */ public static long lcm(long m,long n)&#123; return m*n/gcd(m,n); &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"算法之动态规划","date":"2017-03-14T11:30:12.000Z","path":"2017/03/14/算法之动态规划/","text":"1006 最长公共子序列LCS给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。比如两个串为： 12abcicbaabdkscab ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。 Input 第1行：字符串A 第2行：字符串B(A,B的长度 &lt;= 1000) Output 输出最长的子序列，如果有多个，随意输出1个。 Input示例 12abcicbaabdkscab Output示例1abca 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); String sA = cin.nextLine(); String sB = cin.nextLine(); char[] A = sA.toCharArray(); char[] B = sB.toCharArray(); int len1 = A.length; int len2 = B.length; int[][] L = new int[1005][1005]; int[][] M = new int[1005][1005]; for (int i = 1;i&lt;=len1;i++)&#123; for (int j = 1; j&lt;= len2;j++)&#123; if (A[i-1]==B[j-1])&#123; L[i][j] = L[i-1][j-1]+1; M[i][j] = 1; &#125;else &#123; if (L[i-1][j] &gt;= L[i][j-1])&#123; L[i][j] = L[i-1][j]; M[i][j] = 2; &#125;else &#123; L[i][j] = L[i][j-1]; M[i][j] = 3; &#125; &#125; &#125; &#125; LCS(M,len1,len2,A); &#125; public static void LCS(int[][] M,int i,int j,char[] x)&#123; if (i==0 || j==0) return; if (M[i][j]==1)&#123; LCS(M,i-1,j-1,x); System.out.print(x[i-1]); &#125;else &#123; if (M[i][j] == 2)&#123; LCS(M,i-1,j,x); &#125;else &#123; LCS(M,i,j-1,x); &#125; &#125; &#125;&#125; 1049 最大子段和 求和，每次判断和是否&gt;=0，若是，则加上a[i],否则sum=a[i],并更新最大值. 12345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static long[] numbers = new long[50001]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int N = cin.nextInt(); for (int i = 0;i&lt;N;i++)&#123; numbers[i] = cin.nextLong(); &#125; long max = -1; long sum = 0; for (int i = 0;i&lt;N;i++)&#123; if (sum &gt;= 0)&#123; sum += numbers[i]; &#125;else &#123; sum = numbers[i]; &#125; if (sum &gt; max)&#123; max = sum; &#125; &#125; System.out.println(max); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"机试笔记08Java中的表","date":"2017-03-14T04:10:09.000Z","path":"2017/03/14/机试笔记08Java中的表/","text":"List1234567public interface List&lt;AnyType&gt; extends Collection&lt;AnyType&gt;&#123; AnyType get(int idx); AnyType set(int idx, AnyType newVal); void add(int idx, AnyType x); void remove(int idx); ListIterator&lt;AnyType&gt; listIterator(int pos); ArrayList 对get和set的调用花费常数时间 插入删除代价昂贵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.main;import java.util.Iterator;import java.util.NoSuchElementException;/** * Created by sunhuayan on 2017/3/14. */public class MyArrayList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private int theSize; private AnyType[] theItems; public MyArrayList()&#123; clear(); &#125; public void clear()&#123; theSize = 0; ensureCapacity(DEFAULT_CAPACITY); &#125; public int size()&#123; return theSize; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public void trimToSize()&#123; ensureCapacity(size()); &#125; public AnyType get(int idx)&#123; if (idx &lt; 0 || idx &gt;= size())&#123; throw new ArrayIndexOutOfBoundsException(); &#125; return theItems[idx]; &#125; public AnyType set(int idx, AnyType newVal)&#123; if (idx &lt; 0 || idx &gt;= size())&#123; throw new ArrayIndexOutOfBoundsException(); &#125; AnyType old = theItems[idx]; theItems[idx] = newVal; return old; &#125; private void ensureCapacity(int newCapacity) &#123; if (newCapacity &lt; theSize)&#123; return; &#125; AnyType[] old = theItems; theItems = (AnyType[]) new Object[newCapacity]; for (int i=0; i &lt; size(); i++)&#123; theItems[i] = old[i]; &#125; &#125; public boolean add(AnyType x)&#123; add(size(),x); return true; &#125; public void add(int idx, AnyType x)&#123; if (theItems.length == size())&#123; ensureCapacity(size() * 2 + 1); &#125; for (int i = theSize; i &gt; idx; i--)&#123; theItems[i] = theItems[i-1]; &#125; theItems[idx] = x; theSize++; &#125; public AnyType remove(int idx)&#123; AnyType removeItem = theItems[idx]; for (int i = idx; i &lt; size()-1; i++) theItems[i] = theItems[i+1]; theSize--; return removeItem; &#125; @Override public Iterator&lt;AnyType&gt; iterator() &#123; return new ArrayListIterator(); &#125; private class ArrayListIterator implements Iterator&lt;AnyType&gt;&#123; private int current = 0; public boolean hasNext()&#123; return current &lt; size(); &#125; public AnyType next()&#123; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; return theItems[current++]; &#125; public void remove()&#123; MyArrayList.this.remove(--current); &#125; &#125;&#125; LinkedList 插入删除开销小 不易索引 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package com.main;import java.util.ConcurrentModificationException;import java.util.Iterator;import java.util.NoSuchElementException;/** * Created by sunhuayan on 2017/3/14. */public class MyLinkedList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt; &#123; private int theSize; private int modCount = 0; private Node&lt;AnyType&gt; beginMarker; private Node&lt;AnyType&gt; endMarker; private static class Node&lt;AnyType&gt;&#123; public AnyType data; public Node&lt;AnyType&gt; prev; public Node&lt;AnyType&gt; next; public Node(AnyType d, Node&lt;AnyType&gt; p, Node&lt;AnyType&gt; n)&#123; data = d; prev = p; next = n; &#125; &#125; public MyLinkedList()&#123; clear(); &#125; /** * Change the size of this collection to zero. */ public void clear()&#123; beginMarker = new Node&lt;AnyType&gt;(null,null,null); endMarker = new Node&lt;AnyType&gt;(null, beginMarker, null); beginMarker.next = endMarker; theSize = 0; modCount++; &#125; public int size()&#123; return theSize; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean add(AnyType x)&#123; add(size(),x); return true; &#125; public void add(int idx, AnyType x)&#123; addBefore(getNode(idx),x); &#125; public AnyType get(int idx)&#123; return getNode(idx).data; &#125; public AnyType set(int idx, AnyType newVal)&#123; Node&lt;AnyType&gt; p = getNode(idx); AnyType oldVal = p.data; p.data = newVal; return oldVal; &#125; public AnyType remove(int idx)&#123; return remove(getNode(idx)); &#125; /** * Adds an item to this collection, at specified position p. * Items at or after that position are slid one position higher. * @param p Node to add before. * @param x any object * @throws IndexOutOfBoundsException if idx is not between 0 and size(). */ private void addBefore(Node&lt;AnyType&gt; p, AnyType x)&#123; Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(x,p.prev,p); newNode.prev.next = newNode; p.prev = newNode; theSize++; modCount++; &#125; /** * Removes the Object contained in Node p. * @param p the Node containing the object. * @return the item was removed from the collection. */ private AnyType remove(Node&lt;AnyType&gt; p) &#123; p.next.prev = p.prev; p.prev.next = p.next; theSize--; modCount++; return p.data; &#125; /** * Gets the Node at position idx, which must range from 0 to size(). * @param idx index of node being obtained. * @return internal node corresponding to idx. * @throws IndexOutOfBoundsException if idx is not between 0 and size(). */ private Node&lt;AnyType&gt; getNode(int idx)&#123; Node&lt;AnyType&gt; p; if (idx &lt; 0 || idx &gt; size())&#123; throw new IndexOutOfBoundsException(); &#125; if (idx &lt; size()/2)&#123; p = beginMarker.next; for (int i = 0; i &lt; idx; i++)&#123; p = p.next; &#125; &#125;else &#123; p = endMarker; for (int i = size(); i &gt; idx; i--)&#123; p = p.prev; &#125; &#125; return p; &#125; @Override public Iterator&lt;AnyType&gt; iterator() &#123; return new LinkedListIterator(); &#125; private class LinkedListIterator implements Iterator&lt;AnyType&gt;&#123; private Node&lt;AnyType&gt; current = beginMarker.next; private int expectedModCount = modCount; private boolean okToRemove = false; @Override public boolean hasNext() &#123; return current!=endMarker; &#125; @Override public AnyType next() &#123; if (modCount != expectedModCount)&#123; throw new ConcurrentModificationException(); &#125; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; AnyType nextItem = current.data; current = current.next; okToRemove = true; return nextItem; &#125; @Override public void remove() &#123; if (modCount != expectedModCount)&#123; throw new ConcurrentModificationException(); &#125; if (!okToRemove)&#123; throw new IllegalStateException(); &#125; MyLinkedList.this.remove(current.prev); okToRemove = false; expectedModCount++; &#125; &#125;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记07栈的应用","date":"2017-03-13T12:30:01.000Z","path":"2017/03/13/机试笔记07栈的应用/","text":"栈的应用12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; S;//定义一个堆栈char str[110];//保存输入字符串char ans[110];//保存输出字符串int main()&#123; while (scanf(\"%s\",str)!=EOF) &#123; int i; for (i = 0; str[i]!=0; i++) &#123;//从左到右遍历字符串 if (str[i] == '(') &#123;//若遇到左括号 S.push(i);//将其数组下标放入栈中 ans[i] = ' ';//暂且将对应的输出字符串位置改为空格 &#125;else if(str[i]==')')&#123;//若遇到右括号 if (S.empty() == false) &#123;//若此时栈为空 S.pop();//栈顶左括号与其匹配，从战中弹出 ans[i] = ' ';//修改输出中该位置为空格 &#125;else&#123; ans[i] = '?';//若栈为空，则无法找到左括号匹配 &#125; &#125;else&#123; ans[i] = ' ';//若为其它字符 &#125; &#125; while (!S.empty()) &#123;//字符串遍历完成剩下的无法匹配的左括号 ans[S.top()] = '$';//修改其在输出中的位置为\"$\" S.pop(); &#125; //ans[i] = 0; //为了使输出形成字符串，在其最后一个字符后添加一个空字符 puts(str);//输出字符串 puts(ans); return 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stack&gt;#include &lt;stdio.h&gt;using namespace std;char str[220];//保存表达式字符串int mat[][5]&#123;//优先级矩阵，若mat[i][j]==1,则表示i号运算符优先级大于j号运算符，运算符编码规则为+1号，-2号，*3号，/4号 //人为添加在表达式首位的标记运算符为0号 1,0,0,0,0, 1,0,0,0,0, 1,0,0,0,0, 1,1,1,0,0, 1,1,1,0,0&#125;;stack&lt;int&gt; op;//运算符栈,保存运算符编号stack&lt;double&gt; in;//数字栈void getOp(bool &amp;reto,int &amp;retn,int &amp;i)&#123; //获得表达式中 下一个元素函数，若函数运行结束时，引用变量reto为true,则表示该元素为一个运算符，其编号保存在引用变量retn中；否则，表示该元素为一个数字，其值保存在引用变量retn中，引用变量i表示遍历到的字符串下标 if (i == 0 &amp;&amp; op.empty() == true) &#123;//若此时遍历字符串第一个字符，且运算符栈为空，我们人为添加编号为0的标记字符 reto = true;//运算符 retn = 0;//编号为0 return; &#125; if (str[i] == 0) &#123;//若此时遍历字符为空字符，则表示该字符串已被遍历完 reto = true; retn = 0; return; &#125; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123;//若当前字符为数字 reto = false;//返回为数字 &#125;else&#123;//否则 reto = true;//返回为运算符 if (str[i] == '+') &#123; retn = 1; &#125;else if(str[i] == '-')&#123; retn = 2; &#125;else if(str[i] == '*')&#123; retn = 3; &#125;else if(str[i] == '/')&#123; retn = 4; &#125; i += 2;//i递增，跳过该运算字符和后面的空格 return; &#125; retn = 0;//返回结果为数字 for (; str[i] != ' ' &amp;&amp; str[i] != 0 ; i++) &#123;//若字符串未遍历完，且在一个字符不是空格，则依次遍历其后数字，计算当前连续数字字符表示的数值 retn *= 10; retn += str[i] - '0'; &#125; if (str[i] == ' ')&#123;//若其后字符为空格，则表示字符串未被遍历完 i++;//i递增，跳过该空格 &#125; return;&#125;int main()&#123; while (gets(str)) &#123;//输入字符串，当其位于文件尾时，gets返回0 if (str[0] == '0' &amp;&amp; str[1] == 0) &#123;//若输入只有1个0，则退出 break; &#125; bool retop; int retnum;//定义函数所需的引用变量 int idx = 0;//定义遍历到的字符串下标，初始值尾0 while (!op.empty()) &#123; op.pop(); &#125; while (!in.empty()) &#123; in.pop();//清空数字栈和运算符栈 &#125; while (true) &#123;//循环遍历表达式字符串 getOp(retop, retnum, idx);//获取表达式中下一个元素 if (retop == false) &#123;//若该元素为数字 in.push((double)retnum);//将其压入数字栈中 &#125;else&#123;//否则 double tmp; if (op.empty() == true || mat[retnum][op.top()] == 1) &#123; op.push(retnum);//若运算符栈为空或当前遍历到的运算符优先级大于栈顶运算符，将该运算符压入运算符堆栈 &#125;else&#123;//否则 while (mat[retnum][op.top()] == 0) &#123;//只要当前运算符优先级小于栈顶元素运算符，则重复循环 int ret = op.top();//保存栈顶运算符 op.pop(); double b = in.top(); in.pop(); double a = in.top(); in.pop();//从数字栈栈顶弹出两个数字，依次保存在遍历a,b中 if (ret == 1) &#123; tmp = a+b; &#125;else if(ret == 2)&#123; tmp = a - b; &#125;else if(ret == 3)&#123; tmp = a * b; &#125;else&#123; tmp = a/b;//按照运算符类型完成运算 &#125; in.push(tmp);//将结果压回数字栈 &#125; op.push(retnum);//将当前运算符压入运算符栈 &#125; &#125;if (op.size() == 2 &amp;&amp; op.top() == 0) &#123;//若运算符栈只有两个元素，且栈顶元素为标记运算符，则表示表达式求值结束 break; &#125; &#125; printf(\"%.2f\\n\",in.top()); &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记06Java在ACM中的应用","date":"2017-03-11T13:00:49.000Z","path":"2017/03/11/机试笔记06Java在ACM中的应用/","text":"Chapter I.Java的优缺点各种书上都有，这里只说说用Java做ACM-ICPC的特点： 最明显的好处是，学会Java，可以参加Java Challenge 对于熟悉C/C++的程序员来说，Java并不难学，找本书，一两周业余时间就可以搞定了。当然，这里只是指一般编程，想熟悉所有的Java库还是需要些时间的。 在一般比赛中，Java程序会有额外的时间和空间，而实际上经过实验，在执行计算密集任务的时候Java并不比C/C++慢多少，只是IO操作较慢而已。 Java简单而功能强大，有些东西用Java实现起来更为方便，比如高精度。 用Java不易犯细微的错误，比如C/C++中的指针，“if (n = m) … ” 等 目前来看Eclipse已成基本配置，写Java程序反而比C/C++更方便调试。在具体竞赛时也算多一种选择。 学会Java对以后工作有好处。现在国外很多地方会Java的人比会C/C++的人多。 会Java可以使你看起来更像偶蹄类动物（牛） hoho~ Chapter II.下面说一下ACM-ICPC队员初用Java编程所遇到的一些问题：基本输入输出： JDK 1.5.0 新增的Scanner类为输入提供了良好的基础，简直就是为ACM-ICPC而设的。 一般用法为： 1234567891011121314151617181920212223242526import java.io.* import java.util.* public class Main &#123; public static void main(String args[]) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); ... &#125; &#125; ``` * 读一个整数： int n = cin.nextInt(); * 读一个字符串：String s = cin.next(); * 读一个浮点数：double t = cin.nextDouble();* 读一整行：String s = cin.nextLine(); * 判断是否有下一个输入可以用 cin.hasNext() 或 cin.hasNextInt() 或 cin.hasNextDouble() 等，具体见 TOJ 1001 例程。 * 输出一般可以直接用 System.out.print() 和 System.out.println()，前者不输出换行，而后者输出。 比如：System.out.println(n); // n 为 int 型 同一行输出多个整数可以用```Java System.out.println(new Integer(n).toString() + \" \" + new Integer(m).toString()); 也可重新定义： 12static PrintWriter cout = new PrintWriter(new BufferedOutputStream(System.out)); cout.println(n); 对于输出浮点数保留几位小数的问题，可以使用DecimalFormat类， 12345678import java.text.*; DecimalFormat f = new DecimalFormat(\"#.00#\"); DecimalFormat g = new DecimalFormat(\"0.000\"); double a = 123.45678, b = 0.12; System.out.println(f.format(a)); System.out.println(f.format(b)); System.out.println(g.format(b)); //这里0指一位数字，#指除0以外的数字。 大数字 BigInteger 和 BigDecimal 是在java.math包中已有的类，前者表示整数，后者表示浮点数 用法：不能直接用符号如+、-来使用大数字，例如： 12345(import java.math.*) // 需要引入 java.math 包 BigInteger a = BigInteger.valueOf(100); BigInteger b = BigInteger.valueOf(50); BigInteger c = a.add(b) // c = a + b; 主要有以下方法可以使用： 123456789BigInteger add(BigInteger other) BigInteger subtract(BigInteger other) BigInteger multiply(BigInteger other) BigInteger divide(BigInteger other) BigInteger mod(BigInteger other) int compareTo(BigInteger other) static BigInteger valueOf(long x) //输出大数字时直接使用 System.out.println(a) 即可。 字符串 String 类用来存储字符串，可以用charAt方法来取出其中某一字节，计数从0开始： 1String a = \"Hello\"; // a.charAt(1) = ’e’ 用substring方法可得到子串，如上例 1System.out.println(a.substring(0, 4)) // output \"Hell\" 注意第2个参数位置上的字符不包括进来。这样做使得 1s.substring(a, b) 总是有 b-a个字符。 字符串连接可以直接用 + 号，如 123String a = \"Hello\"; String b = \"world\"; System.out.println(a + \", \" + b + \"!\"); // output \"Hello, world!\" 如想直接将字符串中的某字节改变，可以使用另外的StringBuffer类。 调用递归（或其他动态方法）在主类中 main 方法必须是 public static void 的，在 main 中调用非static类时会有警告信息，可以先建立对象，然后通过对象调用方法： 12345678910111213141516171819public class Main &#123; ... void dfs(int a) &#123; if (...) return; ... dfs(a+1); &#125; public static void main(String args[]) &#123; ... Main e = new Main(); e.dfs(0); ... &#125; &#125; 其他注意的事项 Java是面向对象的语言，思考方法需要变换一下，里面的函数统称为方法，不要搞错。 Java 里的数组有些变动，多维数组的内部其实都是指针，所以Java不支持fill多维数组。 数组定义后必须初始化，如 1int[] a = new int[100]; 布尔类型为 boolean，只有true和false二值，在 if (…) / while (…) 等语句的条件中必须为boolean类型。 在C/C++中的 if (n % 2) … 在Java中无法编译通过。 下面在java.util包里Arrays类的几个方法可替代C/C++里的memset、qsort/sort 和 bsearch: 123Arrays.fill() Arrays.sort() Arrays.binarySearch()","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记05贪心算法","date":"2017-03-11T11:53:28.000Z","path":"2017/03/11/机试笔记05贪心算法/","text":"FatMouse’ Trade 有 m 元钱，n 种物品;每种物品有 j 磅，总价值 f 元，可以 使用 0 到 f 的任意价格购买相应磅的物品，例如使用 0.3f 元，可以购买 0.3j 磅物 品。要求输出用 m 元钱最多能买到多少磅物品 每次都买剩余物品中性价比最高的物品，知道该物品被买完活捉钱耗尽。但该物品已经被卖买完，则我们继续在剩余的物品中寻找性价比最高的物品 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;struct goods &#123; double j;//总重 double f;//总价值 double s;//性价比 bool operator &lt; (const goods &amp;A) const&#123; return s &gt; A.s; &#125;&#125;buf[1000];int main()&#123; double m; int n; while (scanf(\"%lf%d\",&amp;m,&amp;n)!=EOF)&#123; if (m == -1 &amp;&amp; n == -1) break; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%lf%lf\",&amp;buf[i].j,&amp;buf[i].f); buf[i].s = buf[i].j / buf[i].f;//计算性价比 &#125; sort(buf, buf+n); int idx = 0;//当前货物下标 double ans = 0;//累加所能得到的总重量 while (m &gt; 0 &amp;&amp; idx &lt; n) &#123; //若能买下全部该物品 if (m &gt; buf[idx].f) &#123; ans += buf[idx].j; m -= buf[idx].f; &#125;else&#123; //若只能买下部分该物品 ans += buf[idx].j * m / buf[idx].f; m = 0; &#125; idx++;//继续下一个物品 &#125; printf(\"%.3lf\\n\",ans); &#125; return 0;&#125; 今年暑假不AC 最优解中，第一个观看的节目一定是所有节目里结束时间最早的节目。因为按照优先选择结束时间最早的节目，我们所观看的第一个节目一定是所有节目里结束时间最早的。 如果最优解的第一个节目并不是结束最早的节目，那么我们可以直接用结束时间最早的节目代替该解中的第一个节目，替换后的解也是最优解。这样，我们就可以得出当第一个节目选择所有节目中结束时间最早的节目， 这样是一定不会得不到最优解的。于是，在我们所要求的最优解中，第一个被收看的节目可以安排所有节目中结束时间最早的节目(若有多个，则可任意选择一个)。 在选择第 x(x&gt;=1)个节目时， 一定是选择在收看完前 x-1 个节目后，其它所有可以收看节目中结束时间最早的节目，这就是我们要找的贪心策略。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;struct program&#123; int startTime; int endTime; bool operator &lt; (const program &amp;A) const&#123; return endTime &lt; A.endTime; &#125;&#125;buf[100];int main()&#123; int n; while (scanf(\"%d\",&amp;n)!=EOF) &#123; if (n == 0) &#123; break; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d\",&amp;buf[i].startTime,&amp;buf[i].endTime); &#125; sort(buf, buf+n); int currentTime = 0, ans = 0;//记录当前时间变量初始值为0 for (int i = 0; i&lt;n; i++) &#123; if (currentTime &lt;= buf[i].startTime) &#123; //若当前时间小于等于开始时间，那么收看该在剩余节目里结束时间最早的节目 currentTime = buf[i].endTime;//当前时间变为该节目结束时间 ans ++;//又收看了一个节目 &#125; &#125; printf(\"%d\\n\",ans);//输出 &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记04查找","date":"2017-03-10T13:07:41.000Z","path":"2017/03/10/机试笔记04查找/","text":"输入N个学生的信息进行查询 二分查找 12//存在一个升序有序的数组buf,其大小为size,目标数字为target int base = 0 , top = size; //初始情况与二分查找一致 while (base &lt;= top) &#123; //二分循环条件与二分查找一致 int mid = (base + top) / 2; if (buf[mid] &lt;= target) base = mid + 1; //符合前一部分数字规定 else top = mid - 1; //否则 &#125;int ans = top;//最后，top即位我们要求的数字数组下标，buf[top]为数字本省 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;struct Student &#123; char no[100]; char name[100]; int age; char sex[5]; bool operator &lt; (const Student &amp; A) const&#123; return strcmp(no, A.no) &lt; 0; &#125;&#125;buf[1000];int main()&#123; int n; while (scanf(\"%d\",&amp;n) != EOF) &#123; for (int i=0; i&lt;n; i++) &#123; scanf(\"%s%s%s%d\",buf[i].no,buf[i].name,buf[i].sex, &amp;buf[i].age); &#125;//输入 sort(buf, buf+n); int t; scanf(\"%d\",&amp;t); while (t-- != 0) &#123; int ans = -1; char x[30]; scanf(\"%s\",x); int top = n-1, base = 0; while (top &gt;= base) &#123; int mid = (top + base)/2; int tmp = strcmp(buf[mid].no, x); if (tmp == 0) &#123; ans = mid; break; &#125; else if(tmp &gt;0) top = mid - 1; else base = mid + 1; &#125; if (ans == -1) &#123; printf(\"No Answer!\\n\"); &#125;else&#123; printf(\"%s %s %s %d\\n\",buf[ans].no,buf[ans].name,buf[ans].sex,buf[ans].age); &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记03Hash的应用","date":"2017-03-09T07:50:27.000Z","path":"2017/03/09/机试笔记03Hash的应用/","text":"统计同成绩学生人数 读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int n; while (scanf(\"%d\",&amp;n) != EOF &amp;&amp; n != 0) &#123; int Hash[101] = &#123;0&#125;;//建立一个初始为0的Hash数组 for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\",&amp;x); Hash[x]++;//统计分数出现次数 &#125; int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",Hash[x]); &#125; return 0;&#125; Sort 给你 n 个整数，请按从大到小的顺序输出其中前 m 大的数。 每组测试数据有两行，第一行有两个数 n,m(0&lt;n,m&lt;1000000)，第二行包含 n 个各不相同，且都处于区间[-500000,500000]的整数。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define OFFSET 500000int Hash[1000001];int main()&#123; int n,m; while (scanf(\"%d%d\",&amp;n,&amp;m) != EOF) &#123; for (int i=-500000;i&lt;=500000; i++) &#123; Hash[i+OFFSET] = 0; &#125;//初始化 将每个数字都标记为未出现 for (int i=1; i&lt;=n; i++) &#123; int x; scanf(\"%d\",&amp;x); Hash[x+OFFSET] = 1;//凡是出现过的数字，该数组元素均为1 &#125; for (int i = 500000; i&gt;=-500000; i--) &#123;//输出前m个数 if (Hash[i+OFFSET]==1) &#123;//若该数字在输入中出现 printf(\"%d\",i);//输出该数字 m--;//输出一个数字后，m-- if (m!=0) &#123; printf(\" \"); &#125;else&#123; printf(\"\\n\"); break; &#125; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记02日期类问题","date":"2017-03-08T13:39:59.000Z","path":"2017/03/08/机试笔记02日期类问题/","text":"日期差值 在保存某个特定日期与原点日期的天数差时，用了三位数组 输入采用技巧 涉及开辟大量内存空间的情况，必须在函数体外定义或者动态malloc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0//定义宏判断是否是闰年，方便计算每月天数int dayOfMonth[13][2]&#123; 0,0, 31,31, //1 28,29, //2 31,31, //3 30,30, //4 31,31, //5 30,30, //6 31,31, //7 31,31, //8 30,30, //9 31,31, //10 30,30, //11 31,31 //12&#125;;struct Date&#123; int Day; int Month; int Year; //计算下一天的日期 void nextDay()&#123; Day++; if(Day &gt; dayOfMonth[Month][ISYEAP(Year)])&#123; //若日数超过最大日数 Day = 1; Month++;//进入下一月 if(Month &gt; 12)&#123;//月数超过12 Month = 1; Year++; //进入下一年 &#125; &#125; &#125;&#125;;int buf[5001][13][32];//保存预处理天数int Abs(int x)&#123; //求绝对值 return x &lt; 0 ? -x : x;&#125;int main()&#123; Date tmp; int cnt = 0; //天数计数 tmp.Day = 1; tmp.Month = 1; tmp.Year = 0;//初始化日期类对象为0年1月1日 while(tmp.Year != 5001) &#123; //将该日与0年1月1日的天数差保存起来 buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay();//计算下一天日期 cnt++;//计算器累加，每经过一天计数器+1,代表与原点日期的间隔又增加一天 &#125; int d1, m1, y1; int d2, m2, y2; while (scanf(\"%4d%2d%2d\",&amp;y1,&amp;m1,&amp;d1) != EOF) &#123; scanf(\"%4d%2d%2d\",&amp;y2,&amp;m2,&amp;d2);//读入要计算的两个日期 //用预处理的数据计算两日期差值，取绝对值 printf(\"%d\\n\",Abs(buf[y2][m2][d2] - buf[y1][m1][d1] + 1)); &#125; return 0;&#125; Day of Week 输入一个日期，要求输出该日期为星期几 1.今天是星期几; 2.今天和所给定的那天相隔几天。利用其对7求余数，我们便可以轻易的知道所给定的那天是星期几了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0//定义宏判断是否是闰年，方便计算每月天数int dayOfMonth[13][2]&#123; 0,0, 31,31, //1 28,29, //2 31,31, //3 30,30, //4 31,31, //5 30,30, //6 31,31, //7 31,31, //8 30,30, //9 31,31, //10 30,30, //11 31,31 //12&#125;;struct Date&#123; int Day; int Month; int Year; //计算下一天的日期 void nextDay()&#123; Day++; if(Day &gt; dayOfMonth[Month][ISYEAP(Year)])&#123; //若日数超过最大日数 Day = 1; Month++;//进入下一月 if(Month &gt; 12)&#123;//月数超过12 Month = 1; Year++; //进入下一年 &#125; &#125; &#125;&#125;;int buf[3001][13][32];//保存预处理天数char monthName[13][20] = &#123; \"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"&#125;;char weekName[7][20] = &#123; \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;;int main()&#123; Date tmp; int cnt = 0; //天数计数 tmp.Day = 1; tmp.Month = 1; tmp.Year = 0;//初始化日期类对象为0年1月1日 while(tmp.Year != 3001)&#123; //将该日与0年1月1日的天数差保存起来 buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay();//计算下一天日期 cnt++;//计算器累加，每经过一天计数器+1,代表与原点日期的间隔又增加一天 &#125; int d, m, y; char s[20]; while (scanf(\"%d%s%d\",&amp;d,s,&amp;y) != EOF) &#123; for (m = 1; m &lt;= 12; m++) &#123; if (strcmp(s,monthName[m]) == 0) &#123; break; &#125; &#125; //计算给定日期与今日日期的天数间隔 int days = buf[y][m][d] - buf[2017][3][6]; //今天2017年3月6日为星期一，对应数组下标为1，则计算1经过days天后的下标 days = days+1; puts(weekName[(days % 7 + 7)%7]); &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记01排序","date":"2017-03-07T11:24:03.000Z","path":"2017/03/07/机试笔记01排序/","text":"#冒泡排序12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; int n; int buf[100]; while(scanf(\"%d\",&amp;n)!=EOF)&#123;//输入n,并实现多组数据输入 for (int i=0; i&lt;n; i++) &#123; scanf(\"%d\",&amp;buf[i]); &#125; for (int i=0; i&lt;n; i++) &#123; for (int j=0; j&lt;n-1-i; j++) &#123; if (buf[j]&gt;buf[j+1]) &#123; int tmp = buf[j]; buf[j] = buf[j+1]; buf[j+1] = tmp; &#125; &#125; &#125; for (int i=0; i&lt;n; i++) &#123; printf(\"%d \",buf[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 1while(scanf(\"%d\",&amp;n)!=EOF) scanf函数是有返回值的，返回被输入函数成功复制的变量个数 此例中，若成功对n赋值，返回值为1 一般测试数据需要输入多组，需要对每组输入都输出相应答案 当输入已经到达结尾，scanf函数无法再为n赋值，scanf返回EOF 快速排序使用C++内置函数 sort 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int x, int y)&#123; //定义排序规则 return x&gt;y;&#125;int main()&#123; int n; int buf[100]; while (scanf(\"%d\",&amp;n)!=EOF) &#123; for (int i=0; i &lt; n; i++) &#123; scanf(\"%d\",&amp;buf[i]); &#125; //sort(buf,buf+n);//使用该重载形式，表明使用默认排序（递增） sort(buf,buf+n,cmp);//使用该重载形式，表明使用自定义规则 for (int i=0; i&lt;n; i++) &#123; printf(\"%d \",buf[i]); &#125; printf(\"\\n\"); &#125;&#125; #成绩排序 利用sort 题目描述 N 个学生的数据，将学生数据按成绩高低排序，如果成绩相同则按姓名 字符的字母序排序，如果姓名的字母序也相同则按照学生的年龄排序，并输出 N 个学生排序后的信息。 输入 测试数据有多组，每组输入第一行有一个整数 N(N&lt;=1000)，接下来的 N 行包括 N 个学生的数据。每个学生的数据包括姓名(长度不超过 100 的字符串)、年龄(整形数)、成绩(小于等于 100 的正数)。 输出 将学生信息按成绩进行排序，成绩相同的则按姓名的字母序进行排序。然后输出学生信息，按照如下格式:姓名 年龄 成绩 样例输入： 1233 abc 20 99bcd 19 97 bed 20 97 样例输出 123bcd 19 97 bed 20 97 abc 20 99 提示 学生姓名的字母序区分字母的大小写，如 A 要比 a 的字母序靠前(因为 A 的 ASC 码比 a 的 ASC 码要小)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;struct E&#123; char name[101]; int age; int score; bool operator &lt; (const E &amp;b) const&#123; //重载小于运算符 if(score != b.score) return score &lt; b.score; int tmp = strcmp(name, b.name); if(tmp != 0) return tmp&lt;0; else return age &lt; b.age; &#125;&#125;buf[100];//bool cmp(E a,E b)&#123;// if (a.score != b.score) &#123;// return a.score &lt; b.score;// &#125;// int tmp = strcmp(a.name, b.name);// if (tmp != 0) &#123;// return tmp &lt; 0;// &#125;else&#123;// return a.age &lt; b.age;// &#125;//&#125;int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF)&#123; for (int i=0; i&lt;n; i++) &#123; scanf(\"%s%d%d\",buf[i].name,&amp;buf[i].age,&amp;buf[i].score); &#125; //sort(buf, buf+n, cmp); sort(buf,buf+n); for (int i=0; i&lt;n; i++) &#123; printf(\"%s %d %d \\n\",buf[i].name,buf[i].age,buf[i].score); &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"计算机网络笔记01","date":"2017-03-01T13:56:07.000Z","path":"2017/03/01/计算机网络笔记01/","text":"第一章 概述 1.三网：电信网络、有线电视网络、计算机网络 2.起核心作用的是：计算机网络 3.计算机网络：是计算机技术与通信技术相结合形成了一门新的技术，即计算机之间的数据通信 计算机网络发展的五大阶段面向终端的网络（1957 - 1968）分组交换网络（1968 - 1984）网络体系结构的出现（1984 - 1986）Internet的出现（1986 - 今）新一代的计算机网络（ISDN）电路交换的三个阶段 建立连接 通信 释放连接 分组交换网的工作原理 子网划分： 通信子网和资源子网 节点交换机工作方式： 存储转发 在发送端，先把较长的报文划分成较短的、固定长度的数据段 每一个数据段前面添加上首部构成分组 分组交换网以“分组”作为数据传输单元 依次把各分组发送到接收端 接收端收到分组后剥去首部还原成报文 #分组首部的重要性 每一个分组的首部都含有地址等控制信息 分组交换网中的节点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个节点交换机 用这样的存储转发方式，最后分组就能到达最终目的地","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://vvshyer.com/tags/计算机网络/"}]},{"title":"OC学习之数学公式","date":"2017-02-28T11:48:42.000Z","path":"2017/02/28/OC学习之数学公式/","text":"1、 三角函数 double sin (double);正弦 double cos (double);余弦 double tan (double);正切 2 、反三角函数 double asin (double); 结果介于[-PI/2, PI/2] double acos (double); 结果介于[0, PI] double atan (double); 反正切(主值), 结果介于[-PI/2, PI/2] double atan2 (double, double); 反正切(整圆值), 结果介于[-PI, PI] 3 、双曲三角函数 double sinh (double); double cosh (double); double tanh (double); 4 、指数与对数 double exp (double);求取自然数e的幂 double sqrt (double);开平方 double log (double); 以e为底的对数 double log10 (double);以10为底的对数 double pow(double x, double y;计算以x为底数的y次幂 float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数 5 、取整 double ceil (double); 取上整 double floor (double); 取下整 6 、绝对值 double fabs (double);求绝对值 double cabs(struct complex znum) ;求复数的绝对值 7 、标准化浮点数 double frexp (double f, int p); 标准化浮点数, f = x 2^p, 已知f求x, p ( x介于[0.5, 1] ) double ldexp (double x, int p); 与frexp相反, 已知x, p求f 8 、取整与取余 double modf (double, double*); 将参数的整数部分通过指针回传, 返回小数部分 double fmod (double, double); 返回两参数相除的余数 9 、其他 double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x, int exponent);计算x*(2的exponent次幂) double poly(double x, int degree, double coeffs [] );计算多项式 int matherr(struct exception *e);数学错误计算处理程序","tags":[{"name":"iOS MAC Object-C","slug":"iOS-MAC-Object-C","permalink":"https://vvshyer.com/tags/iOS-MAC-Object-C/"}]},{"title":"OC学习之语法","date":"2017-02-28T02:39:06.000Z","path":"2017/02/28/OC学习之语法/","text":"类的定义 123@interface SimpleClass:NSObject类 @end 类的属性申明 1234@interface Person:NSObject@property NSString *firstName;@property NSSTring *lastName; @end 类的属性申明 123@property NSNumber *yearOfBirth;@property int yearOfBirth;@property(readonly) NSString *firstName; 减号方法（普通方法又称对象方法）申明 123456@interface Person:NSObject-(void)someMethod;-(void)someMethodWithValue:(SomeType)value;-(void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;@end 加号方法（类方法又称静态方法）申明 1234567@interface NSString:NSObject+(id)string;+(id)stringWithString:(NSString *)aString;+(id)stringWithFormat:(NSString *)format,...;+(id)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)errod;+(id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;@end 类的实现 123#import \"XYZPerson.h\"@implementation XYZPersion@end","tags":[{"name":"iOS MAC Object-C","slug":"iOS-MAC-Object-C","permalink":"https://vvshyer.com/tags/iOS-MAC-Object-C/"}]},{"title":"生日快乐","date":"2017-02-27T13:18:19.000Z","path":"2017/02/27/生日快乐/","text":"二月二，龙抬头。祝自己生日快乐。Happy birthday.","tags":[{"name":"随笔","slug":"随笔","permalink":"https://vvshyer.com/tags/随笔/"}]},{"title":"Oracle学习之JDBC","date":"2015-01-22T06:38:10.000Z","path":"2015/01/22/Oracle学习之JDBC/","text":"1.JDBC：Java Database Connectivity 在java中访问各种关系型数据库的一些API 2.JDBC所在的包：Java.sql.*; 3.常用的类和接口：DriverManager 程序驱动管理器（类） Connection 代表数据库连接（接口） Statement 声明，可以用来发送sql语句（接口） Boolean excute ResultSet excuteQuery Int executeUpdate Int[] executeUpdate resultSet 结果集（接口），代表查询结果 4.利用JDBC访问数据库的原理：//连接数据库，并向dept表中插一条记录： //1.加载驱动（按需访问） Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //2.获得连接 String url=&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;; String userName=&quot;c##scott&quot;; String password=&quot;tiger&quot;; Connection conn = DriverManager.getConnection(url,userName,password); System.out.println(&quot;连接成功&quot;); ;//代表连接 //3.获得声明 Statement st = null;//声明 //创建一个与conn关联的声明 st = conn.createStatement(); //4.发送sql st.execute(&quot;insert into dept values(45,&apos;开发部&apos;,&apos;哈尔滨&apos;)&quot;); //5.关闭资源 st.close(); conn.close(); 5.Statement的三个常用方法的区别：boolean execute：可以执行任何sql语句，如果此sql语句有查询结果，返回true，否则，false ResultSet getResultSet：获得查询结果集 int executeUpdate：执行DML和DDL，返回影响的记录的条数，如果是DDL，返回0 ResultSet executeQuery：专门执行select语句的方法，返回查询结果集 6.ResultSet的用法：代表查询语句的结果集； 两个重要的方法 .next()：移动记录的指针 .getXXX()：获取当前行的某个字段的值 rs = st.executeQuery(&quot;select * from dept&quot;); //遍历结果集 //是否存在下一条记录 while(rs.next()){ //取每一个字段值 int deptno = rs.getInt(1); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); System.out.println(deptno+&quot;\\t&quot;+dname+&quot;\\t&quot;+loc); } 7.DAO:Data Access Object; 对数据操作的封装 DeptDao{ insert(Dept dept); update(Dept dept); } VO:Value Object java中我们使用的类 数据库中我们使用的表 8.PreparedStatement：这是Statement的子接口，是预编译的Statement，与Statement相比，PreparedStatement在多次执行同一类语句性能更好；同时可以解决sql注入的问题","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之E-R图","date":"2015-01-20T07:23:49.000Z","path":"2015/01/20/Oracle学习之E-R图/","text":"软件开发生命周期：1.可行性分析：做还是不做 2.需求分析：做什么 3.概要设计 4.系统实现 5.测试：单元测试，黑盒，白盒，集成测试，性能测试（压力测试） 6.运行维护：（运维人员） 1.建模：E-R图： 实体，关系图： 三要素： 实体：表 属性：列 关系：一对一，一对多，多对多 2.PowerDesinger简称：PD 是一个建模工具软件，可以利用这个软件绘制E-R图 3.使用PD创建E-R图的步骤：1.新建一个概念E-R图 2.创建实例，属性，并建立关系，如果是一对多，不要在多的那个实体中自定义外键列， 只需要建立一对多关系即可，外键会自动生成 3.将概念E-R图转换成Oracle的物理E-R图 4.生成建表的sql语句 思路：概念-&gt;物理-&gt;语句 4.多对多的实现方式：学生表 科目表 中间表 5.一对一：唯一外键： 是一对多的一个特例，在外键列上再增加一个unique约束即可； 相同主键： 两个表的主键是一个列，从表的主键列还是外键 6.范式：1NF：主键，列的值不能为一组值（集合） 2NF：满足1NF，消除部分依赖 3NF：满足2NF，消除传递依赖 BCNF","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之数据库对象","date":"2015-01-18T06:35:35.000Z","path":"2015/01/18/Oracle学习之数据库对象/","text":"1.数据库对象：表是最基本的数据库对象，作用是用来存储数据 2.其它常用的数据库对象：同义词： 序列： 视图： 索引： 函数： 存储过程： 触发器： 3.序列：用来产生唯一，连续的序号； 生成主键； Create sequence 序列名 Start with Increment by：增量 Maxvalue：最大值 Minvalue：最小值 Cycle | nocycle：是否循环 cache：缓存 如何使用序列： 一定要在sql语句中使用； 序列名.nextVal：下一个值 序列名.currVal：当前值 4.分析函数：Rank() over() 一起使用 Rank()：生成序号，如果比较大小时相同，则序号相同，下一个序列会空出来，的例如 1 1 3 Dense_rank()：生成序号，与rank相比，值相同，序号相同，但不同有空余的序号 1 1 2 Row_number()：函数与rownum伪列相同 Select rank() over(order by sal),emp.* from emp; 5.视图：一个命名的查询语句，也可称为虚拟表 优点： 安全 隔离基表的改变 创建视图： Create view view_name as 查询语句; 创建一个只读视图： Create view view_name as 查询语句 with read only; 对视图中的字段进行重命名： Create view view_name(新名) as 查询语句 对视图进行删除，插入，修改的操作： 如果对视图进行以上操作，实际上是对视图所关联的表进行操作，并不是所有的视图都可以做以上操作； 视图中的数据中的数据必须来自表中的真实数据才可以 6.索引：用来提高查询速度的一个对象： Create index 索引名 on 表名（列名） 7.数据库备份：dos下直接输入两个命令 导入： Imp 导出： Exp 8.数据字典：元数据的数据： $ Dba_ all_ user_tables…","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之DCL","date":"2015-01-17T05:24:41.000Z","path":"2015/01/17/Oracle学习之DCL/","text":"1.oracle常用的用户：Sys： 系统管理员 创建数据库，启动数据库，关闭数据库 System： 数据库管理员 数据库启动后，可以使用数据库的任何权限 scott： 示例用户 2.创建用户：Create user USER_NAME identified by PASSWORD; 3.oracle中权限的分类：系统权限： 用户使用系统资源的权限，例如：登陆，创建表，修改表，创建函数等 对象权限： 一个用户使用其他用户的资源，例如：利用scott来查询student用户的表 4.授权：Grant 权限 to 用户; Grant create session to student; 5.角色：即权限的组合（集合） 常用的角色： Connect 登陆 Resource 普通用户的常用权限的集合 dba 数据库管理员 6.撤销权限：Revoke 权限 from 用户 7.对象权限：例如： student能否删除，修改，查询scott.emp表 Grant select/insert/all on emp to student; Revokde select/insert/all on emp from student; 8.事务：Transaction 是用户自定义的一个操作序列，这个操作序列式一个最小的执行单元 也就是说，要么全做，要么一个都不执行 事务的四个特性：ACID 原子性 最小的执行单位，不能再分 一致性 执行前后，应该保持一致状态 隔离性 多个事务之间，互不干扰 持久性 一旦事务提交，不能回退 9.事务控制语句：Commit 提交 Rollback 回退 savepoint 设置保存点 10.事务所涉及的操作：Update Delete Insert 11.以下情况会提交事务：手动commit提交 正常退出sqlplus环境 执行DDL语句 执行DCL语句 12.解锁用户：Alter user username account unlock;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之常用函数","date":"2015-01-16T10:31:41.000Z","path":"2015/01/16/Oracle学习之常用函数/","text":"1.常用函数字符： Lower：转小写 lower(&apos;Name&apos;); Upper：转大写 upper(&apos;name&apos;); Ltrim：去掉左空格 Rtrim：去掉右空格 Trim：去掉两边空格 Length：求长度 Instr：求字串的位置 instr(&apos;I love china&apos;,&apos;china&apos;) : 8 Substr：截取子串 substr(&apos;I love&apos;,3,4) ：love Lpad：左边填充指定字符 lpad(&apos;hello&apos;,7,&apos;*&apos;) : **hello Rpad：右边填充指定字符 Initcap：将字符串每个首字母大写，其余转为小写 数字： Round：四舍五入 round(34.44) Trunc：直接截断 mod：取余 日期： Months_between：两个日期之间的越差 Months_between(date1,date2); Add_months：为日期增加几个月 Add_months(sysdate,4); sysdate：返回当前时间 Last_day：当前日期所在月的最后一天的日期 Last_day(sysdate); Next_day：指定日期后第一个星期几的日期 Next_day(sysdate,1); 日期直接+数字：代表加的是天数 转换： To_Date：将字符串转换成日期 To_date(&apos;19980908&apos;,&apos;yyyyMMdd&apos;); To_char：将日期转换成字符串 To_char(sysdate,&apos;yyyy-MM-dd&apos;); To_number：转换成数字 To_number(&apos; 1234&apos;,&apos;990000&apos;); 其他： nvl：对null进行处理的函数 Nvl(comm,0)：如果comm的值为空，返回0，否则，返回的还是comm的值 decode：解码，相当于if else语句 2.case语句：可以在查询中进行判断，语法是： Select Case When 条件1 then 结果 When 条件2 then 结果 Else 结果3 End score,name from emp;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之高级查询","date":"2015-01-15T10:29:13.000Z","path":"2015/01/15/Oracle学习之高级查询/","text":"#1.表连接： 内连接： (Oracle写法):select from table_name,table_name2 [where 条件]; (标准sql语法):select from emp inner join dept on dept.deptno=emp.deptno; 如果from后，加入多个表时，查询的结果应该是两个表中的乘积；(列的和，记录的积) 外连接： 左外连接： 以左边的表为准，将左表中的数据全都查询出来，如果右表没有对应的录，则在右表的字段内显示null; (Oracle写法)select from emp,dept where emp.dept=dept.deptno(+); (标准sql语法)select from emp left [outer] join dept on dept.deptno=emp.deptno; 右外连接： 以右边的表为准，将右表中的数据全都查询出来，如果左表没有对应的录，则在左表的字段内显示null; (Oracle写法)select from emp,dept where emp.dept(+)=dept.deptno; (标准sql语法)select from emp right [outer] join dept on dept.deptno=emp.deptno; 全外连接： 左右表中的数据都至少显示一次； (标准sql语法):select * from emp full [outer] join dept on dept.deptno=emp.deptno; 2.子查询(嵌套查询)： 指一个查询中还包含另外一个查询体，也可以理解为，将一个查询结果作为另一个查询的查询条件； 常用的谓词： Any, all, in, not in Exists 存在 select * from dept d where exists(sql查询); 如果exists中的查询有记录，返回true，否则，返回false； 实例： --查询sales或者research部门的员工 select * from emp where deptno in (select deptno from dept where dname=&apos;SALES&apos; or dname=&apos;RESEARCH&apos;); select * from dept; --查询比平均工资高的员工信息 select * from emp where sal&gt;(select avg(sal) from emp); --查询比20部门所有员工工资都高的员工信息 select * from emp where sal&lt;all(select sal from emp where deptno=30); --查询出没有员工的部门 1.select * from dept where deptno not in( select distinct deptno from emp); 2.select * from dept d where not exists (select * from emp where d.deptno=emp.deptno); 3.集合查询：交，并，差 要求：两个查询结果的列数一样，数据类型匹配 Union [all]: 并 不排序 Intersect: 交 Minus: 差 4.递归查询(树查询)：Connect by prior 后设置的是递归查询的连接条件 Start with 后设置的是从哪个记录开始进行递归查询 使用递归查询要求： 这个表中应该是一个自连接的表 可以使用level这个伪列，来查询层级值 实例： select level,emp.* from emp connect by prior empno=mgr start with mgr is null; 5.两个伪列Rownum 行号 行号的算法不是先生成编号，而是满足条件后，才生成行号； 因此不能使用where rownum=2,rownum&gt;3这样的语法，这样不会查出任何记录 Rowid 行的唯一标识 表空间 -&gt;段-&gt;区-&gt;块 比主键更唯一，在全局是唯一的 6.通过rownum可以实现Oracle的分页查询实例： select * from ( select rownum r,a.* from( select * from emp order by sal desc) a where rownum&lt;11) b where b.r&lt;5;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之DML","date":"2015-01-14T13:24:46.000Z","path":"2015/01/14/Oracle学习之DML/","text":"1.dml数据操作语言： 对表中的记录进行操作 Insert 插入 Update 修改更新 Delete 删除 Select 选择 2.insert:1.插入一整条记录： Insert into 表名 values(数据)； 2.指定字段： Insert into 表名(列名) values(); 3.一次性插入多条记录： Insert into 表名(列名) select语句; 3.update: 修改Update 表名 set 列名=新值[,列名2=新值,…][where 条件]; 4.delete: 删除Delete from 表名 [where 条件]; 5.select: 选择Select *|distinct 列名1,…. 表达式 from 表名或视图名 [where 条件] [group by 分组条件 [having 分组后条件]] [order by 排序字段 asc|desc]; 6.列别名的问题:如果在查询中需要给列重新设置一个别名，可以使用&lt;as 列别名&gt;的方式，as 可以省略， 如果别名中出现空格，整个别名应该用双引号引起; Select sal*15 as &quot;salary of year&quot; from emp; 7.to_char函数将日期转换为字符的函数 To_char(日期值,&apos;格式&apos;); 例如： To_char(hiredate,&apos;YYYY-MM-dd&apos;); 8.oralce中的连接字符串运算符使用||.9.常用查询条件：查询条件 谓词 比较 =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，not+上述比较运算符 确定范围 Between and，not between and 确定集合 In，not in 字符匹配 Like，not like 空 Is null， is not null 多重条件 And，or 10.in 的使用：In:可以确定一个不连续的范围： Select * from emp where job in(&quot;MANAGER&apos;,&apos;CLERK&apos;); Not in:不在一个范围： Select * from emp where job not in(&quot;MANAGER&apos;,&apos;CLERK&apos;); 11.like的使用：模糊查询： 通配符： _：任意一个字符； %：任意多个字符（0到多）； Select * from emp where ename like &apos;%A%&apos;; 12.对于null的比较：null代表空，只能通过特殊的运算符进行比较 Is null 或 is not null 如果通过=null进行比较，永远返回false 13.聚集函数：增强检索功能 函数 功能 Count([Distinct|ALL]*) 统计记录个数 Count([Distinct|ALL]&lt;列名&gt;) 统计一列中值的个数 SUM([Distinct|ALL]&lt;列名&gt;) 计算一列的总和(必须为数值型) AVG([Distinct|ALL]&lt;列名&gt;) 计算一列的平均值(必须为数值型) MAX([Distinct|ALL]&lt;列名&gt;) 计算一列的最大值(必须为数值型) MIN([Distinct|ALL]&lt;列名&gt;) 计算一列的最小值(必须为数值型)","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之Oracle基础","date":"2015-01-13T06:18:28.000Z","path":"2015/01/13/Oracle学习之Oracle基础/","text":"1.未来计划：Oracle:数据库，mySql， powerDesigner jdbc:操作数据库的API，反射，annotation web编程 Html css javascript javaEE: servlet, jsp, jstl, xml, ajax,jquery tomcat 项目实践 2.数据库产品类型：单机版： access; foxbase; 无法数据共享 网络版： mySQL: oracle公司的产品，免费开源 SQLServer: 微软 Oracle: Oracle公司 Db2: IBM公司 3.RDBMS的基本概念 表是最小的一个存储单元 整体思路：先将需要处理的数据进行分类后，存储在各个相互关联的表中 4.Oracle的主要服务：OracleXXXListener: 监听器1521 OracleSercviceXXX: Oracle实例 OracleDbConsoleXXX: Oracle企业管理器 常用工具： Oracle Universal Installer(Oracle全局安装器) 安装卸载数据库管理系统 Datebase Configuration Assistant(数据库配置助手) 创建/配置/删除/管理模板 Net Configuration Assistant(网络配置助手) 监听器/命名方法/本地网络服务名/目录使用配置 SQL PLUS Oracle 经典操作平台 基于命令行 SQL Developer Oracle 图形操作平台 基于java PL/SQL Developer 企业中广泛使用的操作平台 5.SQL语句的分类结构化查询语言： 数据定义语言(DDL)： Create, Drop, Alter, Truncate 数据操作语言(DML)： Upate, Insert, Delete, Select(增删改查) 数据控制语言(DCL)： Grant(授予),Revoke(解除) 事物控制语言(TCL)： commit, rollback, savepoint 6.Create：创建作用：创建数据库对象，例如： 表，用户，索引，视图 创建表的语法 create table 表名( 列名 数据类型 [约束], …………… , [表级约束] ) 7.Oracle数据类型：数字： number(4) 表示最多4位数 number(4,2) 表示最多4位数，2位小数 字符： varchar(10) 可变字符 最多10个长度，根据值开辟空间 char(10) 不可变字符 保证占10个长度 varchar2 nvarchar 可变字符 最多10个长度，根据值开辟空间 采用unicode字符集 日期： Date timeStamp 更精确 大对象： BLOB 4G/字段 存在数据库内部 BFILE 4G/字段 存在文件中 CLOB 4G/字段 大文本的 NCLOB 4G/字段 大文本的 采用unicode字符集 oracle数据库密码：Oracle123 8.创建一个学生表： Create table TB_STUDENT( sno number(5) primary key, sname varchar(20), sex varchar(5), birth date ); 查看表结构： Desc 表名; 9.对scott账户解锁：1.使用管理员登录 dos下： sqlplus / as sysdba 2.解锁： alter user scott account 3.改密码： alter user scott identified by tiger 4.重新登录 10.约束的类型：主键：一个表只能有一个主键，主键不能为空，不能重复，作用是唯一标识一条记录； primary key，主键通常与业务无关，无特殊含义。 非空：not null，不能为空，必填项 唯一：unique，不重复，可以为空，一个表可以有多个列是唯一约束 检查：check，可以自定义规则；比如性别 in(&apos;male&apos;,&apos;female&apos;) 外键：foreign key，外键的值必须在另一个表的主键中获取 11.insert语句：向表中插入记录 Insert into 表名 values(值,值2,…….); Insert into 表名(列名) values(值); 12.事例：create table t_person(pno number(5) primary key, 2 name varchar(20) not null, 3 email varchar(30) unique, 4 sex varchar(6) check (sex in (&apos;male&apos;,&apos;female&apos;)) 5 ); 13.修改表语句：ALTER TABLE &lt;表名&gt; ADD &lt;新列名&gt;&lt;数据类型&gt;[完整性约束] DROP &lt;完整性约束名&gt; MODIFY &lt;列名&gt;&lt;数据类型&gt; ; 向表添加新的列，修改列或删除列 添加表约束和删除表约束 1.添加新列 Alter table 表名 add 列名 列类型; 2.删除列 Alter table stu drop column sex; 3.修改列的类型 Alter table stu modify sex varchar(15); 4.添加主键 Alter table stu add primary key (id); 5.删除主键 Alter table stu drop primary key; 5.添加外键 Alter table test2 add constraint foreign_key_name foreign key (Name) references emp(EMPNO); 6.删除表： Drop table 表名; 删除表结构，表中的数据都将被删除; 7.截断表： Truncate table 表名; 将表中所有数据清空，表仍保留","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]}]