[{"title":"用Gradle构建Spring Boot项目","date":"2017-08-16T09:51:05.000Z","path":"2017/08/16/用Gradle构建Spring Boot项目/","text":"相比起Maven的XML配置方式，Gradle提供了一套简明的DSL用于构建Java项目，使我们就像编写程序一样编写项目构建脚本。本文将从无到有创建一个用Gradle构建的Spring Boot项目，并在此过程中讲到Gradle的一些典型用法。 创建Gradle工程Gradle采用了与Maven相同的目录组织结构，你可以通过Spring Initializr网站创建Spring Boot工程。但是在本文中，我们将全部通过命令行操作创建Spring Boot工程。首先在命令行中创建如下目录结构：src123456789101112`├── main│ └── java└── test└── java``然后在src同级目录中添加一个build.gradle文件，内容如下：`apply plugin: &apos;java&apos;`大功告成，一个用Gradle构建的Java项目创建好了，尽情用以下命令编译并打包咱们的Java项目吧：`gradle build`只是现在咱们的Java项目还是一个空架子，不用急，在下文中我们将一步一步在这个空架子中搭建一个有血有肉的Spring Boot项目。值得一提的是，虽然此时的build.gradle文件中只有一行配置（apply plugin: &apos;java&apos;，作用是引入java插件），但是其背后已经帮我们做了很多事情，比如它使得我们能够运行gradle build命令。这里的build即为Gradle中的一个任务（Task），我们还可以运行以下命令查看到更多的Task。`gradle tasks`此时输出： `…Build tasks assemble - Assembles the outputs of this project.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.classes - Assembles main classes.clean - Deletes the build directory.jar - Assembles a jar archive containing the main classes.testClasses - Assembles test classes.… 这里的assemble、build和jar等Task都是java插件引入的。build.gradle是Gradle的配置文件。 使用Gradle Wrapper对于所有的Gradle项目来说，笔者都推荐使用Gradle Wrapper，甚至应该将其当做创建代码库之后的第一件事来做。使用Gradle Wrapper有以下好处： 不用安装gradle也能运行gradle 所有人使用相同的gradle版本在build.gradle中加入以下配置：wrapper(type: Wrapper) &#123;1234567891011`gradleVersion = &apos;3.0&apos;&#125;``然后在命令行运行：`gradle wrapper`此时会生成以下三个文件（夹）：gradlew、gradlew.bat和gradle目录。这里的gradlew和gradlew.bat其实只是脚本文件（前者用于Unix/Linux/Mac，后者用于Windows），在使用gradle命令的地方替换为gradlew或gradlew.bat，他们将自动下载指定的gradle版本，然后用该版本进行项目构建。如上文所示，本文中我们配置gradle版本为3.0。请注意，这三个文件（夹）都需要提交到代码库中。当项目其他人拿到代码之后，由于gradlew和gradlew.bat文件均在源代码中，他们本地即便没有gradle，依然可以通过以下命令进行项目构建：`./gradlew build`如果你的项目有持续集成（CI）服务器（你也应该有），那么你的CI机器也没有必要安装Gradle了。另外，此时所有人都是使用的相同版本的gradle，进而避免了由于版本不同所带来的问题。# 添加Spring Boot依赖在本文中，我们的业务非常简单———输出“Hello World！”。但是麻雀虽小，五脏俱全，首先需要在build.gradle中配置spring-boot插件，并引入Spring的Web组件，整个build.gradle如下： `buildscript {repositories {jcenter()}dependencies {classpath(“org.springframework.boot:spring-boot-gradle-plugin:1.5.2.RELEASE”)}} repositories {jcenter()} apply plugin: ‘java’apply plugin: ‘org.springframework.boot’ sourceCompatibility = 1.8targetCompatibility = 1.8 task wrapper(type: Wrapper) {gradleVersion = ‘3.0’} dependencies {compile(“org.springframework.boot:spring-boot-starter-web”)testCompile(“org.springframework.boot:spring-boot-starter-test”)} 然后创建Application类：12345678910`@SpringBootApplicationpublic class Application &#123;public static void main(String[]() args) &#123;SpringApplication.run(Application.class, args);&#125;&#125;``依然很简单，是吧？！这个Application类便是Spring Boot程序的入口。另外我们还需要一个Controller和一个业务类HelloWorld： `HelloWorldController:@RestController(“/helloworld”)public class HelloController { private HelloWorld helloWorld; public HelloController(HelloWorld helloWorld) {this.helloWorld = helloWorld;} @GetMappingpublic String hello() {return helloWorld.hello();}}HelloWorld:@Componentpublic class HelloWorld { public String hello() {return “Hello World!”;}}`此时工程的目录结构为： ``` ├── README.md├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew├── gradlew.bat└── src├── main│ └── java│ └── davenkin│ ├── Application.java│ ├── HelloController.java│ └── HelloWorld.java└── test└── java`然后运行：./gradlew bootRun`在浏览器或者Postman中打开http://localhost:8080/gradle-spring-boot/helloworld，便可以看到久违的”Hello World！”了。","tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://vvshyer.com/tags/Gradle/"}]},{"title":"Spring Boot","date":"2017-07-19T09:59:50.000Z","path":"2017/07/19/Spring Boot/","text":"Spring Boot 是什么 为所有Spring 开发提供一个更快更广泛的入门体验 开箱即用，不合适时也可以快速抛弃 提供一系列大型项目常用的非功能性特征 零配置（无需XML配置，遵循“约定大于配置”）Spring Boot 简化开发抛弃了传统JavaEE项目繁琐的配置、学习过程，让企业级应用开发过程变得更容易。Spring Boot与其他框架的关系通过Spring Initializr初始化一个Web项目http://start.spring.io/","tags":[{"name":"Spring","slug":"Spring","permalink":"https://vvshyer.com/tags/Spring/"}]},{"title":"Spring","date":"2017-06-28T11:59:50.000Z","path":"2017/06/28/mmall之Spring/","text":"Spring 学习spring-projects/spring-mvc-showcasespring-projects/spring-petclinicspring-projects/greenhouse","tags":[{"name":"Spring","slug":"Spring","permalink":"https://vvshyer.com/tags/Spring/"}]},{"title":"Spring框架第一天","date":"2017-04-01T09:59:50.000Z","path":"2017/04/01/Spring4_day01/","text":"今天课程：Spring框架第一天 Spring框架的学习路线 1. Spring第一天：Spring的IOC容器之XML的方式，Spring框架与Web项目整合 2. Spring第二天：Spring的IOC容器之注解的方式，Spring的AOP技术 3. Spring第三天：Spring的事务管理、Spring框架的JDBC模板 4. Spring第四天：SSH三大框架的整合 今天内容概述 1. Spring框架的概述 2. SpringIOC的快速入门 3. IoC容器XML的方式 4. 在web项目中集成Spring 案例一：使用Spring的IOC技术完成客户的保存功能 需求分析 1. 使用Spring的IOC技术完成客户的保存功能 技术分析之Spring框架的概述和入门 技术分析之什么是Spring框架 1. Spring框架的概述 * Spring是一个开源框架 * Spring是于2003 年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。 * 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 * Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以 从Spring中受益。 * Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。 * EE开发分成三层结构 * WEB层 -- Spring MVC * 业务层 -- Bean管理:(IOC) * 持久层 -- Spring的JDBC模板.ORM模板用于整合其他的持久层框架 技术分析之Spring框架的特点 1. 为什么要学习Spring的框架 * 方便解耦，简化开发 * Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理 * AOP编程的支持 * Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 * 声明式事务的支持 * 只需要通过配置就可以完成对事务的管理，而无需手动编程 * 方便程序的测试 * Spring对Junit4支持，可以通过注解方便的测试Spring程序 * 方便集成各种优秀框架 * Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持 * 降低JavaEE API的使用难度 * Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低 2. Spring框架的版本 * Spring3.x和Spring4.x的版本 技术分析之Spring框架的IOC核心功能快速入门 1. 什么是IOC的功能？ * IoC -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！ * 使用IOC可以解决的程序耦合性高的问题！！ 2. 步骤一：下载Spring框架的开发包 * 官网：http://spring.io/ * 下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:) * docs -- API和开发规范 * libs -- jar包和源码 * schema -- 约束 3. 步骤二：创建JavaWEB项目，引入Spring的开发包 * 引入Spring框架IOC核心功能需要的具体的jar包 * Spring框架的IOC的功能，那么根据Spring框架的体系结构图能看到，只需要引入如下的jar包 * Beans * Core * Context * Expression Language * Spring框架也需要引入日志相关的jar包 * 在spring-framework-3.0.2.RELEASE-dependencies/org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1 * com.springsource.org.apache.commons.logging-1.1.1.jar * 还需要引入log4j的jar包 spring-framework-3.0.2.RELEASE-dependencies\\org.apache.log4j\\com.springsource.org.apache.log4j\\1.2.15 * com.springsource.org.apache.log4j-1.2.15.jar 4. 步骤三：创建对应的包结构，编写Java的类，要注意：以后使用Spring框架做开发，都需要来编写接口与实现类！！ * com.itcast.demo1 * UserService -- 接口 * UserServiceImpl -- 具体的实现类 5. 步骤四：想把UserServiceImpl实现类的创建交给Spring框架来管理，需要创建Spring框架的配置文件，完成配置 * 在src目录下创建applicationContext.xml的配置文件，名称是可以任意的，但是一般都会使用默认名称！！ * 引入spring的约束，需要先找到具体的约束头信息！！ * spring-framework-3.2.0.RELEASE\\docs\\spring-framework-reference\\html\\xsd-config.html * 具体的约束如下： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; * 完成UserService的配置 &lt;!-- Spring的快速入门 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itcast.demo1.UserServiceImpl&quot;/&gt; 6. 步骤五：编写测试程序，采用Spring框架的工厂方式来获取到UserService接口的具体实现类！！ public void demo2(){ // 使用Spring的工厂: ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 通过工厂获得类: UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.sayHello(); } 入门总结之Spring框架中的工厂（了解） 1. ApplicationContext接口 * 使用ApplicationContext工厂的接口，使用该接口可以获取到具体的Bean对象 * 该接口下有两个具体的实现类 * ClassPathXmlApplicationContext -- 加载类路径下的Spring配置文件 * FileSystemXmlApplicationContext -- 加载本地磁盘下的Spring配置文件 2. BeanFactory工厂（是Spring框架早期的创建Bean对象的工厂接口） * 使用BeanFactory接口也可以获取到Bean对象 public void run(){ BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;)); UserService us = (UserService) factory.getBean(&quot;us&quot;); us.sayHello(); } * BeanFactory和ApplicationContext的区别 * BeanFactory -- BeanFactory采取延迟加载，第一次getBean时才会初始化Bean * ApplicationContext -- 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能 * 事件传递 * Bean自动装配 * 各种不同应用层的Context实现 入门总结之配置Spring框架编写XML的提示 1. 步骤一：先复制， http://www.springframework.org/schema/beans/spring-beans.xsd 2. 步骤二：搜索XML Catalog，点击Add按钮 3. 步骤三：先选择Location的schema的约束地址 * E:\\class\\2016\\JavaEE28\\day35_Spring框架第一天\\资料\\spring-framework-4.2.4.RELEASE-schema\\beans\\spring-beans-4.2.xsd 4. 步骤四：注意：Key type要选择：Schema location 5. 步骤五：Key把http://www.springframework.org/schema/beans/spring-beans.xsd复制上 技术分析之Spring框架的Bean管理的配置文件方式 技术分析之Spring框架中标签的配置 1. id属性和name属性的区别 * id -- Bean起个名字，在约束中采用ID的约束，唯一 * 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号 id:不能出现特殊字符 * name -- Bean起个名字，没有采用ID的约束（了解） * 取值要求：name:出现特殊字符.如果&lt;bean&gt;没有id的话 , name可以当做id使用 * Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以/开头的，例如：/bookAction 2. class属性 -- Bean对象的全路径 3. scope属性 -- scope属性代表Bean的作用范围 * singleton -- 单例（默认值） * prototype -- 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！ * request -- 应用在Web项目中,每次HTTP请求都会创建一个新的Bean * session -- 应用在Web项目中,同一个HTTP Session 共享一个Bean * globalsession -- 应用在Web项目中,多服务器间的session 4. Bean对象的创建和销毁的两个属性配置（了解） * 说明：Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法 * init-method -- 当bean被载入到容器的时候调用init-method属性指定的方法 * destroy-method -- 当bean从容器中删除的时候调用destroy-method属性指定的方法 * 想查看destroy-method的效果，有如下条件 * scope= singleton有效 * web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法） 技术分析之依赖注入（DI） 1. IOC和DI的概念 * IOC -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！ * DI -- Dependency Injection，依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！ 2. DI（依赖注入） * 例如：如果UserServiceImpl的实现类中有一个属性，那么使用Spring框架的IOC功能时，可以通过依赖注入把该属性的值传入进来！！ * 具体的配置如下 &lt;bean id=&quot;us&quot; class=&quot;com.vvshyer.demo1.UserServiceImpl&quot;&gt; &lt;property name=&quot;uname&quot; value=&quot;小风&quot;/&gt; &lt;/bean&gt; 技术分析之Spring框架的属性注入 1. 对于类成员变量，常用的注入方式有两种 * 构造函数注入 * 属性setter方法注入 2. 在Spring框架中提供了前两种的属性注入的方式 1. 构造方法的注入方式，两步 * 编写Java的类，提供构造方法 public class Car { private String name; private double money; public Car(String name, double money) { this.name = name; this.money = money; } @Override public String toString() { return &quot;Car [name=&quot; + name + &quot;, money=&quot; + money + &quot;]&quot;; } } * 编写配置文件 &lt;bean id=&quot;car&quot; class=&quot;com.vvshyer.demo4.Car&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;大奔&quot;/&gt; &lt;constructor-arg name=&quot;money&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt; 2. 属性的setter方法的注入方式 * 编写Java的类，提供属性和对应的set方法即可 * 编写配置文件 3. 如果Java类的属性是另一个Java的类，那么需要怎么来注入值呢？ * &lt;property name=&quot;name&quot; rel=&quot;具体的Bean的ID或者name的值&quot;/&gt; * 例如： &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot;&gt; &lt;property name=&quot;pname&quot; value=&quot;美美&quot;/&gt; &lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&gt; &lt;/bean&gt; 技术分析之Spring的2.5版本中提供了一种:p名称空间的注入（了解） 1. 步骤一：需要先引入 p 名称空间 * 在schema的名称空间中加入该行：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 2. 步骤二：使用p名称空间的语法 * p:属性名 = &quot;&quot; * p:属性名-ref = &quot;&quot; 3. 步骤三：测试 * &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot; p:pname=&quot;老王&quot; p:car2-ref=&quot;car2&quot;/&gt; 技术分析之Spring的3.0提供了一种:SpEL注入方式（了解） 1. SpEL：Spring Expression Language是Spring的表达式语言，有一些自己的语法 2. 语法 * #{SpEL} 3. 例如如下的代码 &lt;!-- SpEL的方式 --&gt; &lt;bean id=&quot;person&quot; class=&quot;com.vvshyer.demo4.Person&quot;&gt; &lt;property name=&quot;pname&quot; value=&quot;#{&apos;小风&apos;}&quot;/&gt; &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt; &lt;/bean&gt; 4. 还支持调用类中的属性或者方法 * 定义类和方法，例如 public class CarInfo { public String getCarname(){ return &quot;奇瑞QQ&quot;; } } 技术分析之数组，集合(List,Set,Map)，Properties等的注入 1. 如果是数组或者List集合，注入配置文件的方式是一样的 &lt;bean id=&quot;collectionBean&quot; class=&quot;com.vvshyer.demo5.CollectionBean&quot;&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;美美&lt;/value&gt; &lt;value&gt;小风&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 2. 如果是Set集合，注入的配置文件方式如下： &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;哈哈&lt;/value&gt; &lt;value&gt;呵呵&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 3. 如果是Map集合，注入的配置方式如下： &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;老王2&quot; value=&quot;38&quot;/&gt; &lt;entry key=&quot;凤姐&quot; value=&quot;38&quot;/&gt; &lt;entry key=&quot;如花&quot; value=&quot;29&quot;/&gt; &lt;/map&gt; &lt;/property&gt; 4. 如果是properties属性文件的方式，注入的配置如下： &lt;property name=&quot;pro&quot;&gt; &lt;props&gt; &lt;prop key=&quot;uname&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;pass&quot;&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; 技术分析之Spring框架的配置文件分开管理（了解） 1. 例如：在src的目录下又多创建了一个配置文件，现在是两个核心的配置文件，那么加载这两个配置文件的方式有两种！ * 主配置文件中包含其他的配置文件: &lt;import resource=&quot;applicationContext2.xml&quot;/&gt; * 工厂创建的时候直接加载多个配置文件: ApplicationContext applicationContext = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;); Spring框架整合WEB Spring框架整合WEB（不是最终的方案） 1. 创建JavaWEB项目，引入Spring的开发包。编写具体的类和方法。 * 环境搭建好后，启动服务器来测试项目，发送每访问一次都会加载一次配置文件，这样效率会非常非常慢！！ 2. 解决上面的问题 * 将工厂创建好了以后放入到ServletContext域中.使用工厂的时候,从ServletContext中获得. * ServletContextListener:用来监听ServletContext对象的创建和销毁的监听器. * 当ServletContext对象创建的时候:创建工厂 , 将工厂存入到ServletContext 3. Spring整合Web项目 * 引入spring-web-4.2.4.RELEASE.jar包 * 配置监听器 &lt;!-- 配置Spring的核心监听器: --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 4. 修改servlet的代码 * 从ServletContext中获得工厂 * 具体代码如下 ServletContext servletContext = ServletActionContext.getServletContext(); // 需要使用WEB的工厂的方式 WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext); CustomerService cs = (CustomerService) context.getBean(&quot;customerService&quot;); cs.save();","tags":[{"name":"Spring","slug":"Spring","permalink":"https://vvshyer.com/tags/Spring/"}]},{"title":"计算机网络笔记03","date":"2017-03-31T11:51:40.000Z","path":"2017/03/31/计算机网络笔记03/","text":"第三章 数据链路层3.1 数据链路层的基本概念链路：一条无源的点到点的物理线路段，中间没有其他任何交换结点。 数据链路：把实现这些协议的硬件和软件加到链路上，就构成数据链路。 帧：在数据链路层传输的数据单位。 数据链路层的主要功能 链路管理 帧定界 流量控制 差错控制 将数据和控制信息区分开 透明传输 寻址3.2 停止等待协议3.2.1 完全理想化的数据传输3.2.2 具有最简单流量控制的数据链路层协议算法12345678910111213141516171819202122232425262728293031323334353637 在发送结点： 1.从主机取一个数据帧 2.将数据帧送到数据链路层的发送缓存 3.将发送缓存中的数据帧发送出去 4.等待 5.若收到由接收结点发过来的信息（格式内容事先商定），则从主机取一个新的数据帧，然后转道到2 在接收结点： 1.等待 2.若收到由发送结点发过来的数据帧，则将其放入数据链路层的接收缓存 3。将接收缓存中的数据帧上交主机 4.向发送结点发一信息，表示数据帧已经上交给主机 5.转到1``` ### 3.2.3 实用的停止等待协议![](/assets/network/ch3p01.png)重传时间：略大于“从发完数据帧到收到确认帧所需的平均时间”解决重复帧的问题： * 使每一个数据帧带上不同的发送序号，每发送一个新的数据帧就把它的发送序号加1 * 若结点B收到发送序号相同的数据帧，就表明出现了重复帧。这时应丢弃重复帧，因为已经收到过同样的数据帧并且也交给了主机B * 但此时结点B还必须向A发送确认帧ACK，因为B已经知道A还没收到上一次发过去的确认帧ACK帧的编号问题： * 对于停止等待协议，由于每发送一个数据帧就停止等待，因此一个比特编号就够了。（表示0和1两种不同的序号）数据链路层的停止等待协议采用了有效的检错重传机制，对网络层提供*可靠传输*的服务 ### 3.2.4 循环冗余检验的原理![](/assets/network/ch3p02.png)帧检验序列FCS：在数据后面添加上的冗余码称为帧检验序列FCS ### 3.2.5 停止等待协议的算法* 收发双方实行停止等待* V(S):发送序号状态变量* V(R):接收序号状态变量* N(S):帧的序号* 序号只占1bit 在发送结点：(1) 从主机取一个数据帧，送交发送缓存。(2) V(S)←0。(3) N(S)←V(S)。(4) 将发送缓存中的数据帧发送出去。(5) 设置超时计时器。(6) 等待。 {等待以下三个事件中最先出现的一个}(7) ACK收到确认帧 ， 从主机取一个新的数据帧，放入发送缓存； V(S)←[1-V(S)]，转到 (3)。(8) 收到否认帧NAK， 丢弃这个确认帧，转到(4)。(9) 若超时计时器时间到，则转到(4)。 在接收结点：(1) V(R)←0。(2) 等待。(3) 收到一个数据帧； 若 CRC校验无误 若 N(S) = V(R)，则执行(4)； 否则丢弃此数据帧，然后转到(6)。 否则丢弃此数据帧，发送NAK，然后转到(2)。(4) 将收到的数据帧中的数据部分送交上层软件 （也就是数据链路层模型中的主机）。(5) V(R)←[1-V(R)]。(6) 发送确认帧ACK，转到(2)。12 (1) 从主机取一个数据帧，送交发送缓存。(2) V(S)←0。(3) N(S)←V(S)。(4) 将发送缓存中的数据帧发送出去。(5) 设置超时计时器。(6) 等待。(7) 收到确认帧 ACKn， 若 n = 1 – V(s)，则： 从主机取一个新的数据帧，放入发送缓存； V(S)←[1 V(S)]，转到 (3)。 否则，丢弃这个确认帧，转到(6)。(8) 若超时计时器时间到，则转到(4)。 (1) V(R)←0。(2) 等待。(3) 收到一个数据帧； 若 CRC校验无误 若 N(S) = V(R)，则执行(4)； 否则丢弃此数据帧，然后转到(6)。 否则丢弃此数据帧，然后转到(2)。(4) 将收到的数据帧中的数据部分送交上层软件(5) V(R)←[1 V(R)]。(6) n←V(R)； 发送确认帧 ACKn，转到(2)。``` 停止等待协议ARQ的优点缺点 优点：比较简单 缺点：通信信道的利用率不高3.3 连续 ARQ 协议3.3.1 连续 ARQ 协议的工作原理3.3.2 连续 ARQ 协议的吞吐量3.3.3 滑动窗口的概念3.3.4 信道利用率与最佳帧长3.4 选择重传 ARQ 协议3.5 面向比特的链路层协议 HDLC两种链路配置 非平衡配置 平衡配置三种响应方式 正常响应方式 异步响应方式 异步平衡响应方式3.6 因特网的点对点协议 PPP","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://vvshyer.com/tags/计算机网络/"}]},{"title":"Struts2第三天","date":"2017-03-28T11:59:50.000Z","path":"2017/03/28/Struts2_day03/","text":"Struts2第三天 课程回顾：Struts2框架的第二天 1. Servlet的API * ActionContext对象 * ServletActionContext对象 2. 结构类型的跳转 * 全局结果 * 局部结构，type属性 3. 数据的封装 * 属性驱动方式 * 模型驱动方式 4. 拦截器（自定义拦截器） 今天的课程内容 1. OGNL表达式（了解） 2. Struts2框架的值栈（值栈、存入值、取值） 3. OGNL的特殊符号 案例一：使用Struts2框架查询所有的客户功能 需求分析 1. 使用Struts2框架查询所有的客户功能 技术分析之OGNL表达式概述（了解） 1. OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写 * 所谓对象图，即以任意一个对象为根，通过OGNL可以访问与这个对象关联的其它对象 * 通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性 2. Struts2框架使用OGNL作为默认的表达式语言 * OGNL是一种比EL强大很多倍的语言 * xwork提供 OGNL表达式 * ognl-3.0.5.jar 3. OGNL 提供五大类功能 * 支持对象方法调用 * 支持类静态的方法调用和值访问 * 访问OGNL上下文（OGNL context）和ActionContext * 支持赋值操作和表达式串联 * 操作集合对象 4. 测试的代码 // 访问对象的方法 @Test public void run1() throws OgnlException{ OgnlContext context = new OgnlContext(); // 获取对象的方法 Object obj = Ognl.getValue(&quot;&apos;helloworld&apos;.length()&quot;, context, context.getRoot()); System.out.println(obj); } // 获取OGNL上下文件的对象 @Test public void run3() throws OgnlException{ OgnlContext context = new OgnlContext(); context.put(&quot;name&quot;, &quot;美美&quot;); // 获取对象的方法 Object obj = Ognl.getValue(&quot;#name&quot;, context, context.getRoot()); System.out.println(obj); } // 从root栈获取值 @Test public void demo3() throws OgnlException{ OgnlContext context = new OgnlContext(); Customer c = new Customer(); c.setCust_name(&quot;haha&quot;); context.setRoot(c); String name = (String) Ognl.getValue(&quot;cust_name&quot;, context, context.getRoot()); System.out.println(name); } 技术分析之在Struts2框架中使用OGNL表达式 1. Struts2引入了OGNL表达式，主要是在JSP页面中获取值栈中的值 2. 具体在Struts2中怎么使用呢？如下步骤 * 需要先引入Struts2的标签库 &gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; * 使用Struts2提供的标签中的标签 &gt; &lt;s:property value=&quot;OGNL表达式&quot;/&gt; 3. 在JSP页面使用OGNL表达式 * 访问对象方法 &lt;s:property value=&quot;&apos;hello&apos;.length()&quot;/&gt; 技术分析之值栈的概述 1. 问题一：什么是值栈？ * 值栈就相当于Struts2框架的数据的中转站，向值栈存入一些数据。从值栈中获取到数据。 * ValueStack 是 struts2 提供一个接口，实现类 OgnlValueStack ---- 值栈对象 （OGNL是从值栈中获取数据的 ） * Action是多例的，有一起请求，创建Action实例，创建一个ActionContext对象，代表的是Action的上下文对象，还会创建一个ValueStack对象。 * 每个Action实例都有一个ValueStack对象 （一个请求 对应 一个ValueStack对象 ） * 在其中保存当前Action 对象和其他相关对象 * Struts 框架把 ValueStack 对象保存在名为 “struts.valueStack” 的请求属性中,request中 （值栈对象 是 request一个属性） * ValueStack vs = (ValueStack)request.getAttribute(&quot;struts.valueStack&quot;); 技术分析之值栈的内部结构 2. 问题二 ： 值栈的内部结构 ？ * 值栈由两部分组成 &gt; root -- Struts把动作和相关对象压入 ObjectStack 中--List &gt; context -- Struts把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中 * Struts会默认把下面这些映射压入ContextMap（context）中 * 注意：request代表的是Map集合的key值，value的值其实也是一个Map集合。 &gt; parameters: 该 Map 中包含当前请求的请求参数 ?name=xxx&amp;password=123 &gt; request: 该 Map 中包含当前 request 对象中的所有属性 &gt; session: 该 Map 中包含当前 session 对象中的所有属性 &gt; application:该 Map 中包含当前 application 对象中的所有属性 &gt; attr: 该 Map 按如下顺序来检索某个属性: request, session, application * ValueStack中 存在root属性 (CompoundRoot) 、 context 属性 （OgnlContext ） &gt; CompoundRoot 就是ArrayList &gt; OgnlContext 就是 Map * context 对应Map 引入 root对象 &gt; context中还存在 request、 session、application、 attr、 parameters 对象引用 &gt; OGNL表达式访问值栈中的数据 * 访问root中数据时 不需要 # * 访问 request、 session、application、 attr、 parameters 对象数据 必须写 # &gt; 操作值栈 默认指 操作 root 元素 技术分析之值栈的创建和ActionContext对象的关系 3. 问题三 ： 值栈对象的创建，ValueStack 和 ActionContext 是什么关系？ * 值栈对象是请求时创建的 * ActionContext是绑定到当前的线程上，那么在每个拦截器或者Action中获取到的ActionContext是同一个。 * ActionContext中存在一个Map集合，该Map集合和ValueStack的context是同一个地址。 * ActionContext中可以获取到ValueStack的引用，以后再开发，使用ActionContext来获取到值栈对象 技术分析之获取到值栈的对象 4. 问题四 ： 如何获得值栈对象 * 获得值栈对象 有三种方法 * ValueStack vs1 = (ValueStack) ServletActionContext.getRequest().getAttribute(&quot;struts.valueStack&quot;); * ValueStack vs2 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); * ValueStack vs3 = ActionContext.getContext().getValueStack(); 技术分析之向值栈中保存数据 5. 问题五： 向值栈保存数据 （主要针对root栈） &gt; valueStack.push(Object obj); * push方法的底层调用root对象的push方法（把元素添加到0位置） &gt; valueStack.set(String key, Object obj); * 源码获取map集合（map有可能是已经存在的，有可能是新创建的），把map集合push到栈顶，再把数据存入到map集合中。 &gt; 在jsp中 通过 &lt;s:debug /&gt; 查看值栈的内容 技术分析之从值栈中获取值 6. 问题六： 在JSP中获取值栈的数据 * 总结几个小问题： &gt; 访问root中数据 不需要# &gt; 访问context其它对象数据 加 # &gt; 如果向root中存入对象的话，优先使用push方法。 &gt; 如果向root中存入集合的话，优先要使用set方法。 * 在OgnlContext中获取数据 &gt; 在Action中向域对象中存入值 &gt; request:&lt;s:property value=&quot;#request.username&quot;/&gt; &gt; session:&lt;s:property value=&quot;#session.username&quot;/&gt; &gt; application:&lt;s:property value=&quot;#application.username&quot;/&gt; &gt; attr:&lt;s:property value=&quot;#attr.username&quot;/&gt; &gt; parameters:&lt;s:property value=&quot;#parameters.cid&quot;/&gt; 6.1 代码如下 &lt;!-- // vs.push(&quot;美美&quot;); // 获取到栈顶的值 &lt;s:property value=&quot;[0].top&quot;/&gt; --&gt; &lt;!-- // 栈顶是map集合，通过key获取值 vs.set(&quot;msg&quot;, &quot;小凤&quot;); &lt;s:property value=&quot;[0].top.msg&quot;/&gt; --&gt; &lt;!-- vs.push(user); // 栈顶放user对象 &lt;s:property value=&quot;[0].top.username&quot;/&gt; &lt;s:property value=&quot;[0].top.password&quot;/&gt; // [0].top 关键字是可以省略的 findValue() &lt;s:property value=&quot;username&quot;/&gt; --&gt; &lt;!-- vs.set(&quot;user&quot;, user); &lt;s:property value=&quot;[0].top.user.username&quot;/&gt; &lt;s:property value=&quot;[0].top.user.password&quot;/&gt; // 省略关键字 &lt;s:property value=&quot;user.username&quot;/&gt; --&gt; &lt;!-- // 在ValueStack1Action提供了成员的属性 private User user = new User(&quot;小泽&quot;,&quot;456&quot;); public User getUser() { return user; } public void setUser(User user) { this.user = user; } User user = new User(&quot;小苍&quot;,&quot;123&quot;); vs.set(&quot;user&quot;, user); // 从栈顶开始查找，找user的属性，显示名称 返回的小苍 &lt;s:property value=&quot;user.username&quot;/&gt; // [1].top获取ValueStack1Action [1].top.user返回user对象 [1].top.user.username获取对象的属性名称 &lt;s:property value=&quot;[1].top.user.username&quot;/&gt; --&gt; &lt;!-- 栈顶是list集合 vs.push(ulist); &lt;s:property value=&quot;[0].top[0].username&quot;/&gt; &lt;s:property value=&quot;[0].top[1].username&quot;/&gt; --&gt; &lt;!-- vs.set(&quot;ulist&quot;, ulist); &lt;s:property value=&quot;ulist[0].username&quot;/&gt; --&gt; &lt;!-- 迭代的标签 属性 * value 要迭代的集合，需要从值栈中获取 * var 迭代过程中，遍历的对象 * var编写上，把迭代产生的对象默认压入到context栈中，从context栈取值，加#号 * var不编写，默认把迭代产生的对象压入到root栈中 for(User user:ulist){} // 编写var的属性 &lt;s:iterator value=&quot;ulist&quot; var=&quot;u&quot;&gt; &lt;s:property value=&quot;#u.username&quot;/&gt; &lt;s:property value=&quot;#u.password&quot;/&gt; &lt;/s:iterator&gt; // 没有编写var关键字 &lt;s:iterator value=&quot;ulist&quot;&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;/s:iterator&gt; --&gt; &lt;!-- 从context栈中获取值，加#号 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(&quot;msg&quot;, &quot;美美&quot;); request.getSession().setAttribute(&quot;msg&quot;, &quot;小风&quot;); &lt;s:property value=&quot;#request.msg&quot;/&gt; &lt;s:property value=&quot;#session.msg&quot;/&gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt; &lt;s:property value=&quot;#attr.msg&quot;/&gt; --&gt; &lt;!-- 在JSP页面上，查看值栈的内部结构 --&gt; &lt;s:debug&gt;&lt;/s:debug&gt; 技术分析之EL表达式也会获取到值栈中的数据 7. 问题七：为什么EL也能访问值栈中的数据？ * StrutsPreparedAndExecuteFilter的doFilter代码中 request = prepare.wrapRequest(request); &gt; 对Request对象进行了包装 ，StrutsRequestWrapper &gt; 增强了request的 getAttribute Object attribute = super.getAttribute(s); if (attribute == null) { attribute = stack.findValue(s); } &gt; 访问request范围的数据时，如果数据找不到，去值栈中找 &gt; request对象 具备访问值栈数据的能力 （查找root的数据） 总结OGNL表达式的特殊的符号 1. # 符号的用法 * 获得contextMap中的数据 &gt; &lt;s:property value=&quot;#request.name&quot;/&gt; &gt; &lt;s:property value=&quot;#session.name&quot;/&gt; &gt; &lt;s:property value=&quot;#application.name&quot;/&gt; &gt; &lt;s:property value=&quot;#attr.name&quot;/&gt; &gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt; &gt; &lt;s:property value=&quot;#parameters.name&quot;/&gt; * 构建一个map集合 * 例如： * &lt;s:radio name=&quot;sex&quot; list=&quot;{&apos;男&apos;,&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt; * &lt;s:radio name=&quot;sex&quot; list=&quot;#{&apos;0&apos;:&apos;男&apos;,&apos;1&apos;:&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt; 2. % 符号的用法 * 强制字符串解析成OGNL表达式。 &gt; 例如：在request域中存入值，然后在文本框（&lt;s:textfield&gt;）中取值，现在到value上。 &gt; &lt;s:textfield value=&quot;%{#request.msg}&quot;/&gt; * { }中值用&apos;&apos;引起来,此时不再是ognl表达式,而是普通的字符串 &gt; 例如：&lt;s:property value=&quot;%{&apos;#request.msg&apos;}&quot;/&gt; 3. $ 符号的用法 * 在配置文件中可以使用OGNL表达式，例如：文件下载的配置文件。 &lt;action name=&quot;download1&quot; class=&quot;cn.itcast.demo2.DownloadAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt; &lt;param name=&quot;contentType&quot;&gt;${contentType}&lt;/param&gt; &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${downFilename}&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://vvshyer.com/tags/Struts2/"}]},{"title":"Struts2第二天","date":"2017-03-28T10:59:50.000Z","path":"2017/03/28/Struts2_day02/","text":"Struts2的第二天 课程回顾：Struts2框架第一天 1. Struts2框架的概述，前端控制器的模式，核心的过滤器 2. 入门，编写struts.xml配置文件 3. 配置文件 * 配置文件的加载 4. Action类的编写和访问 Struts2的第二天的内容 1. Struts2框架中的Servlet的API的使用 2. Struts2中Action接收请求参数 3. Struts2中自定义拦截器 案例一：使用Struts2作为WEB层完成客户的新增功能 需求分析 1. 原来是使用Servlet作为WEB层框架，现在需要使用Struts2作为WEB层完成客户的新增功能 技术分析之在Struts2框架中使用Servlet的API 1. 在Action类中也可以获取到Servlet一些常用的API * 需求：提供JSP的表单页面的数据，在Action中使用Servlet的API接收到，然后保存到三个域对象中，最后再显示到JSP的页面上。 * 提供JSP注册的页面，演示下面这三种方式 &lt;h3&gt;注册页面&lt;/h3&gt; &lt;form action=&quot;${ pageContext.request.contextPath }/xxx.action&quot; method=&quot;post&quot;&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt; &lt;/form&gt; 2. 完全解耦合的方式 * 如果使用该种方式，Struts2框架中提供了一个类，ActionContext类，该类中提供一些方法，通过方法获取Servlet的API * 一些常用的方法如下 * static ActionContext getContext() -- 获取ActionContext对象实例 * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getParameters() -- 获取请求参数，相当于request.getParameterMap(); * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getSession() -- 获取的代表session域的Map集合，就相当于操作session域。 * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getApplication() -- 获取代表application域的Map集合 * void put(java.lang.String key, java.lang.Object value) -- 注意：向request域中存入值。 3. 使用原生Servlet的API的方式 * Struts2框架提供了一个类，ServletActionContext，该类中提供了一些静态的方法 * 具体的方法如下 * getPageContext() * getRequest() * getResponse() * getServletContext() 技术分析之结果页面的跳转 1. 结果页面存在两种方式 * 全局结果页面 &gt; 条件：如果&lt;package&gt;包中的一些action都返回success，并且返回的页面都是同一个JSP页面，这样就可以配置全局的结果页面。 &gt; 全局结果页面针对的当前的包中的所有的Action，但是如果局部还有结果页面，会优先局部的。使用的标签是 &lt;global-results&gt; &lt;result&gt;/demo3/suc.jsp&lt;/result&gt; &lt;/global-results&gt; * 局部结果页面 &lt;result&gt;/demo3/suc.jsp&lt;/result&gt; 2. 结果页面的类型 * 结果页面使用&lt;result&gt;标签进行配置，包含两个属性 &gt; name -- 逻辑视图的名称 &gt; type -- 跳转的类型，值一些，需要掌握一些常用的类型。常见的结果类型去struts-default.xml中查找。 * dispatcher -- 转发.type的默认值.Action---&gt;JSP * redirect -- 重定向. Action---&gt;JSP * chain -- 多个action之间跳转.从一个Action转发到另一个Action. Action---Action * redirectAction -- 多个action之间跳转.从一个Action重定向到另一个Action. Action---Action * stream -- 文件下载时候使用的 技术分析之Struts2框架的数据封装 1. 为什么要使用数据的封装呢？ * 作为MVC框架，必须要负责解析HTTP请求参数，并将其封装到Model对象中 * 封装数据为开发提供了很多方便 * Struts2框架提供了很强大的数据封装的功能，不再需要使用Servlet的API完成手动封装了！！ 2. Struts2中提供了两类数据封装的方式？ * 第一种方式：属性驱动 &gt; 提供对应属性的set方法进行数据的封装。 * 表单的哪些属性需要封装数据，那么在对应的Action类中提供该属性的set方法即可。 * 表单中的数据提交，最终找到Action类中的setXxx的方法，最后赋值给全局变量。 * 注意0：Struts2的框架采用的拦截器完成数据的封装。 * 注意1：这种方式不是特别好:因为属性特别多,提供特别多的set方法,而且还需要手动将数据存入到对象中. * 注意2：这种情况下，Action类就相当于一个JavaBean，就没有体现出MVC的思想，Action类又封装数据，又接收请求处理，耦合性较高。 &gt; 在页面上，使用OGNL表达式进行数据封装。 * 在页面中使用OGNL表达式进行数据的封装，就可以直接把属性封装到某一个JavaBean的对象中。 * 在页面中定义一个JavaBean，并且提供set方法：例如：private User user; * 页面中的编写发生了变化，需要使用OGNL的方式，表单中的写法：&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt; * 注意：只提供一个set方法还不够，必须还需要提供user属性的get和set方法！！！ &gt; 先调用get方法，判断一下是否有user对象的实例对象，如果没有，调用set方法把拦截器创建的对象注入进来， * 第二种方式：模型驱动 &gt; 使用模型驱动的方式，也可以把表单中的数据直接封装到一个JavaBean的对象中，并且表单的写法和之前的写法没有区别！ &gt; 编写的页面不需要任何变化，正常编写name属性的值 &gt; 模型驱动的编写步骤： * 手动实例化JavaBean，即：private User user = new User(); * 必须实现ModelDriven&lt;T&gt;接口，实现getModel()的方法，在getModel()方法中返回user即可！！ 技术分析之Struts2把数据封装到集合中 1. 封装复杂类型的参数（集合类型 Collection 、Map接口等） 2. 需求：页面中有可能想批量添加一些数据，那么现在就可以使用上述的技术了。把数据封装到集合中 3. 把数据封装到Collection中 * 因为Collection接口都会有下标值，所有页面的写法会有一些区别，注意： &gt; &lt;input type=&quot;text&quot; name=&quot;products[0].name&quot; /&gt; * 在Action中的写法，需要提供products的集合，并且提供get和set方法。 4. 把数据封装到Map中 * Map集合是键值对的形式，页面的写法 &gt; &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].name&quot; /&gt; * Action中提供map集合，并且提供get和set方法 案例：添加客户 1. 功能 案例总结之Struts2的拦截器技术 1. 拦截器的概述 * 拦截器就是AOP（Aspect-Oriented Programming）的一种实现。（AOP是指用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。） * 过滤器:过滤从客服端发送到服务器端请求的 * 拦截器:拦截对目标Action中的某些方法进行拦截 * 拦截器不能拦截JSP * 拦截到Action中某些方法 2. 拦截器和过滤器的区别 1）拦截器是基于JAVA反射机制的，而过滤器是基于函数回调的 2）过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器 3）拦截器只能对Action请求起作用（Action中的方法），而过滤器可以对几乎所有的请求起作用（CSS JSP JS） * 拦截器 采用 责任链 模式 &gt; 在责任链模式里,很多对象由每一个对象对其下家的引用而连接起来形成一条链 &gt; 责任链每一个节点，都可以继续调用下一个节点，也可以阻止流程继续执行 * 在struts2 中可以定义很多个拦截器，将多个拦截器按照特定顺序 组成拦截器栈 （顺序调用 栈中的每一个拦截器 ） 3. Struts2的核心是拦截器，看一下Struts2的运行流程 案例总结之自定义拦截器和配置 1. 编写拦截器，需要实现Interceptor接口，实现接口中的三个方法 protected String doIntercept(ActionInvocation invocation) throws Exception { // 获取session对象 User user = (User) ServletActionContext.getRequest().getSession().getAttribute(&quot;existUser&quot;); if(user == null){ // 说明，没有登录，后面就不会执行了 return &quot;login&quot;; } return invocation.invoke(); } 2. 需要在struts.xml中进行拦截器的配置，配置一共有两种方式 &lt;!-- 定义了拦截器 第一种方式 &lt;interceptors&gt; &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.vvshyer.interceptor.DemoInterceptor&quot;/&gt; &lt;/interceptors&gt; --&gt; &lt;!-- 第二种方式：定义拦截器栈 --&gt; &lt;interceptors&gt; &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.vvshyer.interceptor.DemoInterceptor&quot;/&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name=&quot;myStack&quot;&gt; &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name=&quot;userAction&quot; class=&quot;com.vvshyer.demo3.UserAction&quot;&gt; &lt;!-- 只要是引用自己的拦截器，默认栈的拦截器就不执行了，必须要手动引入默认栈 &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; --&gt; &lt;!-- 引入拦截器栈就OK --&gt; &lt;interceptor-ref name=&quot;myStack&quot;/&gt; &lt;/action&gt; 案例二：使用拦截器判断用户是否已经登录","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://vvshyer.com/tags/Struts2/"}]},{"title":"Struts2第一天","date":"2017-03-28T09:59:50.000Z","path":"2017/03/28/struts2_day01/","text":"Struts2第一天 Struts2的学习路线 1. Struts2的入门：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写） 2. Struts2的Servlet的API、参数封装和拦截器 3. Struts2的值栈和OGNL表达式 今天的课程内容1. Struts2框架的概述 2. Struts2的快速入门 3. Struts2的运行流程 4. Struts2的常见配置（配置文件加载的顺序、struts.xml的常见配置（重点）、常量的配置等） 5. Struts2的Action的访问（Action的三种编写方式、Action类的配置、方法的调用等） 案例一：使用Struts2框架完成登录功能 需求分析 1. 使用Struts2完成登录的功能 技术分析之Struts2框架的概述 1. 什么是Struts2的框架 * Struts2是Struts1的下一代产品，是在 struts1和WebWork的技术基础上进行了合并的全新的Struts 2框架。 * 其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。 * Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。 * 虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。 2. Struts2是一个基于MVC设计模式的Web层框架 * MVC和JavaEE的三层结构 * MVC设计模式:是由一些网站的开发人员提出来的 * JavaEE三层结构:SUN公司为EE开发划分的结构 3. 常见的Web层的框架 * Struts1 * Struts2 * Webwork * SpringMVC 4. Web层框架的特点 * 都是一个特点，前端控制器模式 * 记住：前端控制器（核心的控制器） * Struts2框架前端的控制器就是过滤器 技术分析之Struts2快速入门的环境准备 1. 创建WEB项目，编写JSP的页面，编写超链接，点击超链接发送请求，请求服务器，让服务器的方法去执行！！ &lt;h3&gt;Struts2的入门程序&lt;/h3&gt; &lt;a href=&quot;${ pageContext.request.contextPath }/hello.action&quot;&gt;Struts2入门程序&lt;/a&gt; 2. 下载Struts2的开发包 * https://struts.apache.org/ -- 官网地址 3. 解压struts-2.3.24-all.zip包 * 解压后会看到有包和一些文件，大家需要掌握包相关的信息 * apps -- Struts2框架提供了一些应用 * libs -- Struts2框架开发的jar包 * docs -- Struts2框架开发文档 * src -- Struts2框架源码 4. 引入需要开发的jar包 * Struts2框架的开发jar包非常多，但是不是所有都是必须要引入的，有一些必须要导入的jar包，这些jar包可以从Struts2框架提供的应用中找到。 * 大家可以打开apps目录，然后找到struts2-blank.war应用。war包和zip包的压缩格式是一样的，所以可以自己修改后缀名，解压。 * 找到解压后的应用，打开WEB-INF/lib目录下所以的jar包。复制到工程中，就可以了。 5. 需要配置Struts2的前端控制器，注意：这一步是必须要做的操作，这是Struts2核心的控制器。 * Struts2的前端控制器就是一个过滤器，那么过滤器相关知识咱们都学习过，需要在web.xml中进行配置。 * 前端控制器的类的路径和名称：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter * 具体配置如下 &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 技术分析之编写Action类 1. Action类是动作类，是Struts2处理请求，封装数据，响应页面的核心控制器。需要自己编写。 package cn.itcast.action; public String sayHello(){ System.out.println(&quot;Hello Struts2!!&quot;); return null; } 技术分析之编写Struts的配置文件 1. 配置文件名称是struts.xml（名称必须是struts.xml） 2. 在src下引入struts.xml配置文件（配置文件的路径必须是在src的目录下） 3. 配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;hello&quot; class=&quot;com.itheima.action.HelloAction&quot; method=&quot;sayHello&quot;&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 入门总结之Struts2的执行流程 1. 执行的流程 * 编写的页面，点击超链接，请求提交到服务器端。 * 请求会先经过Struts2的核心过滤器（StrutsPrepareAndExecuteFilter） * 过滤器的功能是完成了一部分代码功能 * 就是一系列的拦截器执行了，进行一些处理工作。 * 咱们可以在struts-default.xml配置文件中看到有很多的拦截器。可以通过断点的方式来演示。 * 拦截器执行完后，会根据struts.xml的配置文件找到请求路径，找到具体的类，通过反射的方式让方法执行。 2. 总结 * JSP页面--&gt;StrutsPrepereAndExecuteFilter过滤器--&gt;执行一系列拦截器（完成了部分代码）--&gt;执行到目标Action--&gt;返回字符串--&gt;结果页面（result）--&gt;页面跳转 入门总结之struts.xml的配置文件提示的问题 1. 先找到struts.xml的配置文件，复制http://struts.apache.org/dtds/struts-2.3.dtd，注意，不要有双引号。 * http://struts.apache.org/dtds/struts-2.3.dtd 2. 选择window -- 首选项 -- 搜索xml -- 选择xml Catalog 3. 选择添加按钮（add按钮） * key type 要选择URI * key的位置把刚才复制的路径拷贝进去。http://struts.apache.org/dtds/struts-2.3.dtd * Location要在本地能找到struts2-2.3.dtd的真实文件。点击File System，去资料中找到它 4. 如果想查看源代码 * 选择资料/struts2/struts-2.3.24-all.zip 入门总结之Struts2框架配置文件加载的顺序 0. 需要掌握 * 加载了哪些个配置文件（重点的） * 配置文件的名称是什么 * 配置文件的位置 * 配置文件的作用 1. Struts2框架的核心是StrutsPrepareAndExecuteFilter过滤器，该过滤器有两个功能 * Prepare -- 预处理，加载核心的配置文件 * Execute -- 执行，让部分拦截器执行 2. StrutsPrepareAndExecuteFilter过滤器会加载哪些配置文件呢？ * 通过源代码可以看到具体加载的配置文件和加载配置文件的顺序 * init_DefaultProperties(); -- 加载org/apache/struts2/default.properties * init_TraditionalXmlConfigurations(); -- 加载struts-default.xml,struts-plugin.xml,struts.xml * init_LegacyStrutsProperties(); -- 加载自定义的struts.properties. * init_CustomConfigurationProviders(); -- 加载用户自定义配置提供者 * init_FilterInitParameters() ; -- 加载web.xml 3. 重点了解的配置文件 * default.properties -- 在org/apache/struts2/目录下，代表的是配置的是Struts2的常量的值 * struts-default.xml -- 在Struts2的核心包下，代表的是Struts2核心功能的配置（Bean、拦截器、结果类型等） * struts.xml -- 重点中的重点配置，代表WEB应用的默认配置，在工作中，基本就配置它就可以了！！（可以配置常量） * web.xml -- 配置前端控制器（可以配置常量） * 注意： * 前3个配置文件是struts2框架的默认配置文件，基本不用修改。 * 后3个配置文件可以允许自己修改struts2的常量。但是有一个特点：后加载的配置文件修改的常量的值，会覆盖掉前面修改的常量的值。 4. 总结（重点掌握的配置文件） * 先加载default.properties文件，在org/apache/struts2/default.properties文件，都是常量。 * 又加载struts-default.xml配置文件，在核心的jar包最下方，struts2框架的核心功能都是在该配置文件中配置的。 * 再加载struts.xml的配置文件，在src的目录下，代表用户自己配置的配置文件 * 最后加载web.xml的配置文件 * 后加载的配置文件会覆盖掉之前加载的配置文件（在这些配置文件中可以配置常量） 5. 注意一个问题 * 哪些配置文件中可以配置常量？ * default.properties -- 默认值，咱们是不能修改的！！ * struts.xml -- 可以配置，开发中基本上都在该配置文件中配置常量 * struts.properties -- 可以配置，基本不会在该配置文件中配置 * web.xml -- 可以配置，基本不会在该配置文件中配置 * 后加载的配置文件会覆盖掉之前加载的配置！！ 入门总结之struts.xml配置文件的配置 1. &lt;package&gt;标签，如果要配置&lt;Action&gt;的标签，那么必须要先配置&lt;package&gt;标签，代表的包的概念 * 包含的属性 * name -- 包的名称，要求是唯一的，管理action配置 * extends -- 继承，可以继承其他的包，只要继承了，那么该包就包含了其他包的功能，一般都是继承struts-default * namespace -- 名称空间，一般与&lt;action&gt;标签中的name属性共同决定访问路径（通俗话：怎么来访问action），常见的配置如下 * namespace=&quot;/&quot; -- 根名称空间 * namespace=&quot;/aaa&quot; -- 带有名称的名称空间 * abstract -- 抽象的。这个属性基本很少使用，值如果是true，那么编写的包是被继承的 2. &lt;action&gt;标签 * 代表配置action类，包含的属性 * name -- 和&lt;package&gt;标签的namespace属性一起来决定访问路径的 * class -- 配置Action类的全路径（默认值是ActionSupport类） * method -- Action类中执行的方法，如果不指定，默认值是execute 3. &lt;result&gt;标签 * action类中方法执行，返回的结果跳转的页面 * name -- 结果页面逻辑视图名称 * type -- 结果类型（默认值是转发，也可以设置其他的值） 入门总结之Struts2配置常量 1. 可以在Struts2框架中的哪些配置文件中配置常量？ * struts.xml（必须要掌握，开发中基本上就在该配置文件中编写常量） * &lt;constant name=&quot;key&quot; value=&quot;value&quot;&gt;&lt;/constant&gt; * web.xml * 在StrutsPrepareAndExecuteFilter配置文件中配置初始化参数 * 注意：后加载的配置的文件的常量会覆盖之前加载的常量！！ 2. 需要大家了解的常量 * struts.i18n.encoding=UTF-8 -- 指定默认编码集,作用于HttpServletRequest的setCharacterEncoding方法 * struts.action.extension=action,, -- 该属性指定需要Struts 2处理的请求后缀，该属性的默认值是action，即所有匹配*.action的请求都由Struts2处理。如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开 * struts.serve.static.browserCache=true -- 设置浏览器是否缓存静态内容,默认值为true(生产环境下使用),开发阶段最好关闭 * struts.configuration.xml.reload=false -- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认值为false(生产环境下使用) * struts.devMode = false -- 开发模式下使用,这样可以打印出更详细的错误信息 入门总结之指定多个struts的配置文件（了解） 1. 在大部分应用里，随着应用规模的增加，系统中Action的数量也会大量增加，导致struts.xml配置文件变得非常臃肿。 为了避免struts.xml文件过于庞大、臃肿，提高struts.xml文件的可读性，我们可以将一个struts.xml配置文件分解成多个配置文件，然后在struts.xml文件中包含其他配置文件。 2. 可以在&lt;package&gt;标签中，使用&lt;include&gt;标签来引入其他的struts_xx.xml的配置文件。例如： &lt;struts&gt; &lt;include file=&quot;struts-part1.xml&quot;/&gt; &lt;include file=&quot;struts-part2.xml&quot;/&gt; &lt;/struts&gt; 3. 注意注意注意（重要的事情说三遍）：&lt;include file=&quot;cn/itcast/demo2/struts-part1.xml&quot;/&gt; 技术分析之Action类的三种写法 1. 配置文件学习完成，下面的重点是Action类的三种写法 * Action类就是一个POJO类 * 什么是POJO类，POJO（Plain Ordinary Java Object）简单的Java对象.简单记：没有继承某个类，没有实现接口，就是POJO的类。 * Action类可以实现Action接口 * Action接口中定义了5个常量，5个常量的值对应的是5个逻辑视图跳转页面（跳转的页面还是需要自己来配置），还定义了一个方法，execute方法。 * 大家需要掌握5个逻辑视图的常量 * SUCCESS -- 成功. * INPUT -- 用于数据表单校验.如果校验失败,跳转INPUT视图. * LOGIN -- 登录. * ERROR -- 错误. * NONE -- 页面不转向. * Action类可以去继承ActionSupport类（开发中这种方式使用最多） * 设置错误信息 技术分析之Action的访问 1. 通过&lt;action&gt;标签中的method属性，访问到Action中的具体的方法。 * 传统的配置方式，配置更清晰更好理解！但是扩展需要修改配置文件等！ * 具体的实例如下： * 页面代码 * &lt;a href=&quot;${pageContext.request.contextPath}/addBook.action&quot;&gt;添加图书&lt;/a&gt; * &lt;a href=&quot;${pageContext.request.contextPath}/deleteBook.action&quot;&gt;删除图书&lt;/a&gt; * 配置文件的代码 &lt;package name=&quot;demo2&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;addBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt; &lt;action name=&quot;deleteBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;delete&quot;&gt;&lt;/action&gt; &lt;/package&gt; * Action的代码 public String add(){ System.out.println(&quot;添加图书&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除图书&quot;); return NONE; } 2. 通配符的访问方式:(访问的路径和方法的名称必须要有某种联系.) 通配符就是 * 代表任意的字符 * 使用通配符的方式可以简化配置文件的代码编写，而且扩展和维护比较容易。 * 具体实例如下： * 页面代码 &lt;a href=&quot;${pageContext.request.contextPath}/order_add.action&quot;&gt;添加订单&lt;/a&gt; &lt;a href=&quot;${pageContext.request.contextPath}/order_delete.action&quot;&gt;删除订单&lt;/a&gt; * 配置文件代码 * &lt;action name=&quot;order_*&quot; class=&quot;cn.itcast.demo2.OrderAction&quot; method=&quot;{1}&quot;&gt;&lt;/action&gt; * Action的代码 public String add(){ System.out.println(&quot;添加订单&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除订单&quot;); return NONE; } * 具体理解：在JSP页面发送请求，http://localhost/struts2_01/order_add.action，配置文件中的order_*可以匹配该请求，*就相当于变成了add，method属性的值使用{1}来代替，{1}就表示的是第一个*号的位置！！所以method的值就等于了add，那么就找到Action类中的add方法，那么add方法就执行了！ 3. 动态方法访问的方式（有的开发中也会使用这种方式） * 如果想完成动态方法访问的方式，需要开启一个常量，struts.enable.DynamicMethodInvocation = false，把值设置成true。 * 注意：不同的Struts2框架的版本，该常量的值不一定是true或者false，需要自己来看一下。如果是false，需要自己开启。 * 在struts.xml中开启该常量。 * &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; * 具体代码如下 * 页面的代码 * &lt;a href=&quot;${pageContext.request.contextPath}/product!add.action&quot;&gt;添加商品&lt;/a&gt; * &lt;a href=&quot;${pageContext.request.contextPath}/product!delete.action&quot;&gt;删除商品&lt;/a&gt; * 配置文件代码 * &lt;action name=&quot;product&quot; class=&quot;cn.itcast.demo2.ProductAction&quot;&gt;&lt;/action&gt; * Action的类的代码 public class ProductAction extends ActionSupport{ public String add(){ System.out.println(&quot;添加订单&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除订单&quot;); return NONE; } }","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://vvshyer.com/tags/Struts2/"}]},{"title":"Hibernate框架04","date":"2017-03-27T11:59:50.000Z","path":"2017/03/27/Hibernate_day04/","text":"Hibernate框架的第四天 回顾：Hibernate框架的第三天 1. 一对多关联关系映射 * JavaBean的编写 * 编写映射的配置文件 * 使用级联保存、删除、孤儿删除，使用cascade=&quot;save-update,delete,delete-orphan&quot; * 放弃外键的维护的权力，使用inverse=&quot;true&quot; 2. 多对多关联关系映射 * 保存，必须放弃外键的维护的权力 今天内容 1. Hibernate的查询方式 2. Hibernate的查询策略 案例一：使用Hibernate完成查询所有联系人功能 需求分析 1. 完成所有的联系人的查询 技术分析之Hibernate框架的查询方式 1. 唯一标识OID的检索方式 * session.get(对象.class,OID) 2. 对象的导航的方式 3. HQL的检索方式 * Hibernate Query Language -- Hibernate的查询语言 4. QBC的检索方式 * Query By Criteria -- 条件查询 5. SQL检索方式（了解） * 本地的SQL检索 技术分析之HQL的查询方式概述 1. HQL的介绍 * HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似 * 在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式 2. HQL与SQL的关系 * HQL 查询语句是面向对象的,Hibernate负责解析HQL查询语句, 然后根据对象-关系映射文件中的映射信息, 把 HQL 查询语句翻译成相应的 SQL 语句. * HQL 查询语句中的主体是域模型中的类及类的属性 * SQL 查询语句是与关系数据库绑定在一起的. SQL查询语句中的主体是数据库表及表的字段 技术分析之HQL的查询演示 1. HQL基本的查询格式 * 支持方法链的编程，即直接调用list()方法 * 简单的代码如下 * session.createQuery(&quot;from Customer&quot;).list(); 2. 使用别名的方式 * 可以使用别名的方式 * session.createQuery(&quot;from Customer c&quot;).list(); * session.createQuery(&quot;select c from Customer c&quot;).list(); 3. 排序查询 * 排序查询和SQL语句中的排序的语法是一样的 * 升序 * session.createQuery(&quot;from Customer order by cust_id&quot;).list(); * 降序 * session.createQuery(&quot;from Customer order by cust_id desc&quot;).list(); 4. 分页查询 * Hibernate框架提供了分页的方法，咱们可以调用方法来完成分页 * 两个方法如下 * setFirstResult(a) -- 从哪条记录开始，如果查询是从第一条开启，值是0 * setMaxResults(b) -- 每页查询的记录条数 * 演示代码如下 * List&lt;LinkMan&gt; list = session.createQuery(&quot;from LinkMan&quot;).setFirstResult(0).setMaxResults().list(); 5. 带条件的查询 * setParameter(&quot;?号的位置，默认从0开始&quot;,&quot;参数的值&quot;); 不用考虑参数的具体类型 * 按位置绑定参数的条件查询（指定下标值，默认从0开始） * 按名称绑定参数的条件查询（HQL语句中的 ? 号换成 :名称 的方式） * 例如代码如下 Query query = session.createQuery(&quot;from Linkman where lkm_name like ? order by lkm_id desc&quot;); query.setFirstResult(0).setMaxResults(3); query.setParameter(0, &quot;%熊%&quot;); List&lt;Linkman&gt; list = query.list(); for (Linkman linkman : list) { System.out.println(linkman); } HQL的投影查询 1. 投影查询就是想查询某一字段的值或者某几个字段的值 2. 投影查询的案例 * 如果查询多个字段，例如下面这种方式 List&lt;Object[]&gt; list = session.createQuery(&quot;select c.cust_name,c.cust_level from Customer c&quot;).list(); for (Object[] objects : list) { System.out.println(Arrays.toString(objects)); } * 如果查询两个字段，也可以把这两个字段封装到对象中 * 先在持久化类中提供对应字段的构造方法 * 使用下面这种HQL语句的方式 List&lt;Customer&gt; list = session.createQuery(&quot;select new Customer(c.cust_name,c.cust_level) from Customer c&quot;).list(); for (Customer customer : list) { System.out.println(customer); } 技术分析之聚合函数查询 1. 获取总的记录数 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery(&quot;select count(c) from Customer c&quot;).list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 2. 获取某一列数据的和 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery(&quot;select sum(c.cust_id) from Customer c&quot;).list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 技术分析之QBC检索方式 0. QBC：Query By Criteria 按条件进行查询 1. 简单查询，使用的是Criteria接口 List&lt;Customer&gt; list = session.createCriteria(Customer.class).list(); for (Customer customer : list) { System.out.println(customer); } 2. 排序查询 * 需要使用addOrder()的方法来设置参数，参数使用org.hibernate.criterion.Order对象 * 具体代码如下： Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 3. 分页查询 * QBC的分页查询也是使用两个方法 * setFirstResult(); * setMaxResults(); * 代码如下; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); criteria.setFirstResult(0); criteria.setMaxResults(3); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 4. 条件查询（Criterion是查询条件的接口，Restrictions类是Hibernate框架提供的工具类，使用该工具类来设置查询条件） * 条件查询使用Criteria接口的add方法，用来传入条件。 * 使用Restrictions的添加条件的方法，来添加条件，例如： * Restrictions.eq -- 相等 * Restrictions.gt -- 大于号 * Restrictions.ge -- 大于等于 * Restrictions.lt -- 小于 * Restrictions.le -- 小于等于 * Restrictions.between -- 在之间 * Restrictions.like -- 模糊查询 * Restrictions.in -- 范围 * Restrictions.and -- 并且 * Restrictions.or -- 或者 * 测试代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); // 设置查询条件 criteria.add(Restrictions.or(Restrictions.eq(&quot;lkm_gender&quot;, &quot;男&quot;), Restrictions.gt(&quot;lkm_id&quot;, 3L))); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 5. 聚合函数查询（Projection的聚合函数的接口，而Projections是Hibernate提供的工具类，使用该工具类设置聚合函数查询） * 使用QBC的聚合函数查询，需要使用criteria.setProjection()方法 * 具体的代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); criteria.setProjection(Projections.rowCount()); List&lt;Number&gt; list = criteria.list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 技术分析之离线条件查询 1. 离线条件查询使用的是DetachedCriteria接口进行查询，离线条件查询对象在创建的时候，不需要使用Session对象，只是在查询的时候使用Session对象即可。 2. 创建离线条件查询对象 * DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); 3. 具体的代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); // 设置查询条件 criteria.add(Restrictions.eq(&quot;lkm_gender&quot;, &quot;男&quot;)); // 查询数据 List&lt;Linkman&gt; list = criteria.getExecutableCriteria(session).list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 技术分析之SQL查询方式（了解） 1. 基本语法 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from cst_linkman where lkm_gender = ?&quot;); sqlQuery.setParameter(0,&quot;男&quot;); sqlQuery.addEntity(Linkman.class); List&lt;Linkman&gt; list = sqlQuery.list(); System.out.println(list); tr.commit(); 技术分析之HQL多表查询 1. 多表的查询进来使用HQL语句进行查询，HQL语句和SQL语句的查询语法比较类似。 * 内连接查询 * 显示内连接 * select * from customers c inner join orders o on c.cid = o.cno; * 隐式内连接 * select * from customers c,orders o where c.cid = o.cno; * 外连接查询 * 左外连接 * select * from customers c left join orders o on c.cid = o.cno; * 右外连接 * select * from customers c right join orders o on c.cid = o.cno; 2. HQL的多表查询 * 迫切和非迫切： * 非迫切返回结果是Object[] * 迫切连接返回的结果是对象，把客户的信息封装到客户的对象中，把订单的信息封装到客户的Set集合中。 3. 内连接查询 * 内连接使用 inner join ，默认返回的是Object数组 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Object[]&gt; list = session.createQuery(&quot;from Customer c inner join c.linkmans&quot;).list(); for (Object[] objects : list) { System.out.println(Arrays.toString(objects)); } tr.commit(); * 迫切内连接:inner join fetch ，返回的是实体对象 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery(&quot;from Customer c inner join fetch c.linkmans&quot;).list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) { System.out.println(customer); } tr.commit(); 4. 左外连接查询 * 左外连接: 封装成List&lt;Object[]&gt; * 迫切左外连接 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery(&quot;from Customer c left join fetch c.linkmans&quot;).list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) { System.out.println(customer); } tr.commit(); 案例一代码实现 案例二：对查询功能优化 需求分析 1. 对Hibernate框架的查询进行优化 技术分析之延迟加载 1. 延迟加载先获取到代理对象，当真正使用到该对象中的属性的时候，才会发送SQL语句，是Hibernate框架提升性能的方式 2. 类级别的延迟加载 * Session对象的load方法默认就是延迟加载 * Customer c = session.load(Customer.class, 1L);没有发送SQL语句，当使用该对象的属性时，才发送SQL语句 * 使类级别的延迟加载失效 * 在&lt;class&gt;标签上配置lazy=”false” * Hibernate.initialize(Object proxy); 3. 关联级别的延迟加载（查询某个客户，当查看该客户下的所有联系人是是否是延迟加载） * 默认是延迟加载 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c = session.get(Customer.class, 1L); System.out.println(&quot;=============&quot;); System.out.println(c.getLinkmans().size()); tr.commit(); 技术分析之Hibernate框架的查询策略 1. 查询策略：使用Hibernate查询一个对象的时候，查询其关联对象.应该如何查询.是Hibernate的一种优化手段!!! 2. Hibernate框架的检索策略解决的问题 * 查询的时机 Customer c1 = (Customer) session.get(Customer.class, 1); System.out.println(c1.getLinkmans().size()); * lazy属性解决查询的时机的问题，需要配置是否采用延迟加载！！ * 查询的语句形式 List&lt;Customer&gt; list = session.createQuery(&quot;from Customer&quot;).list(); for(Customer c : list){ System.out.println(c.getLinkmans()); } * fetch属性就可以解决查询语句的形式的问题！！ 技术分析之在set标签上配置策略 1. 在&lt;set&gt;标签上使用fetch和lazy属性 * fetch的取值 -- 控制SQL语句生成的格式 * select -- 默认值.发送查询语句 * join -- 连接查询.发送的是一条迫切左外连接!!!配置了join.lazy就失效了 * subselect -- 子查询.发送一条子查询查询其关联对象.(需要使用list()方法进行测试) * lazy的取值 -- 查找关联对象的时候是否采用延迟! * true -- 默认.延迟 * false -- 不延迟 * extra -- 及其懒惰 2. set标签上的默认值是fetch=&quot;select&quot;和lazy=&quot;true&quot; 3. 总结：Hibernate框架都采用了默认值，开发中基本上使用的都是默认值。特殊的情况。 技术分析之在man-to-one标签上配置策略 1. 在&lt;many-to-one&gt;标签上使用fetch和lazy属性 * fetch的取值 -- 控制SQL的格式. * select -- 默认。发送基本select语句查询 * join -- 发送迫切左外连接查询 * lazy的取值 -- 控制加载关联对象是否采用延迟. * false -- 不采用延迟加载. * proxy -- 默认值.代理.现在是否采用延迟. * 由另一端的&lt;class&gt;上的lazy确定.如果这端的class上的lazy=”true”.proxy的值就是true(延迟加载). * 如果class上lazy=”false”.proxy的值就是false(不采用延迟.) 2. 在&lt;many-to-one&gt;标签上的默认值是fetch=&quot;select&quot;和proxy 代码实现","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://vvshyer.com/tags/Hibernate/"}]},{"title":"Hibernate框架03","date":"2017-03-26T08:02:55.000Z","path":"2017/03/26/Hibernate_day03/","text":"Hibernate框架第三天 课程回顾：Hibernate第二天 1. 持久化类和一级缓存 * 持久化类：JavaBean + 映射的配置文件 * 持久化对象的三种状态 * 瞬时态 * 持久态：有自动更新数据的能力 * 托管态 * Session的一级缓存，快照机制 * 主键的生成策略 2. 管理事务 * 设置隔离级别 * 丢失更新的问题，乐观锁：添加属性version，配置&lt;version name=&quot;version&quot;&gt; * 绑定本地的Session，事务需要service层开启，dao层需要使用Session对象 3. 查询的接口 * Query接口：HQL的查询 * Criteria接口：QBC查询（按条件进行查询） 今天内容 1. Hibernate关联关系映射 案例一：完成CRM的联系人的保存操作 需求分析 1. 因为客户和联系人是一对多的关系，在有客户的情况下，完成联系人的添加保存操作 技术分析之Hibernate的关联关系映射之一对多映射（重点） 1. JavaWEB中一对多的设计及其建表原则 2. 先导入SQL的建表语句 * 创建今天的数据库：create database hibernate_day03; * 在资料中找到客户和联系人的SQL脚本 3. 编写客户和联系人的JavaBean程序（注意一对多的编写规则） * 客户的JavaBean如下 public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; private Set&lt;Linkman&gt; linkmans = new HashSet&lt;Linkman&gt;(); } * 联系人的JavaBean如下 public class Linkman { private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; private Customer customer; } 4. 编写客户和联系人的映射配置文件（注意一对多的配置编写） * 客户的映射配置文件如下 &lt;class name=&quot;com.vvshyer.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;set name=&quot;linkmans&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;/&gt; &lt;one-to-many class=&quot;com.vvshyer.domain.Linkman&quot;/&gt; &lt;/set&gt; &lt;/class&gt; * 联系人的映射配置文件如下 &lt;class name=&quot;com.vvshyer.domain.Linkman&quot; table=&quot;cst_linkman&quot;&gt; &lt;id name=&quot;lkm_id&quot; column=&quot;lkm_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;lkm_name&quot; column=&quot;lkm_name&quot;/&gt; &lt;property name=&quot;lkm_gender&quot; column=&quot;lkm_gender&quot;/&gt; &lt;property name=&quot;lkm_phone&quot; column=&quot;lkm_phone&quot;/&gt; &lt;property name=&quot;lkm_mobile&quot; column=&quot;lkm_mobile&quot;/&gt; &lt;property name=&quot;lkm_email&quot; column=&quot;lkm_email&quot;/&gt; &lt;property name=&quot;lkm_qq&quot; column=&quot;lkm_qq&quot;/&gt; &lt;property name=&quot;lkm_position&quot; column=&quot;lkm_position&quot;/&gt; &lt;property name=&quot;lkm_memo&quot; column=&quot;lkm_memo&quot;/&gt; &lt;many-to-one name=&quot;customer&quot; class=&quot;com.vvshyer.domain.Customer&quot; column=&quot;lkm_cust_id&quot;/&gt; &lt;/class&gt; 技术分析之保存客户和联系人的数据 1. 进行双向关联进行数据的保存 技术分析之级联保存 1. 测试：如果现在代码只插入其中的一方的数据 * 如果只保存其中的一方的数据，那么程序会抛出异常。 * 如果想完成只保存一方的数据，并且把相关联的数据都保存到数据库中，那么需要配置级联！！ * 级联保存是方向性 2. 级联保存效果 * 级联保存：保存一方同时可以把关联的对象也保存到数据库中！！ * 使用cascade=&quot;save-update&quot; 技术分析之级联删除 1. 先来给大家在数据库中演示含有外键的删除客户功能，那么SQL语句是会报出错误的 * 例如：delete from customers where cid = 1; 2. 如果使用Hibernate框架直接删除客户的时候，测试发现是可以删除的 3. 上述的删除是普通的删除，那么也可以使用级联删除，注意：级联删除也是有方向性的！！ * &lt;many-to-one cascade=&quot;delete&quot; /&gt; 技术分析之级联的取值（cascade的取值）和孤儿删除 1. 需要大家掌握的取值如下 * none -- 不使用级联 * save-update -- 级联保存或更新 * delete -- 级联删除 * delete-orphan -- 孤儿删除.(注意：只能应用在一对多关系) * all -- 除了delete-orphan的所有情况.（包含save-update delete） * all-delete-orphan -- 包含了delete-orphan的所有情况.（包含save-update delete delete-orphan） 2. 孤儿删除（孤子删除），只有在一对多的环境下才有孤儿删除 * 在一对多的关系中,可以将一的一方认为是父方.将多的一方认为是子方.孤儿删除:在解除了父子关系的时候.将子方记录就直接删除。 * &lt;many-to-one cascade=&quot;delete-orphan&quot; /&gt; 技术分析之让某一方放弃外键的维护，为多对多做准备 1. 先测试双方都维护外键的时候，会产生多余的SQL语句。 * 想修改客户和联系人的关系，进行双向关联，双方都会维护外键，会产生多余的SQL语句。 * 产生的原因：session的一级缓存中的快照机制，会让双方都更新数据库，产生了多余的SQL语句。 2. 如果不想产生多余的SQL语句，那么需要一方来放弃外键的维护！ * 在&lt;set&gt;标签上配置一个inverse=”true”.true:放弃.false:不放弃.默认值是false * &lt;inverse=&quot;true&quot;&gt; 技术分析之cascade和inverse的区别 1. cascade用来级联操作（保存、修改和删除） 2. inverse用来维护外键的 Hibernate的关联关系映射之多对多映射 技术分析之多对多的建表原则 1. JavaWEB的多对多 技术分析之多对多JavaBean的编写 1. 编写用户和角色的JavaBean * 用户的JavaBean代码如下 public class User { private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); } * 角色的JavaBean代码如下 public class Role { private Long role_id; private String role_name; private String role_memo; private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); } 2. 用户和角色的映射配置文件如下 * 用户的映射配置文件如下 &lt;class name=&quot;com.vvshyer.domain.User&quot; table=&quot;sys_user&quot;&gt; &lt;id name=&quot;user_id&quot; column=&quot;user_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;user_code&quot; column=&quot;user_code&quot;/&gt; &lt;property name=&quot;user_name&quot; column=&quot;user_name&quot;/&gt; &lt;property name=&quot;user_password&quot; column=&quot;user_password&quot;/&gt; &lt;property name=&quot;user_state&quot; column=&quot;user_state&quot;/&gt; &lt;set name=&quot;roles&quot; table=&quot;sys_user_role&quot;&gt; &lt;key column=&quot;user_id&quot;/&gt; &lt;many-to-many class=&quot;com.vvshyer.domain.Role&quot; column=&quot;role_id&quot;/&gt; &lt;/set&gt; &lt;/class&gt; * 角色的映射配置文件如下 &lt;class name=&quot;com.vvshyer.domain.Role&quot; table=&quot;sys_role&quot;&gt; &lt;id name=&quot;role_id&quot; column=&quot;role_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;role_name&quot; column=&quot;role_name&quot;/&gt; &lt;property name=&quot;role_memo&quot; column=&quot;role_memo&quot;/&gt; &lt;set name=&quot;users&quot; table=&quot;sys_user_role&quot;&gt; &lt;key column=&quot;role_id&quot;/&gt; &lt;many-to-many class=&quot;com.vvshyer.domain.User&quot; column=&quot;user_id&quot;/&gt; &lt;/set&gt; &lt;/class&gt; 3. 多对多进行双向关联的时候:必须有一方去放弃外键维护权 技术分析之多对多的级联保存 1. 级联保存 * &lt;set cascade=&quot;save-update&quot;&gt; 级联删除（在多对多中是很少使用的） 1. 级联删除","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://vvshyer.com/tags/Hibernate/"}]},{"title":"Hibernate框架02","date":"2017-03-25T13:25:47.000Z","path":"2017/03/25/Hibernate_day02/","text":"Hibernate框架第二天 课程回顾：Hibernate框架的第一天 1. Hibernate框架的概述：ORM 2. 框架的入门的程序 * 编写映射的配置文件 * 编写核心的配置文件 * 编写程序 3. 配置的文件 4. 使用的接口和方法 今天内容 1. Hibernate持久化对象的状态 2. Hibernate的一级缓存 3. Hibernate操作持久化对象的方法 4. Hibernate的基本查询 Hibernate的持久化类 什么是持久化类 1. 持久化类:就是一个Java类（咱们编写的JavaBean），这个Java类与表建立了映射关系就可以成为是持久化类。 * 持久化类 = JavaBean + xxx.hbm.xml 持久化类的编写规则 1. 提供一个无参数 public访问控制符的构造器 -- 底层需要进行反射. 2. 提供一个标识属性，映射数据表主键字段 -- 唯一标识OID.数据库中通过主键.Java对象通过地址确定对象.持久化类通过唯一标识OID确定记录 3. 所有属性提供public访问控制符的 set或者get 方法 4. 标识属性应尽量使用基本数据类型的包装类型 区分自然主键和代理主键 1. 创建表的时候 * 自然主键:对象本身的一个属性.创建一个人员表,每个人都有一个身份证号.(唯一的)使用身份证号作为表的主键.自然主键.（开发中不会使用这种方式） * 代理主键:不是对象本身的一个属性.创建一个人员表,为每个人员单独创建一个字段.用这个字段作为主键.代理主键.（开发中推荐使用这种方式） 2. 创建表的时候尽量使用代理主键创建表 主键的生成策略 1. increment:适用于short,int,long作为主键.不是使用的数据库自动增长机制. * Hibernate中提供的一种增长机制. * 先进行查询 :select max(id) from user; * 再进行插入 :获得最大值+1作为新的记录的主键. * 问题:不能在集群环境下或者有并发访问的情况下使用. 2. identity:适用于short,int,long作为主键。但是这个必须使用在有自动增长数据库中.采用的是数据库底层的自动增长机制. * 底层使用的是数据库的自动增长(auto_increment).像Oracle数据库没有自动增长. 3. sequence:适用于short,int,long作为主键.底层使用的是序列的增长方式. * Oracle数据库底层没有自动增长,想自动增长需要使用序列. 4. uuid:适用于char,varchar类型的作为主键. * 使用随机的字符串作为主键. 5. native:本地策略.根据底层的数据库不同,自动选择适用于该种数据库的生成策略.(short,int,long) * 如果底层使用的MySQL数据库:相当于identity. * 如果底层使用Oracle数据库:相当于sequence. 6. assigned:主键的生成不用Hibernate管理了.必须手动设置主键. Hibernate持久化对象的状态 持久化对象的状态 1. Hibernate的持久化类 * 持久化类:Java类与数据库的某个表建立了映射关系.这个类就称为是持久化类. * 持久化类 = Java类 + hbm的配置文件 2. Hibernate的持久化类的状态 * Hibernate为了管理持久化类：将持久化类分成了三个状态 * 瞬时态:Transient Object * 没有持久化标识OID, 没有被纳入到Session对象的管理. * 持久态:Persistent Object * 有持久化标识OID,已经被纳入到Session对象的管理. * 脱管态:Detached Object * 有持久化标识OID,没有被纳入到Session对象的管理. Hibernate持久化对象的状态的转换 1. 瞬时态 -- 没有持久化标识OID, 没有被纳入到Session对象的管理 * 获得瞬时态的对象 * User user = new User() * 瞬时态对象转换持久态 * save()/saveOrUpdate(); * 瞬时态对象转换成脱管态 * user.setId(1) 2. 持久态 -- 有持久化标识OID,已经被纳入到Session对象的管理 * 获得持久态的对象 * get()/load(); * 持久态转换成瞬时态对象 * delete(); --- 比较有争议的，进入特殊的状态(删除态:Hibernate中不建议使用的) * 持久态对象转成脱管态对象 * session的close()/evict()/clear(); 3. 脱管态 -- 有持久化标识OID,没有被纳入到Session对象的管理 * 获得托管态对象:不建议直接获得脱管态的对象. * User user = new User(); * user.setId(1); * 脱管态对象转换成持久态对象 * update();/saveOrUpdate()/lock(); * 脱管态对象转换成瞬时态对象 * user.setId(null); 4. 注意：持久态对象有自动更新数据库的能力!!! Hibernate的一级缓存 Session对象的一级缓存（重点） 1. 什么是缓存？ * 其实就是一块内存空间,将数据源（数据库或者文件）中的数据存放到缓存中.再次获取的时候 ,直接从缓存中获取.可以提升程序的性能！ 2. Hibernate框架提供了两种缓存 * 一级缓存 -- 自带的不可卸载的.一级缓存的生命周期与session一致.一级缓存称为session级别的缓存. * 二级缓存 -- 默认没有开启，需要手动配置才可以使用的.二级缓存可以在多个session中共享数据,二级缓存称为是sessionFactory级别的缓存. 3. Session对象的缓存概述 * Session接口中,有一系列的java的集合,这些java集合构成了Session级别的缓存(一级缓存).将对象存入到一级缓存中,session没有结束生命周期,那么对象在session中存放着 * 内存中包含Session实例 --&gt; Session的缓存（一些集合） --&gt; 集合中包含的是缓存对象！ 4. 证明一级缓存的存在，编写查询的代码即可证明 * 在同一个Session对象中两次查询，可以证明使用了缓存 5. Hibernate框架是如何做到数据发生变化时进行同步操作的呢？ * 使用get方法查询User对象 * 然后设置User对象的一个属性，注意：没有做update操作。发现，数据库中的记录也改变了。 * 利用快照机制来完成的（SnapShot） 控制Session的一级缓存（了解） 1. 学习Session接口中与一级缓存相关的方法 * Session.clear() -- 清空缓存。 * Session.evict(Object entity) -- 从一级缓存中清除指定的实体对象。 * Session.flush() -- 刷出缓存 Hibernate中的事务与并发 事务相关的概念 1. 什么是事务 * 事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败. * 转账的例子：冠希给美美转钱，扣钱，加钱。两个操作组成了一个事情！ 2. 事务的特性 * 原子性 -- 事务不可分割. * 一致性 -- 事务执行的前后数据的完整性保持一致. * 隔离性 -- 一个事务执行的过程中,不应该受到其他的事务的干扰. * 持久性 -- 事务一旦提交,数据就永久保持到数据库中. 3. 如果不考虑隔离性:引发一些读的问题 * 脏读 -- 一个事务读到了另一个事务未提交的数据. * 不可重复读 -- 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致. * 虚读 -- 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致. 4. 通过设置数据库的隔离级别来解决上述读的问题 * 未提交读:以上的读的问题都有可能发生. * 已提交读:避免脏读,但是不可重复读，虚读都有可能发生. * 可重复读:避免脏读，不可重复读.但是虚读是有可能发生. * 串行化:以上读的情况都可以避免. 5. 如果想在Hibernate的框架中来设置隔离级别，需要在hibernate.cfg.xml的配置文件中通过标签来配置 * 通过：hibernate.connection.isolation = 4 来配置 * 取值 * 1—Read uncommitted isolation * 2—Read committed isolation * 4—Repeatable read isolation * 8—Serializable isolation 丢失更新的问题 1. 如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。 2. 例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。 * A事务和B事务同时获取到一条数据，同时再做修改 * 如果A事务修改完成后，提交了事务 * B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响 3. 解决方案有两种 * 悲观锁 * 采用的是数据库提供的一种锁机制，如果采用做了这种机制，在SQL语句的后面添加 for update 子句 * 当A事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。 * 只有当A事务提交后，锁释放了，其他事务才能操作该条记录 * 乐观锁 * 采用版本号的机制来解决的。会给表结构添加一个字段version=0，默认值是0 * 当A事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号version=1. * 当B事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。 4. 使用Hibernate框架解决丢失更新的问题 * 悲观锁 * 使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法 * 乐观锁 * 1.在对应的JavaBean中添加一个属性，名称可以是任意的。例如：private Integer version; 提供get和set方法 * 2.在映射的配置文件中，提供&lt;version name=&quot;version&quot;/&gt;标签即可。 绑定本地的Session 1. 之前在讲JavaWEB的事务的时候，需要在业务层使用Connection来开启事务， * 一种是通过参数的方式传递下去 * 另一种是把Connection绑定到ThreadLocal对象中 2. 现在的Hibernate框架中，使用session对象开启事务，所以需要来传递session对象，框架提供了ThreadLocal的方式 * 需要在hibernate.cfg.xml的配置文件中提供配置 * &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; * 重新HibernateUtil的工具类，使用SessionFactory的getCurrentSession()方法，获取当前的Session对象。并且该Session对象不用手动关闭，线程结束了，会自动关闭。 public static Session getCurrentSession(){ return factory.getCurrentSession(); } * 注意：想使用getCurrentSession()方法，必须要先配置才能使用。 Hibernate框架的查询方式 Query查询接口 1. 具体的查询代码如下 // 1.查询所有记录 /*Query query = session.createQuery(&quot;from Customer&quot;); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ // 2.条件查询: /*Query query = session.createQuery(&quot;from Customer where name = ?&quot;); query.setString(0, &quot;李健&quot;); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ // 3.条件查询: /*Query query = session.createQuery(&quot;from Customer where name = :aaa and age = :bbb&quot;); query.setString(&quot;aaa&quot;, &quot;李健&quot;); query.setInteger(&quot;bbb&quot;, 38); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ Criteria查询接口（做条件查询非常合适） 1. 具体的查询代码如下 // 1.查询所有记录 /*Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/ // 2.条件查询 /*Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq(&quot;name&quot;, &quot;李健&quot;)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/ // 3.条件查询 /*Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq(&quot;name&quot;, &quot;李健&quot;)); criteria.add(Restrictions.eq(&quot;age&quot;, 38)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://vvshyer.com/tags/Hibernate/"}]},{"title":"程序员的数学","date":"2017-03-21T12:03:36.000Z","path":"2017/03/21/程序员的数学/","text":"乘方的思考题1234567的987654321次方 的个位数是什么？1234567 0次方的个位 = 7的0次方 = 1 1234567 1次方的个位 = 7的1次方 = 7 1234567 2次方的个位 = 7的2次方 = 9 1234567 3次方的个位 = 7的3次方 = 3 1234567 4次方的个位 = 7的4次方 = 1 1234567 5次方的个位 = 7的5次方 = 7 1234567 6次方的个位 = 7的6次方 = 9 1234567 7次方的个位 = 7的7次方 = 3 1234567 8次方的个位 = 7的8次方 = 1 发现规律：个位时1、7、9、3四个数字的循环 用987654321 % 4 = 1, 所以答案为7 ##Tip: 运用余数将大数字问题简化为小数字问题","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"数学基础之欧拉函数","date":"2017-03-21T05:53:18.000Z","path":"2017/03/21/数学基础之欧拉函数/","text":"1136 欧拉函数对正整数n，欧拉函数是少于或等于n的数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为Euler’s totient function、φ函数、欧拉商数等。例如：φ(8) = 4（Phi(8) = 4），因为1,3,5,7均和8互质。1234567891011121314151617181920212223242526package com.main;import java.util.Scanner;public class Main &#123; public static int euler(int n)&#123; int res = n, i; for (i = 2; i * i &lt;= n; i++)&#123; if (n%i == 0)&#123; res = res/i*(i-1); while (n % i == 0) n = n/i; &#125; &#125; if (n != 1) res = res/n*(n-1); return res; &#125; public static void main(String[] args)&#123; Scanner cin = new Scanner(System.in); int n = cin.nextInt(); System.out.println(euler(n)); cin.close(); &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"计算机网络笔记02","date":"2017-03-17T14:03:37.000Z","path":"2017/03/17/计算机网络笔记02/","text":"第二章 物理层功能从OSI／RM角度 为上一层提供服务，提供一个透明传输比特流的能力 物理层研究的并不是物理媒体，而是屏蔽了上一层对于不同物理媒体的差异。 从通信工程角度 机械特性 电器特性 功能特性 规程特性 数据通信的基础知识码元 时间间隔内的信号 信号 单向通信（单工） 双向交替通信（半双工） 双向同时通信（全双工） 基带信号和宽带信号 基带信号就是将数字信号 1 或 0 直接用两种不同的电压来表示，然后送到线路上去传输。 (基带传输) 宽带信号则是将基带信号进行调制后形成的频分复用模拟信号。 (频带传输) 10 base 2 10 表示 10Mb/s base 表示基带传输 2 表示传输距离 200m 模拟传输与数字传输 长途干线最初采用频分复用 FDM 的传输方式FDM (Frequency Division Multiplexing) 信道复用技术 频分复用（FDM ）：所有用户在同样的时间占用不同的带宽资源。 时分复用（TDM）：所有用户在不同的时间占用同样的频带宽度。 静态时分多路复用 动态时分多路复用 码分复用（CDM）：各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://vvshyer.com/tags/计算机网络/"}]},{"title":"CCF之201612-3权限查询","date":"2017-03-16T09:51:05.000Z","path":"2017/03/16/CCF之201612-3权限查询/","text":"授权查询问题描述授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。 本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。 具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。 给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类： 不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限； 分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限； 分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。输入格式 输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 category:level，其中 category是权限类名，level&gt;是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。 接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为 &lt;role&gt; &lt;s&gt; &lt;privilege 1&gt; &lt;privilege 2&gt; ... &lt;privilege s&gt; 其中 role 是角色名称，s 表示该角色具有多少种权限。后面 s 个字符串描述该角色具有的权限，格式同 P 段。 接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为 &lt;user&gt; &lt;t&gt; &lt;role 1&gt; &lt;role 2&gt; ... &lt;role t&gt; 其中 user 是用户名，t 表示该用户具有多少种角色。后面 t 个字符串描述该用户具有的角色。 接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 user privilege，表示查询用户 user 是否具有 privilege 权限。如果查询的权限是分等级权限，则查询中的 privilege 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。输出格式 输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。 样例输入 12345678910111213141516171819202122233crm:2git:3game4hr 1 crm:2it 3 crm:1 git:1 gamedev 2 git:3 gameqa 1 git:23alice 1 hrbob 2 it qacharlie 1 dev9alice gamealice crm:2alice git:0bob gitbob poweroffcharlie gamecharlie crmcharlie git:3malice game 样例输出 123456789falsetruefalse2falsetruefalsetruefalse 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package com.main;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); //输入权限类别的数量 int p = cin.nextInt(); Privi[] arrayPrivi = new Privi[p]; //输入各个权限 for (int i = 0; i &lt; p; i++) &#123; arrayPrivi[i] = new Privi(cin.next()); &#125; // 输入角色数量 int r = cin.nextInt(); Role[] arrayRole = new Role[r]; //输入每个角色信息 for (int i = 0; i &lt; r; i++) &#123; String name = cin.next(); //角色名 int countrole = cin.nextInt(); //角色拥有的权限数 Role ro = new Role(name, countrole); //输入该角色具有的权限 for (int j = 0; j &lt; countrole; j++) &#123; ro.addPrivi(j, new Privi(cin.next())); &#125; arrayRole[i] = ro; &#125; //输入用户数量 int u = cin.nextInt(); User[] arrayUser = new User[u]; //输入每个用户信息 for (int i = 0; i &lt; u; i++) &#123; String name = cin.next(); //用户名 int countrole = cin.nextInt(); //用户拥有角色数 User us = new User(name,countrole); //输入该用户具有的角色 for (int j = 0; j &lt; countrole; j++) &#123; us.addRole(j, roleFactory(arrayRole,cin.next())); &#125; arrayUser[i] = us; &#125; //输入权限查询数量 int q = cin.nextInt(); Query[] arrayQuery = new Query[q]; for (int i = 0; i &lt; q; i++) &#123; //输入查询用户和是否具有的权限 arrayQuery[i] = new Query(cin.next(),cin.next()); &#125; cin.close(); //查询 StringBuilder sb = new StringBuilder(); for (Query query : arrayQuery) &#123; //查询结果拼接 sb.append(check(query,arrayUser) + \"\\n\"); &#125; //输出查询结果 System.out.println(sb.toString()); &#125; //角色工厂，如果已存在该角色直接返回，否则返回null private static Role roleFactory(Role[] arrayRole,String name) &#123; for(Role role : arrayRole) &#123; if(name.equals(role.getName())) &#123; return role; &#125; &#125; return null; &#125; //查询 private static String check(Query query,User[] arrayUser) &#123; int flag = -3; String uname = query.qUserName; Privi up = query.qPrivi; for (User user : arrayUser) &#123; flag = -3; //找是否存在该用户 if (uname.equals(user.getName())) &#123; Role[] userRoleArr = user.getRoleArray(); //是否有该角色 for (Role role : userRoleArr) &#123; Privi[] userRolePriviArr = role.getPriviArray(); //是否有该权限，取权限最高级 for (Privi privi : userRolePriviArr) &#123; int temp = up.equals(privi); flag = (temp &gt; flag) ? temp : flag; if(flag == -1) return \"true\"; &#125; &#125; break; &#125; &#125; if (flag == -2 || flag == -3) &#123; return \"false\"; &#125; else return flag + \"\"; &#125; static class Query &#123; public String qUserName; public Privi qPrivi; Query(String username, String Priviname) &#123; this.qUserName = username; this.qPrivi = new Privi(Priviname); &#125; &#125;&#125;class Privi &#123; private String name; private int level; public Privi() &#123;&#125; public Privi(String per) &#123; String[] p = per.split(\":\"); if (p.length == 1) &#123; Privi.this.name = p[0]; Privi.this.level = -1; &#125; else if (p.length == 2) &#123; Privi.this.name = p[0]; Privi.this.level = Integer.parseInt(p[1]); &#125; &#125; public String getName() &#123; return this.name; &#125; public void setName(String s) &#123; this.name = s; &#125; public int getLevel() &#123; return this.level; &#125; public void setLevel(int l) &#123; this.level = l; &#125; public int equals(Privi p) &#123; if (this.name.equals(p.getName())) &#123; if(this.level == -1 &amp;&amp; this.level &lt; p.getLevel()) return p.getLevel(); else if(this.level == -1 &amp;&amp; p.getLevel() == -1) return -1;//bufendengji else if(this.level != -1 &amp;&amp; this.level &lt;= p.getLevel() ) return -1;//fendengji else return -2; // &#125; else return -2; &#125; public String toString() &#123; return this.name +(this.level != -1 ? (\":\" + this.level) : \"\"); &#125;&#125;class Role &#123; private String name; private int countPrivi; private Privi[] arrPrivi; public Role() &#123; this.name = \"\"; &#125; public Role(String n,int count) &#123; this.name = n; this.countPrivi = count; this.arrPrivi = new Privi[count]; &#125; public String getName() &#123; return this.name; &#125; public void setName(String s) &#123; this.name = s; &#125; public int getPriviCount() &#123; return this.arrPrivi.length; &#125; public Privi[] getPriviArray() &#123; return this.arrPrivi; &#125; public void addPrivi(int n,Privi p) &#123; this.arrPrivi[n] = p; &#125; public String toString() &#123; String s = this.name + \"~\" ; for(Privi p : this.arrPrivi) &#123; s += p.toString() + \"+\"; &#125; return s; &#125;&#125;class User &#123; private String name; private int countRole; private Role[] arrRole; public User() &#123; this.name = \"\"; &#125; public User(String name, int count) &#123; this.name = name; this.countRole = count; this.arrRole = new Role[count]; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Role[] getRoleArray() &#123; return this.arrRole; &#125; public void addRole(int n, Role role) &#123; this.arrRole[n] = role; &#125; public String toString() &#123; String s = name + \"~\"; for(Role role : arrRole) &#123; s += role.toString() + \"+\"; &#125; return s; &#125;&#125;","tags":[{"name":"CCF","slug":"CCF","permalink":"https://vvshyer.com/tags/CCF/"}]},{"title":"Hibernate框架01","date":"2017-03-16T09:51:05.000Z","path":"2017/03/16/Hibernate_day01/","text":"Hibernate框架第一天 今天任务 1. 使用Hibernate框架完成对客户的增删改查的操作 教学导航 vvshyer 1. 能够说出Hibernate的执行流程 2. 能够独立使用Hibernate框架完成增删改查的操作 框架和CRM项目的整体介绍 1. 什么是CRM * CRM（Customer Relationship Management）客户关系管理，是利用相应的信息技术以及互联网技术来协调企业与顾客间在销售、营销和服务上的交互，向客户提供创新式的个性化的客户交互和服务的过程 * 其最终目标是将面向客户的各项信息和活动集成起来，组建一个以客户为中心的企业，实现对面向客户的活动的全面管理 2. CRM的模块 * CRM系统实现了对企业销售、营销、服务等各阶段的客户信息、客户活动进行统一管理。 * CRM系统功能涵盖企业销售、营销、用户服务等各各业务流程，业务流程中与客户相关活动都会在CRM系统统一管理。 * 下边列出一些基本的功能模块，包括： * 客户信息管理 * 联系人管理 * 商机管理 * 统计分析等 3. 模块的具体功能 * 客户信息管理 * 对客户信息统一维护，客户是指存量客户或拟营销的客户，通过员工录入形成公司的“客户库”是公司最重要的数据资源。 * 联系人管理 * 对客户的联系人信息统一管理，联系人是指客户企业的联系人，即企业的业务人员和客户的哪些人在打交道。 * 客户拜访管理 * 业务员要开发客户需要去拜访客户，客户拜访信息记录了业务员与客户沟通交流方面的不足、采取的策略不当、有待改进的地方或值得分享的沟通技巧等方面的信息。 * 综合查询 * 客户相关信息查询，包括：客户信息查询、联系人信息查询、商机信息查询等 * 统计分析 * 按分类统计客户信息，包括：客户信息来源统计、按行业统计客户、客户发展数量统计等 * 系统管理 系统管理属于crm系统基础功能模块，包括：数据字典、账户管理、角色管理、权限管理、操作日志管理等 Hibernate框架的学习路线 1. 注意：Hibernate框架知识点非常多，比较杂乱，大家要做好笔记记录的工作 2. 学习的路线 * 第一天：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 第二天：主要学习一级缓存、事务管理和基本的查询 * 第三天：主要学习一对多和多对多的操作等 * 第四天：基本查询和查询的优化 案例一：完成客户的CRUD的操作 需求分析 1. CRM系统中客户信息管理模块功能包括 * 新增客户信息 * 客户信息查询 * 修改客户信息 * 删除客户信息 2. 要实现客户的新增功能 技术分析之Hibernate框架的概述 Hibernate框架的概述 1. Hibernate框架的概述 * Hibernate称为 * Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 * Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 * Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架 2. 记住：Hibernate是一个持久层的ORM框架！！！ 什么是ORM（对象关系映射） 1. ORM映射：Object Relational Mapping * O：面向对象领域的Object（JavaBean对象） * R：关系数据库领域的Relational（表的结构） * M：映射Mapping（XML的配置文件） 2. 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录 Hibernate优点 1. 优点 * Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 * Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 * Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 技术分析之Hibernate框架的快速入门 第一步：下载Hibernate5的运行环境 1. 下载相应的jar包等 * http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download 2. 解压后对目录结构有一定的了解 第二步：创建表结构 1. 建表语句如下 Create database hibernate_day01; Use hibernate_day01; CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;, `cust_name` varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;, `cust_user_id` bigint(32) DEFAULT NULL COMMENT &apos;负责人id&apos;, `cust_create_id` bigint(32) DEFAULT NULL COMMENT &apos;创建人id&apos;, `cust_source` varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;, `cust_industry` varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;, `cust_level` varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;, `cust_linkman` varchar(64) DEFAULT NULL COMMENT &apos;联系人&apos;, `cust_phone` varchar(64) DEFAULT NULL COMMENT &apos;固定电话&apos;, `cust_mobile` varchar(16) DEFAULT NULL COMMENT &apos;移动电话&apos;, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 第三步：搭建Hibernate的开发环境 1. 创建WEB工程，引入Hibernate开发所需要的jar包 * MySQL的驱动jar包 * Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包） * 日志jar包（资料/jar包/log4j/所有jar包） 第四步：编写JavaBean实体类 1. Customer类的代码如下： public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法 } 第五步：创建类与表结构的映射 1. 在JavaBean所在的包下创建映射的配置文件 * 默认的命名规则为：实体类名.hbm.xml * 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束） &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 2. 如果不能上网，编写配置文件是没有提示的，需要自己来配置 * 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd --&gt; window --&gt; preferences --&gt; 搜索xml --&gt; 选择xml catalog --&gt; 点击add --&gt; 现在URI --&gt; 粘贴复制的地址 --&gt; 选择location，选择本地的DTD的路径 3. 编写映射的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping&gt; &lt;class name=&quot;com.vvshyer.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 第六步：编写Hibernate核心的配置文件 1. 在src目录下，创建名称为hibernate.cfg.xml的配置文件 2. 在XML中引入DTD约束 &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; 3. 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 * 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password * 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect * 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） * &lt;mapping resource=&quot;com/vvshyer/domain/Customer.hbm.xml&quot;/&gt; 4. 具体的配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping resource=&quot;com/vvshyer/domain/Customer.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 第七步：编写Hibernate入门代码 1. 具体的代码如下 /** * 测试保存客户 */ @Test public void testSave(){ // 先加载配置文件 Configuration config = new Configuration(); // 默认加载src目录下的配置文件 config.configure(); // 创建SessionFactory对象 SessionFactory factory = config.buildSessionFactory(); // 创建session对象 Session session = factory.openSession(); // 开启事务 Transaction tr = session.beginTransaction(); // 编写保存代码 Customer c = new Customer(); // c.setCust_id(cust_id); 已经自动递增 c.setCust_name(&quot;测试名称&quot;); c.setCust_mobile(&quot;110&quot;); // 保存客户 session.save(c); // 提交事务 tr.commit(); // 释放资源 session.close(); factory.close(); } 回忆：快速入门 1. 下载Hibernate框架的开发包 2. 编写数据库和表结构 3. 创建WEB的项目，导入了开发的jar包 * MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包 4. 编写JavaBean，以后不使用基本数据类型，使用包装类 5. 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签 6. 编写hibernate的核心的配置文件，里面的内容是固定的 7. 编写代码，使用的类和方法 技术分析之：Hibernate常用的配置文件 Hibernate配置文件之映射配置文件 1. 映射文件，即Stu.hbm.xml的配置文件 * &lt;class&gt;标签 -- 用来将类与数据库表建立映射关系 * name -- 类的全路径 * table -- 表名.(类名与表名一致,那么table属性也可以省略) * catalog -- 数据库的名称，基本上都会省略不写 * &lt;id&gt;标签 -- 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。 * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。 * &lt;property&gt; -- 用来将类中的普通属性与表中的字段建立映射. * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 数据长度 * type -- 数据类型（一般都不需要编写，如果写需要按着规则来编写） * Hibernate的数据类型 type=&quot;string&quot; * Java的数据类型 type=&quot;java.lang.String&quot; * 数据库字段的数据类型 &lt;column name=&quot;name&quot; sql-type=&quot;varchar&quot;/&gt; Hibernate配置文件之核心配置文件 1. 核心配置文件的两种方式 * 第一种方式是属性文件的形式，即properties的配置文件 * hibernate.properties * hibernate.connection.driver_class=com.mysql.jdbc.Driver * 缺点 * 不能加载映射的配置文件，需要手动编写代码去加载 * 第二种方式是XML文件的形式，开发基本都会选择这种方式 * hibernate.cfg.xml * &lt;property name=&quot;hibernate.connection.driver_class&quot; &gt;com.mysql.jdbc.Driver&lt;/property&gt; * 优点 * 格式比较清晰 * 编写有提示 * 可以在该配置文件中加载映射的配置文件（最主要的） 2. 关于hibernate.cfg.xml的配置文件方式 * 必须有的配置 * 数据库连接信息: hibernate.connection.driver_class -- 连接数据库驱动程序 hibernate.connection.url -- 连接数据库URL hibernate.connection.username -- 数据库用户名 hibernate.connection.password -- 数据库密码 * 方言: hibernate.dialect -- 操作数据库方言 * 可选的配置 * hibernate.show_sql -- 显示SQL * hibernate.format_sql -- 格式化SQL * hibernate.hbm2ddl.auto -- 通过映射转成DDL语句 * create -- 每次都会创建一个新的表.---测试的时候 * create-drop -- 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.---测试的时候 * update -- 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构. * validate -- 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错. * 加载映射 * 如果XML方式：&lt;mapping resource=&quot;cn/itcast/hibernate/domain/User.hbm.xml&quot; /&gt; 技术分析之Hibernate常用的接口和类 Configuration类和作用 1. Configuration类 * Configuration对象用于配置并且启动Hibernate。 * Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。 * 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。 2. Configuration类的其他应用（了解） * 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。 * 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件 * 但是需要自己手动加载映射文件 * 例如：config.addResource(&quot;cn/itcast/domain/Student.hbm.xml&quot;); * 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件 SessionFactory：重要 1. 是工厂类，是生成Session对象的工厂类 2. SessionFactory类的特点 * 由Configuration通过加载配置文件创建该对象。 * SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。 * 预定义SQL语句 * 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句 * 常见的SQL语句是增删改查（通过主键来查询） * 这样做的目的是效率更高 * 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。 * SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。 * SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。 * SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 3. 总结 * 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。 编写HibernateUtil的工具类 1. 具体代码如下 public class HibernateUtil { private static final Configuration cfg; private static final SessionFactory factory; static{ // 给常量赋值 // 加载配置文件 cfg = new Configuration().configure(); // 生成factory对象 factory = cfg.buildSessionFactory(); } // 获取Session对象 public static Session openSession(){ return factory.openSession(); } } Session接口 1. 概述 * Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象 * Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心 * Session是线程不安全的 * 所有持久化对象必须在 session 的管理下才可以进行持久化操作 * Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处 * 持久化类与 Session 关联起来后就具有了持久化的能力 2. 特点 * 不是线程安全的。应避免多个线程使用同一个Session实例 * Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例 * Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存 3. 常用的方法 * save(obj) * delete(obj) * get(Class,id) * update(obj) * saveOrUpdate(obj) -- 保存或者修改（如果没有数据，保存数据。如果有，修改数据） * createQuery() -- HQL语句的查询的方式 Transaction接口 1. Transaction是事务的接口 2. 常用的方法 * commit() -- 提交事务 * rollback() -- 回滚事务 3. 特点 * Hibernate框架默认情况下事务不自动提交.需要手动提交事务 * 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务 开发步骤 1. 准备环境 * 在资料/crm/ui/WebRoot下所有的文件，拷贝到工程中 * 引入JSTL的标签库，JSP页面会报错 编写代码","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://vvshyer.com/tags/Hibernate/"}]},{"title":"算法之回文串","date":"2017-03-16T08:33:21.000Z","path":"2017/03/16/算法之最长回文串/","text":"1088 最长回文字串回文串是指aba、abba、cccbccc、aaaa这种左右对称的字符串。输入一个字符串Str，输出Str里最长回文子串的长度。 Input 输入Str（Str的长度 &lt;= 1000) Output 输出最长回文子串的长度L。 从中心向两边扩展12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Main&#123; public static char[] arr = new char[1001]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); String str = cin.nextLine(); arr = str.toCharArray(); int res = 0; for (int i = 0; i &lt; str.length();i++)&#123; for (int j = 0; (i-j)&gt;=0 &amp;&amp; (i+j)&lt;str.length();j++) &#123; if (arr[i - j] != arr[i + j]) &#123; break; &#125; int tmp = 2 * j + 1; if (tmp &gt;= res) &#123; res = tmp; &#125; &#125; for (int j = 0; (i-j)&gt;=0 &amp;&amp; (i+j+1)&lt;str.length();j++) &#123; if (arr[i - j] != arr[i + j + 1]) &#123; break; &#125; int tmp = 2 * j + 2; if (tmp &gt;= res) &#123; res = tmp; &#125; &#125; &#125; System.out.println(res); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"算法之背包问题","date":"2017-03-16T06:17:23.000Z","path":"2017/03/16/算法之背包问题/","text":"1085 背包问题在N件物品取出若干件放在容量为V的背包里，每件物品的体积为C1，C2……Cn（Ci为整数），与之相对应的价值为W1,W2……Wn（Wi为整数）。求背包能够容纳的最大价值。 Input 第1行，2个整数，N和V中间用空格隔开。N为物品的数量，V为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= V &lt;= 10000) 第2 - N + 1行，每行2个整数，Ci和Wi，分别是物品的体积和物品的价值。(1 &lt;= Ci, Wi &lt;= 10000) Output 输出可以容纳的最大价值。 基本思路这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用自问题定义状态：即 F[i,v] = max{F[i-1,v],F[i-1,v-Ci] + Wi} 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由他衍生出来的。所以有必要将它仔细解释一下：“将前i件物品放入容量为v的背包中“这个字问题，若只考虑第i件物品的策略，那么就可以转化为一个只和前i-1件物品相关的问题。如果不放第i件物品，那么问题就转换为“前i-1件物品放入容量为v的背包中“，价值为F[i-1,v]；如果放第i件物品，那么问题就转换为“前i-1件物品放入剩下的容量为v-Ci的背包中，此时能获得的最大价值就是F[i-1,v-Ci]再加上通过放入第i件物品获得的价值Wi。 12F[0,0..V] ← 0for i←1 to N for v←Ci to V F[i,v] ← max&#123;F[i−1,v], F[i−1,v−Ci] + Wi&#125; 优化空间复杂度以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该不能再优化了，但空间复杂度却可以优化到O(V)。 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i ← 1…N，每次算出二维数组F[i,0…V]的所有值。那么，如果只用一个数组F[0…V]，能不能保证第i次循环结束后F[v]中表示的就是我们定义的状态F[i,v]呢？F[i,v]是由F[i-1,v]和F[i-1,v-Ci]两个字问题递推而来，能否保证在推F[i,v]时能够取用F[i-1,v]和F[i-1,v-Ci]的值呢？ 事实上，这要求在每次主循环中我们以 v ← V…0 的递减顺序计算F[v]，这样才能保证计算F[v]时F[v - Ci]保存的事状态F[i-1,v-Ci]的值。伪代码如下: 1F[0..V] ← 0 for i←1 to N for v←V to Ci F[v] ← max&#123;F[v], F[v−Ci] + Wi&#125; 其中的 F[v] ← max{F[v], F[v−Ci] + Wi} 一句，恰就对应于我们原来的转移方程，因为现在的F[v-Ci]就相当于原来的F[i-1,v-Ci]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了F[i,v]由F[i,v-Ci]推导得到，与题意不符。 事实上，使用以为数组解01背包问题在后面多次用到，以后不再说明。 12def ZeroOnePack(F,C,W) for v ← V to C F[v] ← max(F[v], F[v−C] + W) 有了这个，01背包问题的伪代码可以这么写： 1F [0..V ] ← 0 for i ← 1 to N ZeroOnePack(F, Ci, Wi) 初始化的细节问题我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目 要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。 如果是第一种问法，要求恰好装满背包，那么在初始化时除了 F[0] 为 0，其它 F [1..V ] 均设为 −∞，这样就可以保证最终得到的 F [V ] 是一种恰好装满背包的最优解。 如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 F [0..V ] 全部设为 0。 这是为什么呢?可以这样理解:初始化的 F 数组事实上就是在没有任何物品可以放 入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什 么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于 未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包 都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0 了。 这个小技巧完全可以推广到其它类型的背包问题，后面不再对进行状态转移之前的 初始化进行讲解。 一个常数优化上面伪代码中的 for i←1 to N for v←V to Ci 中第二重循环的下限可以改进。它可以被优化为 for i←1 to N for v←V to max(V−ΣNi Wi,Ci) 这个优化之所以成立的原因请读者自己思考。(提示:使用二维的转移方程思考较易。) 小结01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成 01 背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及空间复杂度怎样被优化。","tags":[{"name":"算法 | 数学","slug":"算法-数学","permalink":"https://vvshyer.com/tags/算法-数学/"}]},{"title":"数学基础之中国剩余定理","date":"2017-03-15T14:06:54.000Z","path":"2017/03/15/数学基础之中国剩余定理/","text":"1079 中国剩余定理一个正整数K，给出K Mod 一些质数的结果，求符合条件的最小的K。例如，K % 2 = 1, K % 3 = 2, K % 5 = 3。符合条件的最小的K = 23。 Input 第1行：1个数N表示后面输入的质数及模的数量。（2 &lt;= N &lt;= 10) 第2 - N + 1行，每行2个数P和M，中间用空格分隔，P是质数，M是K % P的结果。（2 &lt;= P &lt;= 100, 0 &lt;= K &lt; P) Output 输出符合条件的最小的K。数据中所有K均小于10^9。 例7：一个班学生分组做游戏，如果每组三人就多两人，每组五人就多三人，每组七人就多四人，问这个班有多少学生? 题目可以看成，除3余2，除5余3，除7余4。没有同余的情况，用的方法是“逐步约束法”，就是从“除7余4的数”中找出符合“除5余3的数”，就是再7上一直加7，直到所得的数除5余3。得出数为18，下面只要在18上一直加7和5得最小公倍数35，直到满足“除3余2” 4+7=11 11+7=18 18+35=53 在第一个余数的基础上，加上最小公倍数，如果取余得到要求得余数就取该值（最小） 1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static int[] P = new int[10]; public static int[] M = new int[10]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int N = cin.nextInt(); for (int i = 0;i &lt; N;i++)&#123; P[i] = cin.nextInt(); M[i] = cin.nextInt(); &#125; int j; int s= 1, k = M[0]; for (int i = 0;i &lt; N-1;i++)&#123; s = s * P[i]; while (k % P[i+1] != M[i+1])&#123; k+=s; &#125; &#125; System.out.println(k); &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"数学基础之约瑟夫环","date":"2017-03-15T14:01:39.000Z","path":"2017/03/15/数学基础之约瑟夫环/","text":"1073 约瑟夫环N个人坐成一个圆环（编号为1 - N），从第1个人开始报数，数到K的人出列，后面的人重新从1开始报数。问最后剩下的人的编号。 例如：N = 3，K = 2。2号先出列，然后是1号，最后剩下的是3号。 Input 2个数N和K，表示N个人，数到K出列。(2 &lt;= N, K &lt;= 10^6) Output 最后剩下的人的编号 解法一：思路：建立一个有N个元素的循环链表，然后从链表表头遍历并记数，如果计数i==m(i初始为1)删除元素，依次类推，若当前元素等于该元素链接的下一元素时终止循环。 解法二：用数学归纳法递推。 无论是用链表实现还是用数组实现都有一个共同点：要模拟整个游戏过程，不仅程序写起来比较烦，而且时间复杂度高达O(nm)，若nm非常大，无法在短时间内计算出结果。我们注意到原问题仅仅是要求出最后的胜利者的序号，而不是要读者模拟整个过程。因此如果要追求效率，就要打破常规，实施一点数学策略。 为了讨论方便，先把问题稍微改变一下，并不影响原意：问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 我们知道第一个人(编号一定是m%n-1) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:k k+1 k+2 … n-2, n-1, 0, 1, 2, … k-2并且从k开始报0。现在我们把他们的编号做一下转换： k –&gt; 0k+1 –&gt; 1k+2 –&gt; 2……k-2 –&gt; n-2k-1 –&gt; n-1变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k)%n 如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况——这显然就是一个倒推问题！好了，思路出来了，下面写递推公式： 令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n] 递推公式f[1]=0;f[i]=(f[i-1]+m)%i; (i&gt;1) 有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1 123456789101112131415161718import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); long N = cin.nextLong(); long K = cin.nextLong(); System.out.println(fun(N,K)+1); &#125; public static long fun(long N,long K)&#123; long res = 0; for (int i = 1;i&lt;=N;i++)&#123; res = (res+K)%i; &#125; return res; &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"算法之博弈论初探","date":"2017-03-15T13:56:03.000Z","path":"2017/03/15/算法之博弈论初探/","text":"1066 Bash游戏有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。 例如N = 3，K = 2。无论A如何拿，B都可以拿到最后1颗石子。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000) 第2 - T + 1行：每行2个数N，K。中间用空格分隔。（1 &lt;= N,K &lt;= 10^9) Output 共T行，如果A获胜输出A，如果B获胜输出B。 1234567891011121314151617181920import java.util.Scanner;public class Main &#123; public static char[] ans = new char[10000]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int T = cin.nextInt(); for (int i = 0;i&lt; T ;i++)&#123; int N = cin.nextInt(); int K = cin.nextInt(); if ((N % (K+1)) == 0) ans[i] = 'B'; else ans[i] = 'A'; &#125; for (int i = 0;i&lt;T;i++)&#123; System.out.println(ans[i]); &#125; &#125;&#125; 1069 Nim游戏有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。 例如：3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。 Input 第1行：一个数N，表示有N堆石子。（1 &lt;= N &lt;= 1000) 第2 - N + 1行：N堆石子的数量。(1 &lt;= A[i] &lt;= 10^9) Output 如果A获胜输出A，如果B获胜输出B。 123456789101112131415161718import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int T = cin.nextInt(); int tmp , ret = 0; for (int i = 0;i&lt; T ;i++)&#123; tmp = cin.nextInt(); if (i==0) ret = tmp; else ret = ret ^ tmp; &#125; char ans; if (ret==0) ans = 'B'; else ans = 'A'; System.out.println(ans); &#125;&#125; 1072 威左夫游戏有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。 例如：2堆石子分别为3颗和5颗。那么不论A怎样拿，B都有对应的方法拿到最后1颗。 Input 第1行：一个数T，表示后面用作输入测试的数的数量。（1 &lt;= T &lt;= 10000) 第2 - T + 1行：每行2个数分别是2堆石子的数量，中间用空格分隔。(1 &lt;= N &lt;= 2000000) Output 共T行，如果A获胜输出A，如果B获胜输出B。 1234567891011121314151617#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int t,n,m,temp; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%d%d\",&amp;n,&amp;m); if(n&gt;m) swap(n,m); temp=(m-n)*(sqrt(5)+1)/2; if(n==temp) printf(\"B\\n\"); else printf(\"A\\n\"); &#125; return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"数学基础之log的巧用","date":"2017-03-15T13:52:52.000Z","path":"2017/03/15/数学基础之log的巧用/","text":"1058 N的阶乘的长度1234567891011121314import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); double N = cin.nextLong(); double ans = 1; for (double i = 1; i &lt;= N;i++)&#123; ans = ans + Math.log10(i); &#125; System.out.println((int)ans); &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"算法之归并","date":"2017-03-15T13:47:26.000Z","path":"2017/03/15/算法之归并/","text":"1019 逆序数 在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。给出一个整数序列，求该序列的逆序数。 解法：归并排序是将两个(或两个以上)有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序的子序列合并为整体有序序列。归并排序是分治算法的一个典型的应用，而且是稳定的一种排序，这题利用归并排序的过程中，计算每个小区间的逆序数，进而得到大区间的逆序数。那么，问题就解决了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.BufferedInputStream;import java.util.Scanner;public class Main &#123; public static int N = 50005; public static int ans = 0; public static long[] a = new long[N]; public static long[] res = new long[N]; public static void main(String[] args) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); int n = cin.nextInt(); for (int i = 1;i&lt;=n;i++)&#123; a[i] = cin.nextLong(); &#125; ans = 0; mer_sort(1,n); System.out.println(ans); &#125; public static void merge(int left, int right)&#123; int mid = (left+right)&gt;&gt;1; int i = left,j = mid+1; int cur = left; while(i &lt;= mid &amp;&amp; j &lt;= right)&#123; if(a[i] &lt;= a[j]) res[cur++] = a[i++]; else&#123; res[cur++] = a[j++]; ans += mid-i+1; //找到逆序的个数 &#125; &#125; while(i &lt;= mid) res[cur++] = a[i++]; while(j &lt;= right) res[cur++] = a[j++]; for(i = left;i &lt;= right;i ++) a[i] = res[i]; &#125; public static void mer_sort(int left ,int right)&#123; if (left &lt; right)&#123; int mid = (left+right)&gt;&gt;1; mer_sort(left,mid); //分解 mer_sort(mid+1,right); //分解 merge(left,right); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"数学基础之求最大公约数、最小公倍数","date":"2017-03-14T11:48:44.000Z","path":"2017/03/14/数学基础之求最大公约数/","text":"用Java求最大公约数GCD1011 最大公约数GCD12345678910111213141516171819202122import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); long A = cin.nextLong(); long B = cin.nextLong(); System.out.println(gcd(A,B)); &#125; /** * 辗转相除法：两个整数的最大公约数等于其中较小的数和两数的相除余数的最大公约数。 */ public static long gcd(long m,long n)&#123; while (true)&#123; if ((m = m % n) == 0) return n; if ((n = n % m) == 0) return m; &#125; &#125;&#125; 最小公倍数1012 最小公倍数LCM1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); long A = cin.nextLong(); long B = cin.nextLong(); System.out.println(lcm(A,B)); &#125; public static long gcd(long m,long n)&#123; while (true)&#123; if ((m = m % n) == 0) return n; if ((n = n % m) == 0) return m; &#125; &#125; /** * 在GCM基础上改动 * 最小公倍数 = n*m/最大公约数 */ public static long lcm(long m,long n)&#123; return m*n/gcd(m,n); &#125;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"https://vvshyer.com/tags/数学/"}]},{"title":"算法之动态规划","date":"2017-03-14T11:30:12.000Z","path":"2017/03/14/算法之动态规划/","text":"1006 最长公共子序列LCS给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。比如两个串为： 12abcicbaabdkscab ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。 Input 第1行：字符串A 第2行：字符串B(A,B的长度 &lt;= 1000) Output 输出最长的子序列，如果有多个，随意输出1个。 Input示例 12abcicbaabdkscab Output示例1abca 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); String sA = cin.nextLine(); String sB = cin.nextLine(); char[] A = sA.toCharArray(); char[] B = sB.toCharArray(); int len1 = A.length; int len2 = B.length; int[][] L = new int[1005][1005]; int[][] M = new int[1005][1005]; for (int i = 1;i&lt;=len1;i++)&#123; for (int j = 1; j&lt;= len2;j++)&#123; if (A[i-1]==B[j-1])&#123; L[i][j] = L[i-1][j-1]+1; M[i][j] = 1; &#125;else &#123; if (L[i-1][j] &gt;= L[i][j-1])&#123; L[i][j] = L[i-1][j]; M[i][j] = 2; &#125;else &#123; L[i][j] = L[i][j-1]; M[i][j] = 3; &#125; &#125; &#125; &#125; LCS(M,len1,len2,A); &#125; public static void LCS(int[][] M,int i,int j,char[] x)&#123; if (i==0 || j==0) return; if (M[i][j]==1)&#123; LCS(M,i-1,j-1,x); System.out.print(x[i-1]); &#125;else &#123; if (M[i][j] == 2)&#123; LCS(M,i-1,j,x); &#125;else &#123; LCS(M,i,j-1,x); &#125; &#125; &#125;&#125; 1049 最大子段和 求和，每次判断和是否&gt;=0，若是，则加上a[i],否则sum=a[i],并更新最大值. 12345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static long[] numbers = new long[50001]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int N = cin.nextInt(); for (int i = 0;i&lt;N;i++)&#123; numbers[i] = cin.nextLong(); &#125; long max = -1; long sum = 0; for (int i = 0;i&lt;N;i++)&#123; if (sum &gt;= 0)&#123; sum += numbers[i]; &#125;else &#123; sum = numbers[i]; &#125; if (sum &gt; max)&#123; max = sum; &#125; &#125; System.out.println(max); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"机试笔记08Java中的表","date":"2017-03-14T04:10:09.000Z","path":"2017/03/14/机试笔记08Java中的表/","text":"List1234567public interface List&lt;AnyType&gt; extends Collection&lt;AnyType&gt;&#123; AnyType get(int idx); AnyType set(int idx, AnyType newVal); void add(int idx, AnyType x); void remove(int idx); ListIterator&lt;AnyType&gt; listIterator(int pos); ArrayList 对get和set的调用花费常数时间 插入删除代价昂贵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.main;import java.util.Iterator;import java.util.NoSuchElementException;/** * Created by sunhuayan on 2017/3/14. */public class MyArrayList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private int theSize; private AnyType[] theItems; public MyArrayList()&#123; clear(); &#125; public void clear()&#123; theSize = 0; ensureCapacity(DEFAULT_CAPACITY); &#125; public int size()&#123; return theSize; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public void trimToSize()&#123; ensureCapacity(size()); &#125; public AnyType get(int idx)&#123; if (idx &lt; 0 || idx &gt;= size())&#123; throw new ArrayIndexOutOfBoundsException(); &#125; return theItems[idx]; &#125; public AnyType set(int idx, AnyType newVal)&#123; if (idx &lt; 0 || idx &gt;= size())&#123; throw new ArrayIndexOutOfBoundsException(); &#125; AnyType old = theItems[idx]; theItems[idx] = newVal; return old; &#125; private void ensureCapacity(int newCapacity) &#123; if (newCapacity &lt; theSize)&#123; return; &#125; AnyType[] old = theItems; theItems = (AnyType[]) new Object[newCapacity]; for (int i=0; i &lt; size(); i++)&#123; theItems[i] = old[i]; &#125; &#125; public boolean add(AnyType x)&#123; add(size(),x); return true; &#125; public void add(int idx, AnyType x)&#123; if (theItems.length == size())&#123; ensureCapacity(size() * 2 + 1); &#125; for (int i = theSize; i &gt; idx; i--)&#123; theItems[i] = theItems[i-1]; &#125; theItems[idx] = x; theSize++; &#125; public AnyType remove(int idx)&#123; AnyType removeItem = theItems[idx]; for (int i = idx; i &lt; size()-1; i++) theItems[i] = theItems[i+1]; theSize--; return removeItem; &#125; @Override public Iterator&lt;AnyType&gt; iterator() &#123; return new ArrayListIterator(); &#125; private class ArrayListIterator implements Iterator&lt;AnyType&gt;&#123; private int current = 0; public boolean hasNext()&#123; return current &lt; size(); &#125; public AnyType next()&#123; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; return theItems[current++]; &#125; public void remove()&#123; MyArrayList.this.remove(--current); &#125; &#125;&#125; LinkedList 插入删除开销小 不易索引 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172package com.main;import java.util.ConcurrentModificationException;import java.util.Iterator;import java.util.NoSuchElementException;/** * Created by sunhuayan on 2017/3/14. */public class MyLinkedList&lt;AnyType&gt; implements Iterable&lt;AnyType&gt; &#123; private int theSize; private int modCount = 0; private Node&lt;AnyType&gt; beginMarker; private Node&lt;AnyType&gt; endMarker; private static class Node&lt;AnyType&gt;&#123; public AnyType data; public Node&lt;AnyType&gt; prev; public Node&lt;AnyType&gt; next; public Node(AnyType d, Node&lt;AnyType&gt; p, Node&lt;AnyType&gt; n)&#123; data = d; prev = p; next = n; &#125; &#125; public MyLinkedList()&#123; clear(); &#125; /** * Change the size of this collection to zero. */ public void clear()&#123; beginMarker = new Node&lt;AnyType&gt;(null,null,null); endMarker = new Node&lt;AnyType&gt;(null, beginMarker, null); beginMarker.next = endMarker; theSize = 0; modCount++; &#125; public int size()&#123; return theSize; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public boolean add(AnyType x)&#123; add(size(),x); return true; &#125; public void add(int idx, AnyType x)&#123; addBefore(getNode(idx),x); &#125; public AnyType get(int idx)&#123; return getNode(idx).data; &#125; public AnyType set(int idx, AnyType newVal)&#123; Node&lt;AnyType&gt; p = getNode(idx); AnyType oldVal = p.data; p.data = newVal; return oldVal; &#125; public AnyType remove(int idx)&#123; return remove(getNode(idx)); &#125; /** * Adds an item to this collection, at specified position p. * Items at or after that position are slid one position higher. * @param p Node to add before. * @param x any object * @throws IndexOutOfBoundsException if idx is not between 0 and size(). */ private void addBefore(Node&lt;AnyType&gt; p, AnyType x)&#123; Node&lt;AnyType&gt; newNode = new Node&lt;AnyType&gt;(x,p.prev,p); newNode.prev.next = newNode; p.prev = newNode; theSize++; modCount++; &#125; /** * Removes the Object contained in Node p. * @param p the Node containing the object. * @return the item was removed from the collection. */ private AnyType remove(Node&lt;AnyType&gt; p) &#123; p.next.prev = p.prev; p.prev.next = p.next; theSize--; modCount++; return p.data; &#125; /** * Gets the Node at position idx, which must range from 0 to size(). * @param idx index of node being obtained. * @return internal node corresponding to idx. * @throws IndexOutOfBoundsException if idx is not between 0 and size(). */ private Node&lt;AnyType&gt; getNode(int idx)&#123; Node&lt;AnyType&gt; p; if (idx &lt; 0 || idx &gt; size())&#123; throw new IndexOutOfBoundsException(); &#125; if (idx &lt; size()/2)&#123; p = beginMarker.next; for (int i = 0; i &lt; idx; i++)&#123; p = p.next; &#125; &#125;else &#123; p = endMarker; for (int i = size(); i &gt; idx; i--)&#123; p = p.prev; &#125; &#125; return p; &#125; @Override public Iterator&lt;AnyType&gt; iterator() &#123; return new LinkedListIterator(); &#125; private class LinkedListIterator implements Iterator&lt;AnyType&gt;&#123; private Node&lt;AnyType&gt; current = beginMarker.next; private int expectedModCount = modCount; private boolean okToRemove = false; @Override public boolean hasNext() &#123; return current!=endMarker; &#125; @Override public AnyType next() &#123; if (modCount != expectedModCount)&#123; throw new ConcurrentModificationException(); &#125; if (!hasNext())&#123; throw new NoSuchElementException(); &#125; AnyType nextItem = current.data; current = current.next; okToRemove = true; return nextItem; &#125; @Override public void remove() &#123; if (modCount != expectedModCount)&#123; throw new ConcurrentModificationException(); &#125; if (!okToRemove)&#123; throw new IllegalStateException(); &#125; MyLinkedList.this.remove(current.prev); okToRemove = false; expectedModCount++; &#125; &#125;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记07栈的应用","date":"2017-03-13T12:30:01.000Z","path":"2017/03/13/机试笔记07栈的应用/","text":"栈的应用12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; S;//定义一个堆栈char str[110];//保存输入字符串char ans[110];//保存输出字符串int main()&#123; while (scanf(\"%s\",str)!=EOF) &#123; int i; for (i = 0; str[i]!=0; i++) &#123;//从左到右遍历字符串 if (str[i] == '(') &#123;//若遇到左括号 S.push(i);//将其数组下标放入栈中 ans[i] = ' ';//暂且将对应的输出字符串位置改为空格 &#125;else if(str[i]==')')&#123;//若遇到右括号 if (S.empty() == false) &#123;//若此时栈为空 S.pop();//栈顶左括号与其匹配，从战中弹出 ans[i] = ' ';//修改输出中该位置为空格 &#125;else&#123; ans[i] = '?';//若栈为空，则无法找到左括号匹配 &#125; &#125;else&#123; ans[i] = ' ';//若为其它字符 &#125; &#125; while (!S.empty()) &#123;//字符串遍历完成剩下的无法匹配的左括号 ans[S.top()] = '$';//修改其在输出中的位置为\"$\" S.pop(); &#125; //ans[i] = 0; //为了使输出形成字符串，在其最后一个字符后添加一个空字符 puts(str);//输出字符串 puts(ans); return 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stack&gt;#include &lt;stdio.h&gt;using namespace std;char str[220];//保存表达式字符串int mat[][5]&#123;//优先级矩阵，若mat[i][j]==1,则表示i号运算符优先级大于j号运算符，运算符编码规则为+1号，-2号，*3号，/4号 //人为添加在表达式首位的标记运算符为0号 1,0,0,0,0, 1,0,0,0,0, 1,0,0,0,0, 1,1,1,0,0, 1,1,1,0,0&#125;;stack&lt;int&gt; op;//运算符栈,保存运算符编号stack&lt;double&gt; in;//数字栈void getOp(bool &amp;reto,int &amp;retn,int &amp;i)&#123; //获得表达式中 下一个元素函数，若函数运行结束时，引用变量reto为true,则表示该元素为一个运算符，其编号保存在引用变量retn中；否则，表示该元素为一个数字，其值保存在引用变量retn中，引用变量i表示遍历到的字符串下标 if (i == 0 &amp;&amp; op.empty() == true) &#123;//若此时遍历字符串第一个字符，且运算符栈为空，我们人为添加编号为0的标记字符 reto = true;//运算符 retn = 0;//编号为0 return; &#125; if (str[i] == 0) &#123;//若此时遍历字符为空字符，则表示该字符串已被遍历完 reto = true; retn = 0; return; &#125; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123;//若当前字符为数字 reto = false;//返回为数字 &#125;else&#123;//否则 reto = true;//返回为运算符 if (str[i] == '+') &#123; retn = 1; &#125;else if(str[i] == '-')&#123; retn = 2; &#125;else if(str[i] == '*')&#123; retn = 3; &#125;else if(str[i] == '/')&#123; retn = 4; &#125; i += 2;//i递增，跳过该运算字符和后面的空格 return; &#125; retn = 0;//返回结果为数字 for (; str[i] != ' ' &amp;&amp; str[i] != 0 ; i++) &#123;//若字符串未遍历完，且在一个字符不是空格，则依次遍历其后数字，计算当前连续数字字符表示的数值 retn *= 10; retn += str[i] - '0'; &#125; if (str[i] == ' ')&#123;//若其后字符为空格，则表示字符串未被遍历完 i++;//i递增，跳过该空格 &#125; return;&#125;int main()&#123; while (gets(str)) &#123;//输入字符串，当其位于文件尾时，gets返回0 if (str[0] == '0' &amp;&amp; str[1] == 0) &#123;//若输入只有1个0，则退出 break; &#125; bool retop; int retnum;//定义函数所需的引用变量 int idx = 0;//定义遍历到的字符串下标，初始值尾0 while (!op.empty()) &#123; op.pop(); &#125; while (!in.empty()) &#123; in.pop();//清空数字栈和运算符栈 &#125; while (true) &#123;//循环遍历表达式字符串 getOp(retop, retnum, idx);//获取表达式中下一个元素 if (retop == false) &#123;//若该元素为数字 in.push((double)retnum);//将其压入数字栈中 &#125;else&#123;//否则 double tmp; if (op.empty() == true || mat[retnum][op.top()] == 1) &#123; op.push(retnum);//若运算符栈为空或当前遍历到的运算符优先级大于栈顶运算符，将该运算符压入运算符堆栈 &#125;else&#123;//否则 while (mat[retnum][op.top()] == 0) &#123;//只要当前运算符优先级小于栈顶元素运算符，则重复循环 int ret = op.top();//保存栈顶运算符 op.pop(); double b = in.top(); in.pop(); double a = in.top(); in.pop();//从数字栈栈顶弹出两个数字，依次保存在遍历a,b中 if (ret == 1) &#123; tmp = a+b; &#125;else if(ret == 2)&#123; tmp = a - b; &#125;else if(ret == 3)&#123; tmp = a * b; &#125;else&#123; tmp = a/b;//按照运算符类型完成运算 &#125; in.push(tmp);//将结果压回数字栈 &#125; op.push(retnum);//将当前运算符压入运算符栈 &#125; &#125;if (op.size() == 2 &amp;&amp; op.top() == 0) &#123;//若运算符栈只有两个元素，且栈顶元素为标记运算符，则表示表达式求值结束 break; &#125; &#125; printf(\"%.2f\\n\",in.top()); &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记06Java在ACM中的应用","date":"2017-03-11T13:00:49.000Z","path":"2017/03/11/机试笔记06Java在ACM中的应用/","text":"Chapter I.Java的优缺点各种书上都有，这里只说说用Java做ACM-ICPC的特点： 最明显的好处是，学会Java，可以参加Java Challenge 对于熟悉C/C++的程序员来说，Java并不难学，找本书，一两周业余时间就可以搞定了。当然，这里只是指一般编程，想熟悉所有的Java库还是需要些时间的。 在一般比赛中，Java程序会有额外的时间和空间，而实际上经过实验，在执行计算密集任务的时候Java并不比C/C++慢多少，只是IO操作较慢而已。 Java简单而功能强大，有些东西用Java实现起来更为方便，比如高精度。 用Java不易犯细微的错误，比如C/C++中的指针，“if (n = m) … ” 等 目前来看Eclipse已成基本配置，写Java程序反而比C/C++更方便调试。在具体竞赛时也算多一种选择。 学会Java对以后工作有好处。现在国外很多地方会Java的人比会C/C++的人多。 会Java可以使你看起来更像偶蹄类动物（牛） hoho~ Chapter II.下面说一下ACM-ICPC队员初用Java编程所遇到的一些问题：基本输入输出： JDK 1.5.0 新增的Scanner类为输入提供了良好的基础，简直就是为ACM-ICPC而设的。 一般用法为： 1234567891011121314151617181920212223242526import java.io.* import java.util.* public class Main &#123; public static void main(String args[]) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); ... &#125; &#125; ``` * 读一个整数： int n = cin.nextInt(); * 读一个字符串：String s = cin.next(); * 读一个浮点数：double t = cin.nextDouble();* 读一整行：String s = cin.nextLine(); * 判断是否有下一个输入可以用 cin.hasNext() 或 cin.hasNextInt() 或 cin.hasNextDouble() 等，具体见 TOJ 1001 例程。 * 输出一般可以直接用 System.out.print() 和 System.out.println()，前者不输出换行，而后者输出。 比如：System.out.println(n); // n 为 int 型 同一行输出多个整数可以用```Java System.out.println(new Integer(n).toString() + \" \" + new Integer(m).toString()); 也可重新定义： 12static PrintWriter cout = new PrintWriter(new BufferedOutputStream(System.out)); cout.println(n); 对于输出浮点数保留几位小数的问题，可以使用DecimalFormat类， 12345678import java.text.*; DecimalFormat f = new DecimalFormat(\"#.00#\"); DecimalFormat g = new DecimalFormat(\"0.000\"); double a = 123.45678, b = 0.12; System.out.println(f.format(a)); System.out.println(f.format(b)); System.out.println(g.format(b)); //这里0指一位数字，#指除0以外的数字。 大数字 BigInteger 和 BigDecimal 是在java.math包中已有的类，前者表示整数，后者表示浮点数 用法：不能直接用符号如+、-来使用大数字，例如： 12345(import java.math.*) // 需要引入 java.math 包 BigInteger a = BigInteger.valueOf(100); BigInteger b = BigInteger.valueOf(50); BigInteger c = a.add(b) // c = a + b; 主要有以下方法可以使用： 123456789BigInteger add(BigInteger other) BigInteger subtract(BigInteger other) BigInteger multiply(BigInteger other) BigInteger divide(BigInteger other) BigInteger mod(BigInteger other) int compareTo(BigInteger other) static BigInteger valueOf(long x) //输出大数字时直接使用 System.out.println(a) 即可。 字符串 String 类用来存储字符串，可以用charAt方法来取出其中某一字节，计数从0开始： 1String a = \"Hello\"; // a.charAt(1) = ’e’ 用substring方法可得到子串，如上例 1System.out.println(a.substring(0, 4)) // output \"Hell\" 注意第2个参数位置上的字符不包括进来。这样做使得 1s.substring(a, b) 总是有 b-a个字符。 字符串连接可以直接用 + 号，如 123String a = \"Hello\"; String b = \"world\"; System.out.println(a + \", \" + b + \"!\"); // output \"Hello, world!\" 如想直接将字符串中的某字节改变，可以使用另外的StringBuffer类。 调用递归（或其他动态方法）在主类中 main 方法必须是 public static void 的，在 main 中调用非static类时会有警告信息，可以先建立对象，然后通过对象调用方法： 12345678910111213141516171819public class Main &#123; ... void dfs(int a) &#123; if (...) return; ... dfs(a+1); &#125; public static void main(String args[]) &#123; ... Main e = new Main(); e.dfs(0); ... &#125; &#125; 其他注意的事项 Java是面向对象的语言，思考方法需要变换一下，里面的函数统称为方法，不要搞错。 Java 里的数组有些变动，多维数组的内部其实都是指针，所以Java不支持fill多维数组。 数组定义后必须初始化，如 1int[] a = new int[100]; 布尔类型为 boolean，只有true和false二值，在 if (…) / while (…) 等语句的条件中必须为boolean类型。 在C/C++中的 if (n % 2) … 在Java中无法编译通过。 下面在java.util包里Arrays类的几个方法可替代C/C++里的memset、qsort/sort 和 bsearch: 123Arrays.fill() Arrays.sort() Arrays.binarySearch()","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记05贪心算法","date":"2017-03-11T11:53:28.000Z","path":"2017/03/11/机试笔记05贪心算法/","text":"FatMouse’ Trade 有 m 元钱，n 种物品;每种物品有 j 磅，总价值 f 元，可以 使用 0 到 f 的任意价格购买相应磅的物品，例如使用 0.3f 元，可以购买 0.3j 磅物 品。要求输出用 m 元钱最多能买到多少磅物品 每次都买剩余物品中性价比最高的物品，知道该物品被买完活捉钱耗尽。但该物品已经被卖买完，则我们继续在剩余的物品中寻找性价比最高的物品 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;struct goods &#123; double j;//总重 double f;//总价值 double s;//性价比 bool operator &lt; (const goods &amp;A) const&#123; return s &gt; A.s; &#125;&#125;buf[1000];int main()&#123; double m; int n; while (scanf(\"%lf%d\",&amp;m,&amp;n)!=EOF)&#123; if (m == -1 &amp;&amp; n == -1) break; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%lf%lf\",&amp;buf[i].j,&amp;buf[i].f); buf[i].s = buf[i].j / buf[i].f;//计算性价比 &#125; sort(buf, buf+n); int idx = 0;//当前货物下标 double ans = 0;//累加所能得到的总重量 while (m &gt; 0 &amp;&amp; idx &lt; n) &#123; //若能买下全部该物品 if (m &gt; buf[idx].f) &#123; ans += buf[idx].j; m -= buf[idx].f; &#125;else&#123; //若只能买下部分该物品 ans += buf[idx].j * m / buf[idx].f; m = 0; &#125; idx++;//继续下一个物品 &#125; printf(\"%.3lf\\n\",ans); &#125; return 0;&#125; 今年暑假不AC 最优解中，第一个观看的节目一定是所有节目里结束时间最早的节目。因为按照优先选择结束时间最早的节目，我们所观看的第一个节目一定是所有节目里结束时间最早的。 如果最优解的第一个节目并不是结束最早的节目，那么我们可以直接用结束时间最早的节目代替该解中的第一个节目，替换后的解也是最优解。这样，我们就可以得出当第一个节目选择所有节目中结束时间最早的节目， 这样是一定不会得不到最优解的。于是，在我们所要求的最优解中，第一个被收看的节目可以安排所有节目中结束时间最早的节目(若有多个，则可任意选择一个)。 在选择第 x(x&gt;=1)个节目时， 一定是选择在收看完前 x-1 个节目后，其它所有可以收看节目中结束时间最早的节目，这就是我们要找的贪心策略。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;struct program&#123; int startTime; int endTime; bool operator &lt; (const program &amp;A) const&#123; return endTime &lt; A.endTime; &#125;&#125;buf[100];int main()&#123; int n; while (scanf(\"%d\",&amp;n)!=EOF) &#123; if (n == 0) &#123; break; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d%d\",&amp;buf[i].startTime,&amp;buf[i].endTime); &#125; sort(buf, buf+n); int currentTime = 0, ans = 0;//记录当前时间变量初始值为0 for (int i = 0; i&lt;n; i++) &#123; if (currentTime &lt;= buf[i].startTime) &#123; //若当前时间小于等于开始时间，那么收看该在剩余节目里结束时间最早的节目 currentTime = buf[i].endTime;//当前时间变为该节目结束时间 ans ++;//又收看了一个节目 &#125; &#125; printf(\"%d\\n\",ans);//输出 &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记04查找","date":"2017-03-10T13:07:41.000Z","path":"2017/03/10/机试笔记04查找/","text":"输入N个学生的信息进行查询 二分查找 12//存在一个升序有序的数组buf,其大小为size,目标数字为target int base = 0 , top = size; //初始情况与二分查找一致 while (base &lt;= top) &#123; //二分循环条件与二分查找一致 int mid = (base + top) / 2; if (buf[mid] &lt;= target) base = mid + 1; //符合前一部分数字规定 else top = mid - 1; //否则 &#125;int ans = top;//最后，top即位我们要求的数字数组下标，buf[top]为数字本省 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;struct Student &#123; char no[100]; char name[100]; int age; char sex[5]; bool operator &lt; (const Student &amp; A) const&#123; return strcmp(no, A.no) &lt; 0; &#125;&#125;buf[1000];int main()&#123; int n; while (scanf(\"%d\",&amp;n) != EOF) &#123; for (int i=0; i&lt;n; i++) &#123; scanf(\"%s%s%s%d\",buf[i].no,buf[i].name,buf[i].sex, &amp;buf[i].age); &#125;//输入 sort(buf, buf+n); int t; scanf(\"%d\",&amp;t); while (t-- != 0) &#123; int ans = -1; char x[30]; scanf(\"%s\",x); int top = n-1, base = 0; while (top &gt;= base) &#123; int mid = (top + base)/2; int tmp = strcmp(buf[mid].no, x); if (tmp == 0) &#123; ans = mid; break; &#125; else if(tmp &gt;0) top = mid - 1; else base = mid + 1; &#125; if (ans == -1) &#123; printf(\"No Answer!\\n\"); &#125;else&#123; printf(\"%s %s %s %d\\n\",buf[ans].no,buf[ans].name,buf[ans].sex,buf[ans].age); &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记03Hash的应用","date":"2017-03-09T07:50:27.000Z","path":"2017/03/09/机试笔记03Hash的应用/","text":"统计同成绩学生人数 读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int n; while (scanf(\"%d\",&amp;n) != EOF &amp;&amp; n != 0) &#123; int Hash[101] = &#123;0&#125;;//建立一个初始为0的Hash数组 for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\",&amp;x); Hash[x]++;//统计分数出现次数 &#125; int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",Hash[x]); &#125; return 0;&#125; Sort 给你 n 个整数，请按从大到小的顺序输出其中前 m 大的数。 每组测试数据有两行，第一行有两个数 n,m(0&lt;n,m&lt;1000000)，第二行包含 n 个各不相同，且都处于区间[-500000,500000]的整数。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define OFFSET 500000int Hash[1000001];int main()&#123; int n,m; while (scanf(\"%d%d\",&amp;n,&amp;m) != EOF) &#123; for (int i=-500000;i&lt;=500000; i++) &#123; Hash[i+OFFSET] = 0; &#125;//初始化 将每个数字都标记为未出现 for (int i=1; i&lt;=n; i++) &#123; int x; scanf(\"%d\",&amp;x); Hash[x+OFFSET] = 1;//凡是出现过的数字，该数组元素均为1 &#125; for (int i = 500000; i&gt;=-500000; i--) &#123;//输出前m个数 if (Hash[i+OFFSET]==1) &#123;//若该数字在输入中出现 printf(\"%d\",i);//输出该数字 m--;//输出一个数字后，m-- if (m!=0) &#123; printf(\" \"); &#125;else&#123; printf(\"\\n\"); break; &#125; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记02日期类问题","date":"2017-03-08T13:39:59.000Z","path":"2017/03/08/机试笔记02日期类问题/","text":"日期差值 在保存某个特定日期与原点日期的天数差时，用了三位数组 输入采用技巧 涉及开辟大量内存空间的情况，必须在函数体外定义或者动态malloc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0//定义宏判断是否是闰年，方便计算每月天数int dayOfMonth[13][2]&#123; 0,0, 31,31, //1 28,29, //2 31,31, //3 30,30, //4 31,31, //5 30,30, //6 31,31, //7 31,31, //8 30,30, //9 31,31, //10 30,30, //11 31,31 //12&#125;;struct Date&#123; int Day; int Month; int Year; //计算下一天的日期 void nextDay()&#123; Day++; if(Day &gt; dayOfMonth[Month][ISYEAP(Year)])&#123; //若日数超过最大日数 Day = 1; Month++;//进入下一月 if(Month &gt; 12)&#123;//月数超过12 Month = 1; Year++; //进入下一年 &#125; &#125; &#125;&#125;;int buf[5001][13][32];//保存预处理天数int Abs(int x)&#123; //求绝对值 return x &lt; 0 ? -x : x;&#125;int main()&#123; Date tmp; int cnt = 0; //天数计数 tmp.Day = 1; tmp.Month = 1; tmp.Year = 0;//初始化日期类对象为0年1月1日 while(tmp.Year != 5001) &#123; //将该日与0年1月1日的天数差保存起来 buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay();//计算下一天日期 cnt++;//计算器累加，每经过一天计数器+1,代表与原点日期的间隔又增加一天 &#125; int d1, m1, y1; int d2, m2, y2; while (scanf(\"%4d%2d%2d\",&amp;y1,&amp;m1,&amp;d1) != EOF) &#123; scanf(\"%4d%2d%2d\",&amp;y2,&amp;m2,&amp;d2);//读入要计算的两个日期 //用预处理的数据计算两日期差值，取绝对值 printf(\"%d\\n\",Abs(buf[y2][m2][d2] - buf[y1][m1][d1] + 1)); &#125; return 0;&#125; Day of Week 输入一个日期，要求输出该日期为星期几 1.今天是星期几; 2.今天和所给定的那天相隔几天。利用其对7求余数，我们便可以轻易的知道所给定的那天是星期几了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0//定义宏判断是否是闰年，方便计算每月天数int dayOfMonth[13][2]&#123; 0,0, 31,31, //1 28,29, //2 31,31, //3 30,30, //4 31,31, //5 30,30, //6 31,31, //7 31,31, //8 30,30, //9 31,31, //10 30,30, //11 31,31 //12&#125;;struct Date&#123; int Day; int Month; int Year; //计算下一天的日期 void nextDay()&#123; Day++; if(Day &gt; dayOfMonth[Month][ISYEAP(Year)])&#123; //若日数超过最大日数 Day = 1; Month++;//进入下一月 if(Month &gt; 12)&#123;//月数超过12 Month = 1; Year++; //进入下一年 &#125; &#125; &#125;&#125;;int buf[3001][13][32];//保存预处理天数char monthName[13][20] = &#123; \"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"&#125;;char weekName[7][20] = &#123; \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;;int main()&#123; Date tmp; int cnt = 0; //天数计数 tmp.Day = 1; tmp.Month = 1; tmp.Year = 0;//初始化日期类对象为0年1月1日 while(tmp.Year != 3001)&#123; //将该日与0年1月1日的天数差保存起来 buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay();//计算下一天日期 cnt++;//计算器累加，每经过一天计数器+1,代表与原点日期的间隔又增加一天 &#125; int d, m, y; char s[20]; while (scanf(\"%d%s%d\",&amp;d,s,&amp;y) != EOF) &#123; for (m = 1; m &lt;= 12; m++) &#123; if (strcmp(s,monthName[m]) == 0) &#123; break; &#125; &#125; //计算给定日期与今日日期的天数间隔 int days = buf[y][m][d] - buf[2017][3][6]; //今天2017年3月6日为星期一，对应数组下标为1，则计算1经过days天后的下标 days = days+1; puts(weekName[(days % 7 + 7)%7]); &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记01排序","date":"2017-03-07T11:24:03.000Z","path":"2017/03/07/机试笔记01排序/","text":"#冒泡排序12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; int n; int buf[100]; while(scanf(\"%d\",&amp;n)!=EOF)&#123;//输入n,并实现多组数据输入 for (int i=0; i&lt;n; i++) &#123; scanf(\"%d\",&amp;buf[i]); &#125; for (int i=0; i&lt;n; i++) &#123; for (int j=0; j&lt;n-1-i; j++) &#123; if (buf[j]&gt;buf[j+1]) &#123; int tmp = buf[j]; buf[j] = buf[j+1]; buf[j+1] = tmp; &#125; &#125; &#125; for (int i=0; i&lt;n; i++) &#123; printf(\"%d \",buf[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 1while(scanf(\"%d\",&amp;n)!=EOF) scanf函数是有返回值的，返回被输入函数成功复制的变量个数 此例中，若成功对n赋值，返回值为1 一般测试数据需要输入多组，需要对每组输入都输出相应答案 当输入已经到达结尾，scanf函数无法再为n赋值，scanf返回EOF 快速排序使用C++内置函数 sort 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int x, int y)&#123; //定义排序规则 return x&gt;y;&#125;int main()&#123; int n; int buf[100]; while (scanf(\"%d\",&amp;n)!=EOF) &#123; for (int i=0; i &lt; n; i++) &#123; scanf(\"%d\",&amp;buf[i]); &#125; //sort(buf,buf+n);//使用该重载形式，表明使用默认排序（递增） sort(buf,buf+n,cmp);//使用该重载形式，表明使用自定义规则 for (int i=0; i&lt;n; i++) &#123; printf(\"%d \",buf[i]); &#125; printf(\"\\n\"); &#125;&#125; #成绩排序 利用sort 题目描述 N 个学生的数据，将学生数据按成绩高低排序，如果成绩相同则按姓名 字符的字母序排序，如果姓名的字母序也相同则按照学生的年龄排序，并输出 N 个学生排序后的信息。 输入 测试数据有多组，每组输入第一行有一个整数 N(N&lt;=1000)，接下来的 N 行包括 N 个学生的数据。每个学生的数据包括姓名(长度不超过 100 的字符串)、年龄(整形数)、成绩(小于等于 100 的正数)。 输出 将学生信息按成绩进行排序，成绩相同的则按姓名的字母序进行排序。然后输出学生信息，按照如下格式:姓名 年龄 成绩 样例输入： 1233 abc 20 99bcd 19 97 bed 20 97 样例输出 123bcd 19 97 bed 20 97 abc 20 99 提示 学生姓名的字母序区分字母的大小写，如 A 要比 a 的字母序靠前(因为 A 的 ASC 码比 a 的 ASC 码要小)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;struct E&#123; char name[101]; int age; int score; bool operator &lt; (const E &amp;b) const&#123; //重载小于运算符 if(score != b.score) return score &lt; b.score; int tmp = strcmp(name, b.name); if(tmp != 0) return tmp&lt;0; else return age &lt; b.age; &#125;&#125;buf[100];//bool cmp(E a,E b)&#123;// if (a.score != b.score) &#123;// return a.score &lt; b.score;// &#125;// int tmp = strcmp(a.name, b.name);// if (tmp != 0) &#123;// return tmp &lt; 0;// &#125;else&#123;// return a.age &lt; b.age;// &#125;//&#125;int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF)&#123; for (int i=0; i&lt;n; i++) &#123; scanf(\"%s%d%d\",buf[i].name,&amp;buf[i].age,&amp;buf[i].score); &#125; //sort(buf, buf+n, cmp); sort(buf,buf+n); for (int i=0; i&lt;n; i++) &#123; printf(\"%s %d %d \\n\",buf[i].name,buf[i].age,buf[i].score); &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"计算机网络笔记01","date":"2017-03-01T13:56:07.000Z","path":"2017/03/01/计算机网络笔记01/","text":"第一章 概述 1.三网：电信网络、有线电视网络、计算机网络 2.起核心作用的是：计算机网络 计算机网络发展的五大阶段面向终端的网络（1957 - 1968）分组交换网络（1968 - 1984）网络体系结构的出现（1984 - 1986）Internet的出现（1986 - 今）新一代的计算机网络（ISDN）电路交换电路交换必定是面向连接的三个阶段 建立连接 通信 释放连接 分组交换网的工作原理 子网划分： 通信子网和资源子网 节点交换机工作方式： 存储转发 在发送端，先把较长的报文划分成较短的、固定长度的数据段 每一个数据段前面添加上首部构成分组 分组交换网以“分组”作为数据传输单元 依次把各分组发送到接收端 接收端收到分组后剥去首部还原成报文 分组首部的重要性 每一个分组的首部都含有地址等控制信息 分组交换网中的节点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个节点交换机 用这样的存储转发方式，最后分组就能到达最终目的地 主机和结点交换机 主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组 结点交换机对分组进行存储转发，最后把分组交付给目的主机 分组交换网优点 高效：动态或断续分配带宽 灵活：每个节点具有智能，独立选择路由 迅速：不太长的分组作为传输单位，每个节点能做出快速的处理 可靠：分布式的通信子网和完善的网络协议缺点 开销：分组携带信息带来的开销 可靠：分组可能丢失的现象 顺序：分组出现失序的现象 时延：分组在存储转发时造成的时延 计算机网络定义 把处在不同地理位置的独立计算机系统，用一定的通信设备和介质相连接，在完善的网络软件支持下，实现互相通信、资源共享，这样的多机系统称为计算机网络。 功能 数据通信 资源共享 增强可靠性 提高系统处理能力 分类从网络的交换功能进行分类 电路交换 优点：时延小、透明传输 缺点：网络资源利用率低 报文交换 优点：多路复用 缺点：实时性差 分组交换 优点：多路复用 缺点：实时性差 混合交换从网络的作用范围进行分类 广域网 WAN 局域网 LAN 城域网 MAN 接入网 AN从网络的使用者进行分类 公用网 专用网从网络的拓扑结构进行分类 总线型 星型 环型 网状从网络组件关系进行分类 对等网 基于服务器网络 主要性能指标带宽 是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。 时延 总时延 = 发送时延 + 传播时延 + 处理时延 体系结构形成分层 将复杂问题简单化 各层之间是独立的 结构上可分开 灵活性好 易于实现和维护 能促进标准化的工作 分层的必要性 计算机网络中的数据交换必须遵守事先约定好的规则。 这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。 为进行网络中的数据交换而建立的规则、标准或约定即网络协议(network protocol)，简称为协议。 五层协议的体系结构 应用层 运输层 网络层 数据链路层 物理层 实体、协议、服务和服务访问点 实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 协议是控制两个对等实体进行通信的规则的集合。 协议是“水平的” 服务是“垂直的” 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。 要实现本层协议，还需要使用下层所提供的服务。 服务访问点：SAP 同一系统相邻两层的实体进行交互的地方 两种国际标准OSI／RMTCP/IP 事实上的国际标准 面向连接服务无连接服务","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://vvshyer.com/tags/计算机网络/"}]},{"title":"OC学习之数学公式","date":"2017-02-28T11:48:42.000Z","path":"2017/02/28/OC学习之数学公式/","text":"1、 三角函数 double sin (double);正弦 double cos (double);余弦 double tan (double);正切 2 、反三角函数 double asin (double); 结果介于[-PI/2, PI/2] double acos (double); 结果介于[0, PI] double atan (double); 反正切(主值), 结果介于[-PI/2, PI/2] double atan2 (double, double); 反正切(整圆值), 结果介于[-PI, PI] 3 、双曲三角函数 double sinh (double); double cosh (double); double tanh (double); 4 、指数与对数 double exp (double);求取自然数e的幂 double sqrt (double);开平方 double log (double); 以e为底的对数 double log10 (double);以10为底的对数 double pow(double x, double y;计算以x为底数的y次幂 float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数 5 、取整 double ceil (double); 取上整 double floor (double); 取下整 6 、绝对值 double fabs (double);求绝对值 double cabs(struct complex znum) ;求复数的绝对值 7 、标准化浮点数 double frexp (double f, int p); 标准化浮点数, f = x 2^p, 已知f求x, p ( x介于[0.5, 1] ) double ldexp (double x, int p); 与frexp相反, 已知x, p求f 8 、取整与取余 double modf (double, double*); 将参数的整数部分通过指针回传, 返回小数部分 double fmod (double, double); 返回两参数相除的余数 9 、其他 double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x, int exponent);计算x*(2的exponent次幂) double poly(double x, int degree, double coeffs [] );计算多项式 int matherr(struct exception *e);数学错误计算处理程序","tags":[{"name":"iOS MAC Object-C","slug":"iOS-MAC-Object-C","permalink":"https://vvshyer.com/tags/iOS-MAC-Object-C/"}]},{"title":"OC学习之语法","date":"2017-02-28T02:39:06.000Z","path":"2017/02/28/OC学习之语法/","text":"类的定义 123@interface SimpleClass:NSObject类 @end 类的属性申明 1234@interface Person:NSObject@property NSString *firstName;@property NSSTring *lastName; @end 类的属性申明 123@property NSNumber *yearOfBirth;@property int yearOfBirth;@property(readonly) NSString *firstName; 减号方法（普通方法又称对象方法）申明 123456@interface Person:NSObject-(void)someMethod;-(void)someMethodWithValue:(SomeType)value;-(void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;@end 加号方法（类方法又称静态方法）申明 1234567@interface NSString:NSObject+(id)string;+(id)stringWithString:(NSString *)aString;+(id)stringWithFormat:(NSString *)format,...;+(id)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)errod;+(id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;@end 类的实现 123#import \"XYZPerson.h\"@implementation XYZPersion@end","tags":[{"name":"iOS MAC Object-C","slug":"iOS-MAC-Object-C","permalink":"https://vvshyer.com/tags/iOS-MAC-Object-C/"}]},{"title":"生日快乐","date":"2017-02-27T13:18:19.000Z","path":"2017/02/27/生日快乐/","text":"二月二，龙抬头。祝自己生日快乐。Happy birthday.","tags":[{"name":"随笔","slug":"随笔","permalink":"https://vvshyer.com/tags/随笔/"}]},{"title":"搭建FTP文件服务","date":"2017-01-22T06:39:10.000Z","path":"2017/01/22/搭建FTP文件服务/","text":"1.安装并启动FTP服务安装VSFTPD使用yum安装vsftpd:yum install vsftpd -y 启动VSFTPD安装完成后，启动FTP服务：service vsftpd start启动后，可以看到系统已经监听了21端口：netstat -nltp | grep 21此时，访问ftp://ip可浏览机器上的/var/ftp目录。 2.配置FTP权限目前FTP服务登录允许匿名登录，也无法区分用户访问，我们需要配置FTP访问权限。 了解VSFTP配置vsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件： vsftpd.conf 为主要配置文件 ftpusers 配置禁止访问 FTP 服务器的用户列表 user_list 配置用户访问控制阅读上述配置以了解更多信息。如果您准备好了，点击下一步开始修改配置来设置权限。阻止匿名访问和切换根目录匿名访问和切换根目录都会给服务器带来安全风险，我们把这两个功能关闭。编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：# 禁用匿名用户anonymous_enable=NO# 禁止切换根目录chroot_local_user=YES编辑完成后，按 Ctrl + S 保存配置，重新启动 FTP 服务，如：service vsftpd restart创建FTP用户创建一个用户 ftpuser:useradd ftpuser为用户 ftpuser 设置密码:echo &quot;NaOii3Qs | passwd ftpuser —stdin限制该用户仅能通过 FTP 访问限制用户 ftpuser 只能通过 FTP 访问服务器，而不能直接登录服务器：usermod -s /sbin/nologin ftpuser为用户分配主目录为用户 ftpuser 创建主目录并约定：/data/ftp 为主目录, 该目录不可上传文件/data/ftp/pub 文件只能上传到该目录下mkdir -p /data/ftp/pub创建登录欢迎文件 :echo &quot;Welcome to use FTP service.&quot; &gt; /data/ftp/welcome.txt设置访问权限：chmod a-w /data/ftp &amp;&amp; chmod 777 -R /data/ftp/pub设置为用户的主目录：usermod -d /data/ftp ftpuser","tags":[{"name":"FTP","slug":"FTP","permalink":"https://vvshyer.com/tags/FTP/"}]},{"title":"算法学习之堆","date":"2015-07-22T06:38:10.000Z","path":"2015/07/22/算法学习之堆/","text":"堆排序 Heap Sort堆和优先队列 Heap and Priority Queue什么是优先队列？普通队列：先进先出，后进后出优先队列：出队顺序和入队顺序无关，和优先级有关 优先队列主要操作入队出队（取出优先级最高的元素） 优先队列的实现入队 出队普通数组 O(1) O(n)顺序数组 O(n) O(1) 堆 O(lgn) O(lgn)对于总共N个请求使用普通数组或者顺序数组，最差情况是：O(n^2)使用堆：O(nlgn) 二叉堆堆中某个节点的值总是不大于其父节点的值；堆总是一棵完全二叉树（最大堆）用数组存储二叉堆 从根节点按行依次从左至右 Heapify的复杂度将n个元素逐个插入到一个空堆中，算法复杂度为O(nlogn)heapify的过程算法复杂度为O(n) 原地堆排序","tags":[{"name":"算法","slug":"算法","permalink":"https://vvshyer.com/tags/算法/"}]},{"title":"Oracle学习之JDBC","date":"2015-01-22T06:38:10.000Z","path":"2015/01/22/Oracle学习之JDBC/","text":"1.JDBC：Java Database Connectivity 在java中访问各种关系型数据库的一些API 2.JDBC所在的包：Java.sql.*; 3.常用的类和接口：DriverManager 程序驱动管理器（类） Connection 代表数据库连接（接口） Statement 声明，可以用来发送sql语句（接口） Boolean excute ResultSet excuteQuery Int executeUpdate Int[] executeUpdate resultSet 结果集（接口），代表查询结果 4.利用JDBC访问数据库的原理：//连接数据库，并向dept表中插一条记录： //1.加载驱动（按需访问） Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //2.获得连接 String url=&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;; String userName=&quot;c##scott&quot;; String password=&quot;tiger&quot;; Connection conn = DriverManager.getConnection(url,userName,password); System.out.println(&quot;连接成功&quot;); ;//代表连接 //3.获得声明 Statement st = null;//声明 //创建一个与conn关联的声明 st = conn.createStatement(); //4.发送sql st.execute(&quot;insert into dept values(45,&apos;开发部&apos;,&apos;哈尔滨&apos;)&quot;); //5.关闭资源 st.close(); conn.close(); 5.Statement的三个常用方法的区别：boolean execute：可以执行任何sql语句，如果此sql语句有查询结果，返回true，否则，false ResultSet getResultSet：获得查询结果集 int executeUpdate：执行DML和DDL，返回影响的记录的条数，如果是DDL，返回0 ResultSet executeQuery：专门执行select语句的方法，返回查询结果集 6.ResultSet的用法：代表查询语句的结果集； 两个重要的方法 .next()：移动记录的指针 .getXXX()：获取当前行的某个字段的值 rs = st.executeQuery(&quot;select * from dept&quot;); //遍历结果集 //是否存在下一条记录 while(rs.next()){ //取每一个字段值 int deptno = rs.getInt(1); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); System.out.println(deptno+&quot;\\t&quot;+dname+&quot;\\t&quot;+loc); } 7.DAO:Data Access Object; 对数据操作的封装 DeptDao{ insert(Dept dept); update(Dept dept); } VO:Value Object java中我们使用的类 数据库中我们使用的表 8.PreparedStatement：这是Statement的子接口，是预编译的Statement，与Statement相比，PreparedStatement在多次执行同一类语句性能更好；同时可以解决sql注入的问题","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之E-R图","date":"2015-01-20T07:23:49.000Z","path":"2015/01/20/Oracle学习之E-R图/","text":"软件开发生命周期：1.可行性分析：做还是不做 2.需求分析：做什么 3.概要设计 4.系统实现 5.测试：单元测试，黑盒，白盒，集成测试，性能测试（压力测试） 6.运行维护：（运维人员） 1.建模：E-R图： 实体，关系图： 三要素： 实体：表 属性：列 关系：一对一，一对多，多对多 2.PowerDesinger简称：PD 是一个建模工具软件，可以利用这个软件绘制E-R图 3.使用PD创建E-R图的步骤：1.新建一个概念E-R图 2.创建实例，属性，并建立关系，如果是一对多，不要在多的那个实体中自定义外键列， 只需要建立一对多关系即可，外键会自动生成 3.将概念E-R图转换成Oracle的物理E-R图 4.生成建表的sql语句 思路：概念-&gt;物理-&gt;语句 4.多对多的实现方式：学生表 科目表 中间表 5.一对一：唯一外键： 是一对多的一个特例，在外键列上再增加一个unique约束即可； 相同主键： 两个表的主键是一个列，从表的主键列还是外键 6.范式：1NF：主键，列的值不能为一组值（集合） 2NF：满足1NF，消除部分依赖 3NF：满足2NF，消除传递依赖 BCNF","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之数据库对象","date":"2015-01-18T06:35:35.000Z","path":"2015/01/18/Oracle学习之数据库对象/","text":"1.数据库对象：表是最基本的数据库对象，作用是用来存储数据 2.其它常用的数据库对象：同义词： 序列： 视图： 索引： 函数： 存储过程： 触发器： 3.序列：用来产生唯一，连续的序号； 生成主键； Create sequence 序列名 Start with Increment by：增量 Maxvalue：最大值 Minvalue：最小值 Cycle | nocycle：是否循环 cache：缓存 如何使用序列： 一定要在sql语句中使用； 序列名.nextVal：下一个值 序列名.currVal：当前值 4.分析函数：Rank() over() 一起使用 Rank()：生成序号，如果比较大小时相同，则序号相同，下一个序列会空出来，的例如 1 1 3 Dense_rank()：生成序号，与rank相比，值相同，序号相同，但不同有空余的序号 1 1 2 Row_number()：函数与rownum伪列相同 Select rank() over(order by sal),emp.* from emp; 5.视图：一个命名的查询语句，也可称为虚拟表 优点： 安全 隔离基表的改变 创建视图： Create view view_name as 查询语句; 创建一个只读视图： Create view view_name as 查询语句 with read only; 对视图中的字段进行重命名： Create view view_name(新名) as 查询语句 对视图进行删除，插入，修改的操作： 如果对视图进行以上操作，实际上是对视图所关联的表进行操作，并不是所有的视图都可以做以上操作； 视图中的数据中的数据必须来自表中的真实数据才可以 6.索引：用来提高查询速度的一个对象： Create index 索引名 on 表名（列名） 7.数据库备份：dos下直接输入两个命令 导入： Imp 导出： Exp 8.数据字典：元数据的数据： $ Dba_ all_ user_tables…","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之DCL","date":"2015-01-17T05:24:41.000Z","path":"2015/01/17/Oracle学习之DCL/","text":"1.oracle常用的用户：Sys： 系统管理员 创建数据库，启动数据库，关闭数据库 System： 数据库管理员 数据库启动后，可以使用数据库的任何权限 scott： 示例用户 2.创建用户：Create user USER_NAME identified by PASSWORD; 3.oracle中权限的分类：系统权限： 用户使用系统资源的权限，例如：登陆，创建表，修改表，创建函数等 对象权限： 一个用户使用其他用户的资源，例如：利用scott来查询student用户的表 4.授权：Grant 权限 to 用户; Grant create session to student; 5.角色：即权限的组合（集合） 常用的角色： Connect 登陆 Resource 普通用户的常用权限的集合 dba 数据库管理员 6.撤销权限：Revoke 权限 from 用户 7.对象权限：例如： student能否删除，修改，查询scott.emp表 Grant select/insert/all on emp to student; Revokde select/insert/all on emp from student; 8.事务：Transaction 是用户自定义的一个操作序列，这个操作序列式一个最小的执行单元 也就是说，要么全做，要么一个都不执行 事务的四个特性：ACID 原子性 最小的执行单位，不能再分 一致性 执行前后，应该保持一致状态 隔离性 多个事务之间，互不干扰 持久性 一旦事务提交，不能回退 9.事务控制语句：Commit 提交 Rollback 回退 savepoint 设置保存点 10.事务所涉及的操作：Update Delete Insert 11.以下情况会提交事务：手动commit提交 正常退出sqlplus环境 执行DDL语句 执行DCL语句 12.解锁用户：Alter user username account unlock;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之常用函数","date":"2015-01-16T10:31:41.000Z","path":"2015/01/16/Oracle学习之常用函数/","text":"1.常用函数字符： Lower：转小写 lower(&apos;Name&apos;); Upper：转大写 upper(&apos;name&apos;); Ltrim：去掉左空格 Rtrim：去掉右空格 Trim：去掉两边空格 Length：求长度 Instr：求字串的位置 instr(&apos;I love china&apos;,&apos;china&apos;) : 8 Substr：截取子串 substr(&apos;I love&apos;,3,4) ：love Lpad：左边填充指定字符 lpad(&apos;hello&apos;,7,&apos;*&apos;) : **hello Rpad：右边填充指定字符 Initcap：将字符串每个首字母大写，其余转为小写 数字： Round：四舍五入 round(34.44) Trunc：直接截断 mod：取余 日期： Months_between：两个日期之间的越差 Months_between(date1,date2); Add_months：为日期增加几个月 Add_months(sysdate,4); sysdate：返回当前时间 Last_day：当前日期所在月的最后一天的日期 Last_day(sysdate); Next_day：指定日期后第一个星期几的日期 Next_day(sysdate,1); 日期直接+数字：代表加的是天数 转换： To_Date：将字符串转换成日期 To_date(&apos;19980908&apos;,&apos;yyyyMMdd&apos;); To_char：将日期转换成字符串 To_char(sysdate,&apos;yyyy-MM-dd&apos;); To_number：转换成数字 To_number(&apos; 1234&apos;,&apos;990000&apos;); 其他： nvl：对null进行处理的函数 Nvl(comm,0)：如果comm的值为空，返回0，否则，返回的还是comm的值 decode：解码，相当于if else语句 2.case语句：可以在查询中进行判断，语法是： Select Case When 条件1 then 结果 When 条件2 then 结果 Else 结果3 End score,name from emp;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之高级查询","date":"2015-01-15T10:29:13.000Z","path":"2015/01/15/Oracle学习之高级查询/","text":"#1.表连接： 内连接： (Oracle写法):select from table_name,table_name2 [where 条件]; (标准sql语法):select from emp inner join dept on dept.deptno=emp.deptno; 如果from后，加入多个表时，查询的结果应该是两个表中的乘积；(列的和，记录的积) 外连接： 左外连接： 以左边的表为准，将左表中的数据全都查询出来，如果右表没有对应的录，则在右表的字段内显示null; (Oracle写法)select from emp,dept where emp.dept=dept.deptno(+); (标准sql语法)select from emp left [outer] join dept on dept.deptno=emp.deptno; 右外连接： 以右边的表为准，将右表中的数据全都查询出来，如果左表没有对应的录，则在左表的字段内显示null; (Oracle写法)select from emp,dept where emp.dept(+)=dept.deptno; (标准sql语法)select from emp right [outer] join dept on dept.deptno=emp.deptno; 全外连接： 左右表中的数据都至少显示一次； (标准sql语法):select * from emp full [outer] join dept on dept.deptno=emp.deptno; 2.子查询(嵌套查询)： 指一个查询中还包含另外一个查询体，也可以理解为，将一个查询结果作为另一个查询的查询条件； 常用的谓词： Any, all, in, not in Exists 存在 select * from dept d where exists(sql查询); 如果exists中的查询有记录，返回true，否则，返回false； 实例： --查询sales或者research部门的员工 select * from emp where deptno in (select deptno from dept where dname=&apos;SALES&apos; or dname=&apos;RESEARCH&apos;); select * from dept; --查询比平均工资高的员工信息 select * from emp where sal&gt;(select avg(sal) from emp); --查询比20部门所有员工工资都高的员工信息 select * from emp where sal&lt;all(select sal from emp where deptno=30); --查询出没有员工的部门 1.select * from dept where deptno not in( select distinct deptno from emp); 2.select * from dept d where not exists (select * from emp where d.deptno=emp.deptno); 3.集合查询：交，并，差 要求：两个查询结果的列数一样，数据类型匹配 Union [all]: 并 不排序 Intersect: 交 Minus: 差 4.递归查询(树查询)：Connect by prior 后设置的是递归查询的连接条件 Start with 后设置的是从哪个记录开始进行递归查询 使用递归查询要求： 这个表中应该是一个自连接的表 可以使用level这个伪列，来查询层级值 实例： select level,emp.* from emp connect by prior empno=mgr start with mgr is null; 5.两个伪列Rownum 行号 行号的算法不是先生成编号，而是满足条件后，才生成行号； 因此不能使用where rownum=2,rownum&gt;3这样的语法，这样不会查出任何记录 Rowid 行的唯一标识 表空间 -&gt;段-&gt;区-&gt;块 比主键更唯一，在全局是唯一的 6.通过rownum可以实现Oracle的分页查询实例： select * from ( select rownum r,a.* from( select * from emp order by sal desc) a where rownum&lt;11) b where b.r&lt;5;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之DML","date":"2015-01-14T13:24:46.000Z","path":"2015/01/14/Oracle学习之DML/","text":"1.dml数据操作语言： 对表中的记录进行操作 Insert 插入 Update 修改更新 Delete 删除 Select 选择 2.insert:1.插入一整条记录： Insert into 表名 values(数据)； 2.指定字段： Insert into 表名(列名) values(); 3.一次性插入多条记录： Insert into 表名(列名) select语句; 3.update: 修改Update 表名 set 列名=新值[,列名2=新值,…][where 条件]; 4.delete: 删除Delete from 表名 [where 条件]; 5.select: 选择Select *|distinct 列名1,…. 表达式 from 表名或视图名 [where 条件] [group by 分组条件 [having 分组后条件]] [order by 排序字段 asc|desc]; 6.列别名的问题:如果在查询中需要给列重新设置一个别名，可以使用&lt;as 列别名&gt;的方式，as 可以省略， 如果别名中出现空格，整个别名应该用双引号引起; Select sal*15 as &quot;salary of year&quot; from emp; 7.to_char函数将日期转换为字符的函数 To_char(日期值,&apos;格式&apos;); 例如： To_char(hiredate,&apos;YYYY-MM-dd&apos;); 8.oralce中的连接字符串运算符使用||.9.常用查询条件：查询条件 谓词 比较 =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，not+上述比较运算符 确定范围 Between and，not between and 确定集合 In，not in 字符匹配 Like，not like 空 Is null， is not null 多重条件 And，or 10.in 的使用：In:可以确定一个不连续的范围： Select * from emp where job in(&quot;MANAGER&apos;,&apos;CLERK&apos;); Not in:不在一个范围： Select * from emp where job not in(&quot;MANAGER&apos;,&apos;CLERK&apos;); 11.like的使用：模糊查询： 通配符： _：任意一个字符； %：任意多个字符（0到多）； Select * from emp where ename like &apos;%A%&apos;; 12.对于null的比较：null代表空，只能通过特殊的运算符进行比较 Is null 或 is not null 如果通过=null进行比较，永远返回false 13.聚集函数：增强检索功能 函数 功能 Count([Distinct|ALL]*) 统计记录个数 Count([Distinct|ALL]&lt;列名&gt;) 统计一列中值的个数 SUM([Distinct|ALL]&lt;列名&gt;) 计算一列的总和(必须为数值型) AVG([Distinct|ALL]&lt;列名&gt;) 计算一列的平均值(必须为数值型) MAX([Distinct|ALL]&lt;列名&gt;) 计算一列的最大值(必须为数值型) MIN([Distinct|ALL]&lt;列名&gt;) 计算一列的最小值(必须为数值型)","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之Oracle基础","date":"2015-01-13T06:18:28.000Z","path":"2015/01/13/Oracle学习之Oracle基础/","text":"1.未来计划：Oracle:数据库，mySql， powerDesigner jdbc:操作数据库的API，反射，annotation web编程 Html css javascript javaEE: servlet, jsp, jstl, xml, ajax,jquery tomcat 项目实践 2.数据库产品类型：单机版： access; foxbase; 无法数据共享 网络版： mySQL: oracle公司的产品，免费开源 SQLServer: 微软 Oracle: Oracle公司 Db2: IBM公司 3.RDBMS的基本概念 表是最小的一个存储单元 整体思路：先将需要处理的数据进行分类后，存储在各个相互关联的表中 4.Oracle的主要服务：OracleXXXListener: 监听器1521 OracleSercviceXXX: Oracle实例 OracleDbConsoleXXX: Oracle企业管理器 常用工具： Oracle Universal Installer(Oracle全局安装器) 安装卸载数据库管理系统 Datebase Configuration Assistant(数据库配置助手) 创建/配置/删除/管理模板 Net Configuration Assistant(网络配置助手) 监听器/命名方法/本地网络服务名/目录使用配置 SQL PLUS Oracle 经典操作平台 基于命令行 SQL Developer Oracle 图形操作平台 基于java PL/SQL Developer 企业中广泛使用的操作平台 5.SQL语句的分类结构化查询语言： 数据定义语言(DDL)： Create, Drop, Alter, Truncate 数据操作语言(DML)： Upate, Insert, Delete, Select(增删改查) 数据控制语言(DCL)： Grant(授予),Revoke(解除) 事物控制语言(TCL)： commit, rollback, savepoint 6.Create：创建作用：创建数据库对象，例如： 表，用户，索引，视图 创建表的语法 create table 表名( 列名 数据类型 [约束], …………… , [表级约束] ) 7.Oracle数据类型：数字： number(4) 表示最多4位数 number(4,2) 表示最多4位数，2位小数 字符： varchar(10) 可变字符 最多10个长度，根据值开辟空间 char(10) 不可变字符 保证占10个长度 varchar2 nvarchar 可变字符 最多10个长度，根据值开辟空间 采用unicode字符集 日期： Date timeStamp 更精确 大对象： BLOB 4G/字段 存在数据库内部 BFILE 4G/字段 存在文件中 CLOB 4G/字段 大文本的 NCLOB 4G/字段 大文本的 采用unicode字符集 oracle数据库密码：Oracle123 8.创建一个学生表： Create table TB_STUDENT( sno number(5) primary key, sname varchar(20), sex varchar(5), birth date ); 查看表结构： Desc 表名; 9.对scott账户解锁：1.使用管理员登录 dos下： sqlplus / as sysdba 2.解锁： alter user scott account 3.改密码： alter user scott identified by tiger 4.重新登录 10.约束的类型：主键：一个表只能有一个主键，主键不能为空，不能重复，作用是唯一标识一条记录； primary key，主键通常与业务无关，无特殊含义。 非空：not null，不能为空，必填项 唯一：unique，不重复，可以为空，一个表可以有多个列是唯一约束 检查：check，可以自定义规则；比如性别 in(&apos;male&apos;,&apos;female&apos;) 外键：foreign key，外键的值必须在另一个表的主键中获取 11.insert语句：向表中插入记录 Insert into 表名 values(值,值2,…….); Insert into 表名(列名) values(值); 12.事例：create table t_person(pno number(5) primary key, 2 name varchar(20) not null, 3 email varchar(30) unique, 4 sex varchar(6) check (sex in (&apos;male&apos;,&apos;female&apos;)) 5 ); 13.修改表语句：ALTER TABLE &lt;表名&gt; ADD &lt;新列名&gt;&lt;数据类型&gt;[完整性约束] DROP &lt;完整性约束名&gt; MODIFY &lt;列名&gt;&lt;数据类型&gt; ; 向表添加新的列，修改列或删除列 添加表约束和删除表约束 1.添加新列 Alter table 表名 add 列名 列类型; 2.删除列 Alter table stu drop column sex; 3.修改列的类型 Alter table stu modify sex varchar(15); 4.添加主键 Alter table stu add primary key (id); 5.删除主键 Alter table stu drop primary key; 5.添加外键 Alter table test2 add constraint foreign_key_name foreign key (Name) references emp(EMPNO); 6.删除表： Drop table 表名; 删除表结构，表中的数据都将被删除; 7.截断表： Truncate table 表名; 将表中所有数据清空，表仍保留","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]}]