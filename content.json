[{"title":"机试笔记03Hash的应用","date":"2017-03-09T07:50:27.000Z","path":"2017/03/09/机试笔记03Hash的应用/","text":"统计同成绩学生人数 读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int n; while (scanf(\"%d\",&amp;n) != EOF &amp;&amp; n != 0) &#123; int Hash[101] = &#123;0&#125;;//建立一个初始为0的Hash数组 for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\",&amp;x); Hash[x]++;//统计分数出现次数 &#125; int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",Hash[x]); &#125; return 0;&#125; Sort 给你 n 个整数，请按从大到小的顺序输出其中前 m 大的数。 每组测试数据有两行，第一行有两个数 n,m(0&lt;n,m&lt;1000000)，第二行包含 n 个各不相同，且都处于区间[-500000,500000]的整数。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define OFFSET 500000int Hash[1000001];int main()&#123; int n,m; while (scanf(\"%d%d\",&amp;n,&amp;m) != EOF) &#123; for (int i=-500000;i&lt;=500000; i++) &#123; Hash[i+OFFSET] = 0; &#125;//初始化 将每个数字都标记为未出现 for (int i=1; i&lt;=n; i++) &#123; int x; scanf(\"%d\",&amp;x); Hash[x+OFFSET] = 1;//凡是出现过的数字，该数组元素均为1 &#125; for (int i = 500000; i&gt;=-500000; i--) &#123;//输出前m个数 if (Hash[i+OFFSET]==1) &#123;//若该数字在输入中出现 printf(\"%d\",i);//输出该数字 m--;//输出一个数字后，m-- if (m!=0) &#123; printf(\" \"); &#125;else&#123; printf(\"\\n\"); break; &#125; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记02日期类问题","date":"2017-03-08T13:39:59.000Z","path":"2017/03/08/机试笔记02日期类问题/","text":"日期差值 在保存某个特定日期与原点日期的天数差时，用了三位数组 输入采用技巧 涉及开辟大量内存空间的情况，必须在函数体外定义或者动态malloc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0//定义宏判断是否是闰年，方便计算每月天数int dayOfMonth[13][2]&#123; 0,0, 31,31, //1 28,29, //2 31,31, //3 30,30, //4 31,31, //5 30,30, //6 31,31, //7 31,31, //8 30,30, //9 31,31, //10 30,30, //11 31,31 //12&#125;;struct Date&#123; int Day; int Month; int Year; //计算下一天的日期 void nextDay()&#123; Day++; if(Day &gt; dayOfMonth[Month][ISYEAP(Year)])&#123; //若日数超过最大日数 Day = 1; Month++;//进入下一月 if(Month &gt; 12)&#123;//月数超过12 Month = 1; Year++; //进入下一年 &#125; &#125; &#125;&#125;;int buf[5001][13][32];//保存预处理天数int Abs(int x)&#123; //求绝对值 return x &lt; 0 ? -x : x;&#125;int main()&#123; Date tmp; int cnt = 0; //天数计数 tmp.Day = 1; tmp.Month = 1; tmp.Year = 0;//初始化日期类对象为0年1月1日 while(tmp.Year != 5001) &#123; //将该日与0年1月1日的天数差保存起来 buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay();//计算下一天日期 cnt++;//计算器累加，每经过一天计数器+1,代表与原点日期的间隔又增加一天 &#125; int d1, m1, y1; int d2, m2, y2; while (scanf(\"%4d%2d%2d\",&amp;y1,&amp;m1,&amp;d1) != EOF) &#123; scanf(\"%4d%2d%2d\",&amp;y2,&amp;m2,&amp;d2);//读入要计算的两个日期 //用预处理的数据计算两日期差值，取绝对值 printf(\"%d\\n\",Abs(buf[y2][m2][d2] - buf[y1][m1][d1] + 1)); &#125; return 0;&#125; Day of Week 输入一个日期，要求输出该日期为星期几 1.今天是星期几; 2.今天和所给定的那天相隔几天。利用其对7求余数，我们便可以轻易的知道所给定的那天是星期几了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0//定义宏判断是否是闰年，方便计算每月天数int dayOfMonth[13][2]&#123; 0,0, 31,31, //1 28,29, //2 31,31, //3 30,30, //4 31,31, //5 30,30, //6 31,31, //7 31,31, //8 30,30, //9 31,31, //10 30,30, //11 31,31 //12&#125;;struct Date&#123; int Day; int Month; int Year; //计算下一天的日期 void nextDay()&#123; Day++; if(Day &gt; dayOfMonth[Month][ISYEAP(Year)])&#123; //若日数超过最大日数 Day = 1; Month++;//进入下一月 if(Month &gt; 12)&#123;//月数超过12 Month = 1; Year++; //进入下一年 &#125; &#125; &#125;&#125;;int buf[3001][13][32];//保存预处理天数char monthName[13][20] = &#123; \"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"&#125;;char weekName[7][20] = &#123; \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;;int main()&#123; Date tmp; int cnt = 0; //天数计数 tmp.Day = 1; tmp.Month = 1; tmp.Year = 0;//初始化日期类对象为0年1月1日 while(tmp.Year != 3001)&#123; //将该日与0年1月1日的天数差保存起来 buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay();//计算下一天日期 cnt++;//计算器累加，每经过一天计数器+1,代表与原点日期的间隔又增加一天 &#125; int d, m, y; char s[20]; while (scanf(\"%d%s%d\",&amp;d,s,&amp;y) != EOF) &#123; for (m = 1; m &lt;= 12; m++) &#123; if (strcmp(s,monthName[m]) == 0) &#123; break; &#125; &#125; //计算给定日期与今日日期的天数间隔 int days = buf[y][m][d] - buf[2017][3][6]; //今天2017年3月6日为星期一，对应数组下标为1，则计算1经过days天后的下标 days = days+1; puts(weekName[(days % 7 + 7)%7]); &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"机试笔记01排序","date":"2017-03-07T11:24:03.000Z","path":"2017/03/07/机试笔记01排序/","text":"#冒泡排序12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main()&#123; int n; int buf[100]; while(scanf(\"%d\",&amp;n)!=EOF)&#123;//输入n,并实现多组数据输入 for (int i=0; i&lt;n; i++) &#123; scanf(\"%d\",&amp;buf[i]); &#125; for (int i=0; i&lt;n; i++) &#123; for (int j=0; j&lt;n-1-i; j++) &#123; if (buf[j]&gt;buf[j+1]) &#123; int tmp = buf[j]; buf[j] = buf[j+1]; buf[j+1] = tmp; &#125; &#125; &#125; for (int i=0; i&lt;n; i++) &#123; printf(\"%d \",buf[i]); &#125; printf(\"\\n\"); &#125; return 0;&#125; 1while(scanf(\"%d\",&amp;n)!=EOF) scanf函数是有返回值的，返回被输入函数成功复制的变量个数 此例中，若成功对n赋值，返回值为1 一般测试数据需要输入多组，需要对每组输入都输出相应答案 当输入已经到达结尾，scanf函数无法再为n赋值，scanf返回EOF 快速排序使用C++内置函数 sort 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int x, int y)&#123; //定义排序规则 return x&gt;y;&#125;int main()&#123; int n; int buf[100]; while (scanf(\"%d\",&amp;n)!=EOF) &#123; for (int i=0; i &lt; n; i++) &#123; scanf(\"%d\",&amp;buf[i]); &#125; //sort(buf,buf+n);//使用该重载形式，表明使用默认排序（递增） sort(buf,buf+n,cmp);//使用该重载形式，表明使用自定义规则 for (int i=0; i&lt;n; i++) &#123; printf(\"%d \",buf[i]); &#125; printf(\"\\n\"); &#125;&#125; #成绩排序 利用sort 题目描述 N 个学生的数据，将学生数据按成绩高低排序，如果成绩相同则按姓名 字符的字母序排序，如果姓名的字母序也相同则按照学生的年龄排序，并输出 N 个学生排序后的信息。 输入 测试数据有多组，每组输入第一行有一个整数 N(N&lt;=1000)，接下来的 N 行包括 N 个学生的数据。每个学生的数据包括姓名(长度不超过 100 的字符串)、年龄(整形数)、成绩(小于等于 100 的正数)。 输出 将学生信息按成绩进行排序，成绩相同的则按姓名的字母序进行排序。然后输出学生信息，按照如下格式:姓名 年龄 成绩 样例输入： 1233 abc 20 99bcd 19 97 bed 20 97 样例输出 123bcd 19 97 bed 20 97 abc 20 99 提示 学生姓名的字母序区分字母的大小写，如 A 要比 a 的字母序靠前(因为 A 的 ASC 码比 a 的 ASC 码要小)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;struct E&#123; char name[101]; int age; int score; bool operator &lt; (const E &amp;b) const&#123; //重载小于运算符 if(score != b.score) return score &lt; b.score; int tmp = strcmp(name, b.name); if(tmp != 0) return tmp&lt;0; else return age &lt; b.age; &#125;&#125;buf[100];//bool cmp(E a,E b)&#123;// if (a.score != b.score) &#123;// return a.score &lt; b.score;// &#125;// int tmp = strcmp(a.name, b.name);// if (tmp != 0) &#123;// return tmp &lt; 0;// &#125;else&#123;// return a.age &lt; b.age;// &#125;//&#125;int main()&#123; int n; while(scanf(\"%d\",&amp;n)!=EOF)&#123; for (int i=0; i&lt;n; i++) &#123; scanf(\"%s%d%d\",buf[i].name,&amp;buf[i].age,&amp;buf[i].score); &#125; //sort(buf, buf+n, cmp); sort(buf,buf+n); for (int i=0; i&lt;n; i++) &#123; printf(\"%s %d %d \\n\",buf[i].name,buf[i].age,buf[i].score); &#125; &#125; return 0;&#125;","tags":[{"name":"研究生之路","slug":"研究生之路","permalink":"https://vvshyer.com/tags/研究生之路/"}]},{"title":"计算机网络笔记01","date":"2017-03-01T13:56:07.000Z","path":"2017/03/01/计算机网络笔记01/","text":"第一章 概述 1.三网：电信网络、有线电视网络、计算机网络 2.起核心作用的是：计算机网络 3.计算机网络：是计算机技术与通信技术相结合形成了一门新的技术，即计算机之间的数据通信 计算机网络发展的五大阶段面向终端的网络（1957 - 1968）分组交换网络（1968 - 1984）网络体系结构的出现（1984 - 1986）Internet的出现（1986 - 今）新一代的计算机网络（ISDN）电路交换的三个阶段 建立连接 通信 释放连接 分组交换网的工作原理 子网划分： 通信子网和资源子网 节点交换机工作方式： 存储转发 在发送端，先把较长的报文划分成较短的、固定长度的数据段 每一个数据段前面添加上首部构成分组 分组交换网以“分组”作为数据传输单元 依次把各分组发送到接收端 接收端收到分组后剥去首部还原成报文 #分组首部的重要性 每一个分组的首部都含有地址等控制信息 分组交换网中的节点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个节点交换机 用这样的存储转发方式，最后分组就能到达最终目的地","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://vvshyer.com/tags/计算机网络/"}]},{"title":"OC学习之数学公式","date":"2017-02-28T11:48:42.000Z","path":"2017/02/28/OC学习之数学公式/","text":"1、 三角函数 double sin (double);正弦 double cos (double);余弦 double tan (double);正切 2 、反三角函数 double asin (double); 结果介于[-PI/2, PI/2] double acos (double); 结果介于[0, PI] double atan (double); 反正切(主值), 结果介于[-PI/2, PI/2] double atan2 (double, double); 反正切(整圆值), 结果介于[-PI, PI] 3 、双曲三角函数 double sinh (double); double cosh (double); double tanh (double); 4 、指数与对数 double exp (double);求取自然数e的幂 double sqrt (double);开平方 double log (double); 以e为底的对数 double log10 (double);以10为底的对数 double pow(double x, double y;计算以x为底数的y次幂 float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数 5 、取整 double ceil (double); 取上整 double floor (double); 取下整 6 、绝对值 double fabs (double);求绝对值 double cabs(struct complex znum) ;求复数的绝对值 7 、标准化浮点数 double frexp (double f, int p); 标准化浮点数, f = x 2^p, 已知f求x, p ( x介于[0.5, 1] ) double ldexp (double x, int p); 与frexp相反, 已知x, p求f 8 、取整与取余 double modf (double, double*); 将参数的整数部分通过指针回传, 返回小数部分 double fmod (double, double); 返回两参数相除的余数 9 、其他 double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x, int exponent);计算x*(2的exponent次幂) double poly(double x, int degree, double coeffs [] );计算多项式 int matherr(struct exception *e);数学错误计算处理程序","tags":[{"name":"iOS MAC Object-C","slug":"iOS-MAC-Object-C","permalink":"https://vvshyer.com/tags/iOS-MAC-Object-C/"}]},{"title":"OC学习之语法","date":"2017-02-28T02:39:06.000Z","path":"2017/02/28/OC学习之语法/","text":"类的定义 123@interface SimpleClass:NSObject类 @end 类的属性申明 1234@interface Person:NSObject@property NSString *firstName;@property NSSTring *lastName; @end 类的属性申明 123@property NSNumber *yearOfBirth;@property int yearOfBirth;@property(readonly) NSString *firstName; 减号方法（普通方法又称对象方法）申明 123456@interface Person:NSObject-(void)someMethod;-(void)someMethodWithValue:(SomeType)value;-(void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;@end 加号方法（类方法又称静态方法）申明 1234567@interface NSString:NSObject+(id)string;+(id)stringWithString:(NSString *)aString;+(id)stringWithFormat:(NSString *)format,...;+(id)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)errod;+(id)stringWithCString:(const char *)cString encoding:(NSStringEncoding)enc;@end 类的实现 123#import \"XYZPerson.h\"@implementation XYZPersion@end","tags":[{"name":"iOS MAC Object-C","slug":"iOS-MAC-Object-C","permalink":"https://vvshyer.com/tags/iOS-MAC-Object-C/"}]},{"title":"生日快乐","date":"2017-02-27T13:18:19.000Z","path":"2017/02/27/生日快乐/","text":"二月二，龙抬头。祝自己生日快乐。Happy birthday.","tags":[{"name":"随笔","slug":"随笔","permalink":"https://vvshyer.com/tags/随笔/"}]},{"title":"Oracle学习之JDBC","date":"2015-01-22T06:38:10.000Z","path":"2015/01/22/Oracle学习之JDBC/","text":"1.JDBC：Java Database Connectivity 在java中访问各种关系型数据库的一些API 2.JDBC所在的包：Java.sql.*; 3.常用的类和接口：DriverManager 程序驱动管理器（类） Connection 代表数据库连接（接口） Statement 声明，可以用来发送sql语句（接口） Boolean excute ResultSet excuteQuery Int executeUpdate Int[] executeUpdate resultSet 结果集（接口），代表查询结果 4.利用JDBC访问数据库的原理：//连接数据库，并向dept表中插一条记录： //1.加载驱动（按需访问） Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //2.获得连接 String url=&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;; String userName=&quot;c##scott&quot;; String password=&quot;tiger&quot;; Connection conn = DriverManager.getConnection(url,userName,password); System.out.println(&quot;连接成功&quot;); ;//代表连接 //3.获得声明 Statement st = null;//声明 //创建一个与conn关联的声明 st = conn.createStatement(); //4.发送sql st.execute(&quot;insert into dept values(45,&apos;开发部&apos;,&apos;哈尔滨&apos;)&quot;); //5.关闭资源 st.close(); conn.close(); 5.Statement的三个常用方法的区别：boolean execute：可以执行任何sql语句，如果此sql语句有查询结果，返回true，否则，false ResultSet getResultSet：获得查询结果集 int executeUpdate：执行DML和DDL，返回影响的记录的条数，如果是DDL，返回0 ResultSet executeQuery：专门执行select语句的方法，返回查询结果集 6.ResultSet的用法：代表查询语句的结果集； 两个重要的方法 .next()：移动记录的指针 .getXXX()：获取当前行的某个字段的值 rs = st.executeQuery(&quot;select * from dept&quot;); //遍历结果集 //是否存在下一条记录 while(rs.next()){ //取每一个字段值 int deptno = rs.getInt(1); String dname = rs.getString(&quot;dname&quot;); String loc = rs.getString(&quot;loc&quot;); System.out.println(deptno+&quot;\\t&quot;+dname+&quot;\\t&quot;+loc); } 7.DAO:Data Access Object; 对数据操作的封装 DeptDao{ insert(Dept dept); update(Dept dept); } VO:Value Object java中我们使用的类 数据库中我们使用的表 8.PreparedStatement：这是Statement的子接口，是预编译的Statement，与Statement相比，PreparedStatement在多次执行同一类语句性能更好；同时可以解决sql注入的问题","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之E-R图","date":"2015-01-20T07:23:49.000Z","path":"2015/01/20/Oracle学习之E-R图/","text":"软件开发生命周期：1.可行性分析：做还是不做 2.需求分析：做什么 3.概要设计 4.系统实现 5.测试：单元测试，黑盒，白盒，集成测试，性能测试（压力测试） 6.运行维护：（运维人员） 1.建模：E-R图： 实体，关系图： 三要素： 实体：表 属性：列 关系：一对一，一对多，多对多 2.PowerDesinger简称：PD 是一个建模工具软件，可以利用这个软件绘制E-R图 3.使用PD创建E-R图的步骤：1.新建一个概念E-R图 2.创建实例，属性，并建立关系，如果是一对多，不要在多的那个实体中自定义外键列， 只需要建立一对多关系即可，外键会自动生成 3.将概念E-R图转换成Oracle的物理E-R图 4.生成建表的sql语句 思路：概念-&gt;物理-&gt;语句 4.多对多的实现方式：学生表 科目表 中间表 5.一对一：唯一外键： 是一对多的一个特例，在外键列上再增加一个unique约束即可； 相同主键： 两个表的主键是一个列，从表的主键列还是外键 6.范式：1NF：主键，列的值不能为一组值（集合） 2NF：满足1NF，消除部分依赖 3NF：满足2NF，消除传递依赖 BCNF","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之数据库对象","date":"2015-01-18T06:35:35.000Z","path":"2015/01/18/Oracle学习之数据库对象/","text":"1.数据库对象：表是最基本的数据库对象，作用是用来存储数据 2.其它常用的数据库对象：同义词： 序列： 视图： 索引： 函数： 存储过程： 触发器： 3.序列：用来产生唯一，连续的序号； 生成主键； Create sequence 序列名 Start with Increment by：增量 Maxvalue：最大值 Minvalue：最小值 Cycle | nocycle：是否循环 cache：缓存 如何使用序列： 一定要在sql语句中使用； 序列名.nextVal：下一个值 序列名.currVal：当前值 4.分析函数：Rank() over() 一起使用 Rank()：生成序号，如果比较大小时相同，则序号相同，下一个序列会空出来，的例如 1 1 3 Dense_rank()：生成序号，与rank相比，值相同，序号相同，但不同有空余的序号 1 1 2 Row_number()：函数与rownum伪列相同 Select rank() over(order by sal),emp.* from emp; 5.视图：一个命名的查询语句，也可称为虚拟表 优点： 安全 隔离基表的改变 创建视图： Create view view_name as 查询语句; 创建一个只读视图： Create view view_name as 查询语句 with read only; 对视图中的字段进行重命名： Create view view_name(新名) as 查询语句 对视图进行删除，插入，修改的操作： 如果对视图进行以上操作，实际上是对视图所关联的表进行操作，并不是所有的视图都可以做以上操作； 视图中的数据中的数据必须来自表中的真实数据才可以 6.索引：用来提高查询速度的一个对象： Create index 索引名 on 表名（列名） 7.数据库备份：dos下直接输入两个命令 导入： Imp 导出： Exp 8.数据字典：元数据的数据： $ Dba_ all_ user_tables…","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之DCL","date":"2015-01-17T05:24:41.000Z","path":"2015/01/17/Oracle学习之DCL/","text":"1.oracle常用的用户：Sys： 系统管理员 创建数据库，启动数据库，关闭数据库 System： 数据库管理员 数据库启动后，可以使用数据库的任何权限 scott： 示例用户 2.创建用户：Create user USER_NAME identified by PASSWORD; 3.oracle中权限的分类：系统权限： 用户使用系统资源的权限，例如：登陆，创建表，修改表，创建函数等 对象权限： 一个用户使用其他用户的资源，例如：利用scott来查询student用户的表 4.授权：Grant 权限 to 用户; Grant create session to student; 5.角色：即权限的组合（集合） 常用的角色： Connect 登陆 Resource 普通用户的常用权限的集合 dba 数据库管理员 6.撤销权限：Revoke 权限 from 用户 7.对象权限：例如： student能否删除，修改，查询scott.emp表 Grant select/insert/all on emp to student; Revokde select/insert/all on emp from student; 8.事务：Transaction 是用户自定义的一个操作序列，这个操作序列式一个最小的执行单元 也就是说，要么全做，要么一个都不执行 事务的四个特性：ACID 原子性 最小的执行单位，不能再分 一致性 执行前后，应该保持一致状态 隔离性 多个事务之间，互不干扰 持久性 一旦事务提交，不能回退 9.事务控制语句：Commit 提交 Rollback 回退 savepoint 设置保存点 10.事务所涉及的操作：Update Delete Insert 11.以下情况会提交事务：手动commit提交 正常退出sqlplus环境 执行DDL语句 执行DCL语句 12.解锁用户：Alter user username account unlock;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之常用函数","date":"2015-01-16T10:31:41.000Z","path":"2015/01/16/Oracle学习之常用函数/","text":"1.常用函数字符： Lower：转小写 lower(&apos;Name&apos;); Upper：转大写 upper(&apos;name&apos;); Ltrim：去掉左空格 Rtrim：去掉右空格 Trim：去掉两边空格 Length：求长度 Instr：求字串的位置 instr(&apos;I love china&apos;,&apos;china&apos;) : 8 Substr：截取子串 substr(&apos;I love&apos;,3,4) ：love Lpad：左边填充指定字符 lpad(&apos;hello&apos;,7,&apos;*&apos;) : **hello Rpad：右边填充指定字符 Initcap：将字符串每个首字母大写，其余转为小写 数字： Round：四舍五入 round(34.44) Trunc：直接截断 mod：取余 日期： Months_between：两个日期之间的越差 Months_between(date1,date2); Add_months：为日期增加几个月 Add_months(sysdate,4); sysdate：返回当前时间 Last_day：当前日期所在月的最后一天的日期 Last_day(sysdate); Next_day：指定日期后第一个星期几的日期 Next_day(sysdate,1); 日期直接+数字：代表加的是天数 转换： To_Date：将字符串转换成日期 To_date(&apos;19980908&apos;,&apos;yyyyMMdd&apos;); To_char：将日期转换成字符串 To_char(sysdate,&apos;yyyy-MM-dd&apos;); To_number：转换成数字 To_number(&apos; 1234&apos;,&apos;990000&apos;); 其他： nvl：对null进行处理的函数 Nvl(comm,0)：如果comm的值为空，返回0，否则，返回的还是comm的值 decode：解码，相当于if else语句 2.case语句：可以在查询中进行判断，语法是： Select Case When 条件1 then 结果 When 条件2 then 结果 Else 结果3 End score,name from emp;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之高级查询","date":"2015-01-15T10:29:13.000Z","path":"2015/01/15/Oracle学习之高级查询/","text":"#1.表连接： 内连接： (Oracle写法):select from table_name,table_name2 [where 条件]; (标准sql语法):select from emp inner join dept on dept.deptno=emp.deptno; 如果from后，加入多个表时，查询的结果应该是两个表中的乘积；(列的和，记录的积) 外连接： 左外连接： 以左边的表为准，将左表中的数据全都查询出来，如果右表没有对应的录，则在右表的字段内显示null; (Oracle写法)select from emp,dept where emp.dept=dept.deptno(+); (标准sql语法)select from emp left [outer] join dept on dept.deptno=emp.deptno; 右外连接： 以右边的表为准，将右表中的数据全都查询出来，如果左表没有对应的录，则在左表的字段内显示null; (Oracle写法)select from emp,dept where emp.dept(+)=dept.deptno; (标准sql语法)select from emp right [outer] join dept on dept.deptno=emp.deptno; 全外连接： 左右表中的数据都至少显示一次； (标准sql语法):select * from emp full [outer] join dept on dept.deptno=emp.deptno; 2.子查询(嵌套查询)： 指一个查询中还包含另外一个查询体，也可以理解为，将一个查询结果作为另一个查询的查询条件； 常用的谓词： Any, all, in, not in Exists 存在 select * from dept d where exists(sql查询); 如果exists中的查询有记录，返回true，否则，返回false； 实例： --查询sales或者research部门的员工 select * from emp where deptno in (select deptno from dept where dname=&apos;SALES&apos; or dname=&apos;RESEARCH&apos;); select * from dept; --查询比平均工资高的员工信息 select * from emp where sal&gt;(select avg(sal) from emp); --查询比20部门所有员工工资都高的员工信息 select * from emp where sal&lt;all(select sal from emp where deptno=30); --查询出没有员工的部门 1.select * from dept where deptno not in( select distinct deptno from emp); 2.select * from dept d where not exists (select * from emp where d.deptno=emp.deptno); 3.集合查询：交，并，差 要求：两个查询结果的列数一样，数据类型匹配 Union [all]: 并 不排序 Intersect: 交 Minus: 差 4.递归查询(树查询)：Connect by prior 后设置的是递归查询的连接条件 Start with 后设置的是从哪个记录开始进行递归查询 使用递归查询要求： 这个表中应该是一个自连接的表 可以使用level这个伪列，来查询层级值 实例： select level,emp.* from emp connect by prior empno=mgr start with mgr is null; 5.两个伪列Rownum 行号 行号的算法不是先生成编号，而是满足条件后，才生成行号； 因此不能使用where rownum=2,rownum&gt;3这样的语法，这样不会查出任何记录 Rowid 行的唯一标识 表空间 -&gt;段-&gt;区-&gt;块 比主键更唯一，在全局是唯一的 6.通过rownum可以实现Oracle的分页查询实例： select * from ( select rownum r,a.* from( select * from emp order by sal desc) a where rownum&lt;11) b where b.r&lt;5;","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之DML","date":"2015-01-14T13:24:46.000Z","path":"2015/01/14/Oracle学习之DML/","text":"1.dml数据操作语言： 对表中的记录进行操作 Insert 插入 Update 修改更新 Delete 删除 Select 选择 2.insert:1.插入一整条记录： Insert into 表名 values(数据)； 2.指定字段： Insert into 表名(列名) values(); 3.一次性插入多条记录： Insert into 表名(列名) select语句; 3.update: 修改Update 表名 set 列名=新值[,列名2=新值,…][where 条件]; 4.delete: 删除Delete from 表名 [where 条件]; 5.select: 选择Select *|distinct 列名1,…. 表达式 from 表名或视图名 [where 条件] [group by 分组条件 [having 分组后条件]] [order by 排序字段 asc|desc]; 6.列别名的问题:如果在查询中需要给列重新设置一个别名，可以使用&lt;as 列别名&gt;的方式，as 可以省略， 如果别名中出现空格，整个别名应该用双引号引起; Select sal*15 as &quot;salary of year&quot; from emp; 7.to_char函数将日期转换为字符的函数 To_char(日期值,&apos;格式&apos;); 例如： To_char(hiredate,&apos;YYYY-MM-dd&apos;); 8.oralce中的连接字符串运算符使用||.9.常用查询条件：查询条件 谓词 比较 =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，not+上述比较运算符 确定范围 Between and，not between and 确定集合 In，not in 字符匹配 Like，not like 空 Is null， is not null 多重条件 And，or 10.in 的使用：In:可以确定一个不连续的范围： Select * from emp where job in(&quot;MANAGER&apos;,&apos;CLERK&apos;); Not in:不在一个范围： Select * from emp where job not in(&quot;MANAGER&apos;,&apos;CLERK&apos;); 11.like的使用：模糊查询： 通配符： _：任意一个字符； %：任意多个字符（0到多）； Select * from emp where ename like &apos;%A%&apos;; 12.对于null的比较：null代表空，只能通过特殊的运算符进行比较 Is null 或 is not null 如果通过=null进行比较，永远返回false 13.聚集函数：增强检索功能 函数 功能 Count([Distinct|ALL]*) 统计记录个数 Count([Distinct|ALL]&lt;列名&gt;) 统计一列中值的个数 SUM([Distinct|ALL]&lt;列名&gt;) 计算一列的总和(必须为数值型) AVG([Distinct|ALL]&lt;列名&gt;) 计算一列的平均值(必须为数值型) MAX([Distinct|ALL]&lt;列名&gt;) 计算一列的最大值(必须为数值型) MIN([Distinct|ALL]&lt;列名&gt;) 计算一列的最小值(必须为数值型)","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]},{"title":"Oracle学习之Oracle基础","date":"2015-01-13T06:18:28.000Z","path":"2015/01/13/Oracle学习之Oracle基础/","text":"1.未来计划：Oracle:数据库，mySql， powerDesigner jdbc:操作数据库的API，反射，annotation web编程 Html css javascript javaEE: servlet, jsp, jstl, xml, ajax,jquery tomcat 项目实践 2.数据库产品类型：单机版： access; foxbase; 无法数据共享 网络版： mySQL: oracle公司的产品，免费开源 SQLServer: 微软 Oracle: Oracle公司 Db2: IBM公司 3.RDBMS的基本概念 表是最小的一个存储单元 整体思路：先将需要处理的数据进行分类后，存储在各个相互关联的表中 4.Oracle的主要服务：OracleXXXListener: 监听器1521 OracleSercviceXXX: Oracle实例 OracleDbConsoleXXX: Oracle企业管理器 常用工具： Oracle Universal Installer(Oracle全局安装器) 安装卸载数据库管理系统 Datebase Configuration Assistant(数据库配置助手) 创建/配置/删除/管理模板 Net Configuration Assistant(网络配置助手) 监听器/命名方法/本地网络服务名/目录使用配置 SQL PLUS Oracle 经典操作平台 基于命令行 SQL Developer Oracle 图形操作平台 基于java PL/SQL Developer 企业中广泛使用的操作平台 5.SQL语句的分类结构化查询语言： 数据定义语言(DDL)： Create, Drop, Alter, Truncate 数据操作语言(DML)： Upate, Insert, Delete, Select(增删改查) 数据控制语言(DCL)： Grant(授予),Revoke(解除) 事物控制语言(TCL)： commit, rollback, savepoint 6.Create：创建作用：创建数据库对象，例如： 表，用户，索引，视图 创建表的语法 create table 表名( 列名 数据类型 [约束], …………… , [表级约束] ) 7.Oracle数据类型：数字： number(4) 表示最多4位数 number(4,2) 表示最多4位数，2位小数 字符： varchar(10) 可变字符 最多10个长度，根据值开辟空间 char(10) 不可变字符 保证占10个长度 varchar2 nvarchar 可变字符 最多10个长度，根据值开辟空间 采用unicode字符集 日期： Date timeStamp 更精确 大对象： BLOB 4G/字段 存在数据库内部 BFILE 4G/字段 存在文件中 CLOB 4G/字段 大文本的 NCLOB 4G/字段 大文本的 采用unicode字符集 oracle数据库密码：Oracle123 8.创建一个学生表： Create table TB_STUDENT( sno number(5) primary key, sname varchar(20), sex varchar(5), birth date ); 查看表结构： Desc 表名; 9.对scott账户解锁：1.使用管理员登录 dos下： sqlplus / as sysdba 2.解锁： alter user scott account 3.改密码： alter user scott identified by tiger 4.重新登录 10.约束的类型：主键：一个表只能有一个主键，主键不能为空，不能重复，作用是唯一标识一条记录； primary key，主键通常与业务无关，无特殊含义。 非空：not null，不能为空，必填项 唯一：unique，不重复，可以为空，一个表可以有多个列是唯一约束 检查：check，可以自定义规则；比如性别 in(&apos;male&apos;,&apos;female&apos;) 外键：foreign key，外键的值必须在另一个表的主键中获取 11.insert语句：向表中插入记录 Insert into 表名 values(值,值2,…….); Insert into 表名(列名) values(值); 12.事例：create table t_person(pno number(5) primary key, 2 name varchar(20) not null, 3 email varchar(30) unique, 4 sex varchar(6) check (sex in (&apos;male&apos;,&apos;female&apos;)) 5 ); 13.修改表语句：ALTER TABLE &lt;表名&gt; ADD &lt;新列名&gt;&lt;数据类型&gt;[完整性约束] DROP &lt;完整性约束名&gt; MODIFY &lt;列名&gt;&lt;数据类型&gt; ; 向表添加新的列，修改列或删除列 添加表约束和删除表约束 1.添加新列 Alter table 表名 add 列名 列类型; 2.删除列 Alter table stu drop column sex; 3.修改列的类型 Alter table stu modify sex varchar(15); 4.添加主键 Alter table stu add primary key (id); 5.删除主键 Alter table stu drop primary key; 5.添加外键 Alter table test2 add constraint foreign_key_name foreign key (Name) references emp(EMPNO); 6.删除表： Drop table 表名; 删除表结构，表中的数据都将被删除; 7.截断表： Truncate table 表名; 将表中所有数据清空，表仍保留","tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://vvshyer.com/tags/Oracle/"}]}]